{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"해시 테이블 1. 개념 해시 - 고기와 감자를 잘게다져 요리한것. 키 값을 잘게 다져 특정 인덱스로 변경\n-> 키와 값을 받아 키를 해싱(잘게 쪼개어)하여 도출된 인덱스에 값을 저장하는 구조 해시테이블이란?  입력받은 값을 특정범위내의 숫자로 변경하는 함수 2. 해시충돌 해시함수를 거친 값이 동일하다면, 데이터가 삽입되는 위치가 중복되는 현상 2-1. 해…","fields":{"slug":"/22_08_28/"},"frontmatter":{"date":"August 28, 2022","title":"✏️ 2022-08-28 Today I Learn","tags":["TIL","HTTP","자료구조","Javascript"]},"rawMarkdownBody":"\n## 해시 테이블\n### 1. 개념\n> 해시 - 고기와 감자를 잘게다져 요리한것. 키 값을 잘게 다져 특정 인덱스로 변경\n> <br/>-> 키와 값을 받아 **키를 해싱(잘게 쪼개어)**하여 도출된 인덱스에 값을 저장하는 구조\n\n* **해시테이블이란?**<br/>  입력받은 값을 특정범위내의 숫자로 변경하는 함수\n\n### 2. 해시충돌\n> 해시함수를 거친 값이 동일하다면, 데이터가 삽입되는 위치가 중복되는 현상\n\n#### 2-1. 해시충돌해결방법 1 : 선형탐사법\n충돌이 발생하면 다음인덱스에 데이터 저장. 충돌이 발생하면 다른곳에 저장.\n\n#### 2-2. 해시충돌해결방법 2 : 제곱탐사법\n충돌이 발생한 지점의 제곱만큼 옆으로 이동하여 데이터 저장 \n\n#### 2-3. 해시충돌해결방법 3 : 이중 해싱 \nA함수를 이용해 충돌이 발생하면 B함수를 통해 해싱하는것\n\n#### 2-4. 해시충돌해결방법 4 : 분리 연결 \n충돌이 발생하면, 연결리스트로직을 이용해 메모리에 저장. 한 메모리 내에 차지하는 데이터가 무한정 늘어날수 있음.\n\n\n### 3.자바스크립트에서 해시테이블을 사용하는 방법\n1. 배열\n2. 객체\n3. **[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map,\"map_link\") :** 키와 값이 다르게 저장. 키로 여러가지 타입을 저장할 수 있음.\n4. **[Set](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set, \"set_link\") :** 키와 값이 동일하게 저장. 중복된 내용 제거\n"},{"excerpt":"1. Javascript 구조분해할당을 통해 Swap을 구현 할 수 있다. ES6 문법이므로 이하 지원브라우저에서는 사용할 수 없음. 2. Javascript shift() 를 이용한 큐 구현은 효율적이지 못하다. shift를 이용하게 되면, 빈 첫번째 메모리를 메우는 동작을 하기 때문에 n의 속도가 보장된다.\n따라서, 1의 속도를 보장해야하는 큐에서 적…","fields":{"slug":"/22_08_25/"},"frontmatter":{"date":"August 25, 2022","title":"✏️ 2022-08-25 Today I Learn","tags":["TIL","HTTP","Javascript"]},"rawMarkdownBody":"\n### 1. [Javascript] 구조분해할당을 통해 Swap을 구현 할 수 있다.\nES6 문법이므로 이하 지원브라우저에서는 사용할 수 없음.\n```javascript\nlet [a, b] = 1, 2\n\nconsole.log(a) // 1 \nconsole.log(b) // 2\n\n[b, a] = [a, b]\nconsole.log(a) // 2\nconsole.log(b) // 1\n```\n\n### 2. [Javascript] shift() 를 이용한 큐 구현은 효율적이지 못하다.\nshift를 이용하게 되면, 빈 첫번째 메모리를 메우는 동작을 하기 때문에 n의 속도가 보장된다.\n따라서, 1의 속도를 보장해야하는 큐에서 적절하지 못하다. 아래와 같이 delete 를 이용하여 사용하면된다.\n```javascript\nclass Node {\n    constructor(location, priority){\n        this.location = location;\n        this.priority = priority;\n    }\n}\n\nclass Queue {\n    constructor(){\n        this.queue = [];\n        this.head = 0;\n        this.rear = 0;\n    }\n    \n    enqueue(location, priority){\n        // 추가 시 길이를 1늘려준다.\n        this.queue[this.rear++] = new Node(location, priority)\n    }\n    \n    dequeue(){\n        // 삭제시 앞에 빈칸을 하나 추가하고, head의 인덱스를 1증가시킨다.\n        const value = this.queue[this.head]\n        delete this.queue[this.head++] // delete를 이용했기 때문에, 1의 속도를 보장한다.\n        return value\n    }\n}\n```\n\n### 3. [HTTP] 상태코드의 종류\n**1xx :** 요청이 수신되어 처리중 (거의사용하지않음)\n**2xx :** 정상처리\n**3xx :** ***요청을 완료하기 위해 추가적인 행동이 필요***\n**4xx :** ***클라이언트 오류***\n**5xx :** ***서버 오류***\n\n### 4. [HTTP] 상태코드 추론\n클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면 클라이언트는 **상위 상태코드**로 해석해서 처리한다.<br/>\n따라서, 미래에 새로운 상태코드가 추가되어도 클라이언트를 변경하지 않아도 된다. \n```\n388 -> 3xx\n499 -> 4xx \n```\n\n"},{"excerpt":"1. form 을 통한 데이터 전송 시 http contents type aplication/x-www-form-urlencoded : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다. multipart/form-data : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다. 2…","fields":{"slug":"/22_08_24/"},"frontmatter":{"date":"August 24, 2022","title":"✏️ 2022-08-24 Today I Learn","tags":["TIL","HTTP","자료구조","Javascript"]},"rawMarkdownBody":"\n### 1. form 을 통한 데이터 전송 시 http contents type\n- **aplication/x-www-form-urlencoded** : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다.\n- **multipart/form-data** : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다.\n\n### 2. HTML form으로 GET요청도 가능하다.\n\n### 3. PUT은 일부 업데이트가 아니다.\n기존의 리소스를 삭제하고 다른 리소스로 갈아치우는 것이기 때문에, 주의하여 사용해야한다.\n\n### 4. PATCH는 리소스의 일부 업데이트를 의미한다.\n\n### 5. HTTP 메소드의 속성\n- **안전** : 호출해도 리소스를 변경하지 않는다.\n    - GET, HEAD, OPTION, TRACE\n- **멱등** : 여러번 호출해도 같은 결과를 보여준다.\n    - GET, PUT, DELETE \n- **캐시** : 응답결과의 리소스를 반복하여 사용가능하다.\n    - GET, HEAD\n    - POST, PUT : 캐시키를 이용해 body값까지 모두 캐싱해야하기 때문에 번거로워서 잘 쓰이지 않는다.\n\n### 6. 메서드 설계 시 리소스에 해당되는 것은 '명사'이다.\nex) 미네랄을 캔다 에서 캔다가 중요요소가 아니라 미네랄을 기준으로 메서드를 설계해야한다.\nGET /minerals -> O\nGET /dig -> X \n\n### 7. GET은 스펙상으로 body를 붙힐 수 있다.\n구현이 되지 않은 서버가 많은 것일 뿐.\n\n### 8. HEAD는 body를 붙힐 수 없는 GET이라고 보면된다.\n\n### 9. POST는 리소스 상태의 변경을 위한 용도로도 사용된다.\n```\nPOST /car/{id}/start\nPOST /car/{id}/stop\n```\n이때는 메서드에 동사를 사용한다.\n\n### 10. POST와 PUT의 차이는 리소스의 정보를 어디서 알고있느냐의 차이다.\n- POST : 리소스의 생성을 요청하면, 서버에서 생성정보를 보내줌\n- PUT : 클라이언트에서 업데이트 할 리소스를 정해서 보내줌. 이 때, 클라이언트 내에 스토어로 리소스를 따로 관리해줘야하는 전제조건이 있다.\n\n### 11. 배열은 연속되는 순서로 메모리를 차지한다. 인덱스 값은 연속되지만, 주소값은 반드시 연속되어 증가하지 않는다.\n\n### 12. 자바스크립트 배열은 해시맵과 같아서, 논리값 할당이 가능하다. 단, 배열의 실제길이에 영향을 주지는 않는다.(사용권장X)\n\n### 13. 연결리스트는 메모리를 순서대로 차지하지 않는다. "}]}},"pageContext":{}},"staticQueryHashes":[]}