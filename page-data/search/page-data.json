{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"","fields":{"slug":"/Event_delegation/"},"frontmatter":{"date":"August 30, 2022","title":"이벤트 위임","tags":["TIL","Javascript","DOM Event"]},"rawMarkdownBody":"\n"},{"excerpt":"1. 이벤트 실행 우선순위 인라인 이벤트실행 -> addEventListener 이벤트 실행\n인라인 이벤트는 event 객체가 parameter로 넘겨지지 않습니다.","fields":{"slug":"/22_08_29/"},"frontmatter":{"date":"August 29, 2022","title":"✏️ 2022-08-29 Today I Learn","tags":["TIL","Javascript","DOM Event"]},"rawMarkdownBody":"\n## 1. 이벤트 실행 우선순위\n인라인 이벤트실행 -> addEventListener 이벤트 실행\n인라인 이벤트는 event 객체가 parameter로 넘겨지지 않습니다."},{"excerpt":"1. 버블링 정의 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는 현상.  2. 캡쳐링 정의 이벤트가 상위에서 하위로 전달되며 핸들러를 실행하는 현상.  위의 구조에서 c를 클릭했을 경우, 이벤트가…","fields":{"slug":"/Bubbling_Capturing/"},"frontmatter":{"date":"August 29, 2022","title":"이벤트 버블링/캡쳐링","tags":["TIL","Javascript","DOM Event"]},"rawMarkdownBody":"\n## 1. 버블링 정의\n> 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는 현상.\n\n<img src=\"https://ko.javascript.info/article/bubbling-and-capturing/event-order-bubbling.svg\" width=\"300\" alt=\"[출처]javascript korea\"></img>\n\n```html\n<div id=\"a\">\n    <div id=\"b\">\n        <div id=\"c\" onclick=\"handler\">\n        </div>\n    </div>\n</div>\n```\n\n## 2. 캡쳐링 정의\n> 이벤트가 상위에서 하위로 전달되며 핸들러를 실행하는 현상.\n\n<img src=\"https://ko.javascript.info/article/bubbling-and-capturing/eventflow.svg\" width=\"300\" alt=\"[출처]javascript korea\"></img>\n\n```html\n<div id=\"a\">\n    <div id=\"b\">\n        <div id=\"c\" onclick=\"handler\">\n        </div>\n    </div>\n</div>\n```\n\n위의 구조에서 c를 클릭했을 경우, 이벤트가 a -> b -> c 로 전파되는 현상을 의미한다.\n다음과 같이 event 를 등록 할 떄, capture option을 활성화하여 사용한다.\n```javascript\nel.addEventListener('click', event , {capture: true})\n\n// or \n\nel.addEventListener('click', event , true)\n```\n\n\n\n## 3. stopPropagation\n> propagation의 뜻은 **번식** 이다.\n부모 element로의 캡쳐링/버블링을 막기위해선, stopPropagation 을 사용한다.\n```html\n<div id=\"a\">\n    <div id=\"b\">\n        <div id=\"c\" onclick=\"(e)=>e.stopPropagation()\">\n        </div>\n    </div>\n</div>\n```\n\n을 실행하게 되면, 이벤트는 c에서만 실행되게 된다.\n\n\n## 4. stopImmediatePropagation\n같은 레벨에 여러가지 이벤트 리스너가 등록되어 있을 경우에, stopPropagation을 사용하면\n동일레벨에서의 메서드 실행을 제어하지 못한다.\n\n```html\n<div id=\"a\">\n    <div id=\"b\">\n        <div id=\"c\" onclick=\"A함수;B함수\">\n        </div>\n    </div>\n</div>\n```\n위의 케이스에서 A함수의 실행만 시키고 싶어 stopPropagation을 함수내부에서 호출하여도, 같은레벨의 B함수는 계속 실행된다.\n이유는 stopPropagation은 상위레벨로의 이벤트 전파만 방지하기 때문이다.\n\n위의 케이스에서는 stopImmediatePropatation을 사용하여, 같은레벨로 이벤트가 전파되는 것을 방지해준다.\n\n## 5. Bubbling 되지않는 메서드\n* focus \n\n## 6. event.target vs event.currentTarget vs event.eventPhase\n* **event.target :** 실제 이벤트가 발생한 타겟.\n* **event.currentTarget :** 현재 이벤트가 벌어지고 있는 모타겟.\n* **event.eventPhase :**  현재 이벤트 흐름 단계(캡처링=1, 타깃=2, 버블링=3)\n\n## 7. 버블링을 굳이 막을 필요는 없다.\n지금은 상위 요소에서 이벤트가 어떻게 쓰일지 확실치 않더라도, 추후에 버블링이 필요한 경우가 생기기 때문에 stopPropagation의 사용은 추천하지 않는다.\n\n## 8. Bubbling이 Default value가 된 배경.\n> 현실에서 사고가 발생하면 지역 경찰이 먼저 사고를 조사합니다. 그 지역에 대해 가장 잘 아는 기관은 지역 경찰이기 때문입니다. 추가 조사가 필요하다면 그 이후에 상위 기관이 사건을 넘겨받습니다.\n\n## 9. 이벤트 위임(event delegation)\n> 캡쳐링과 버블링을 이용한 이벤트 핸들링 패턴\n\n### 참고문헌\n* https://ko.javascript.info/bubbling-and-capturing\n* https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/"},{"excerpt":"해시 테이블 1. 개념 해시 - 고기와 감자를 잘게다져 요리한것. 키 값을 잘게 다져 특정 인덱스로 변경\n-> 키와 값을 받아 키를 해싱(잘게 쪼개어)하여 도출된 인덱스에 값을 저장하는 구조 해시테이블이란?  입력받은 값을 특정범위내의 숫자로 변경하는 함수 2. 해시충돌 해시함수를 거친 값이 동일하다면, 데이터가 삽입되는 위치가 중복되는 현상 2-1. 해…","fields":{"slug":"/22_08_28/"},"frontmatter":{"date":"August 28, 2022","title":"✏️ 2022-08-28 Today I Learn","tags":["TIL","HTTP","자료구조","Javascript"]},"rawMarkdownBody":"\n## 해시 테이블\n### 1. 개념\n> 해시 - 고기와 감자를 잘게다져 요리한것. 키 값을 잘게 다져 특정 인덱스로 변경\n> <br/>-> 키와 값을 받아 **키를 해싱(잘게 쪼개어)**하여 도출된 인덱스에 값을 저장하는 구조\n\n* **해시테이블이란?**<br/>  입력받은 값을 특정범위내의 숫자로 변경하는 함수\n\n### 2. 해시충돌\n> 해시함수를 거친 값이 동일하다면, 데이터가 삽입되는 위치가 중복되는 현상\n\n#### 2-1. 해시충돌해결방법 1 : 선형탐사법\n충돌이 발생하면 다음인덱스에 데이터 저장. 충돌이 발생하면 다른곳에 저장.\n\n#### 2-2. 해시충돌해결방법 2 : 제곱탐사법\n충돌이 발생한 지점의 제곱만큼 옆으로 이동하여 데이터 저장 \n\n#### 2-3. 해시충돌해결방법 3 : 이중 해싱 \nA함수를 이용해 충돌이 발생하면 B함수를 통해 해싱하는것\n\n#### 2-4. 해시충돌해결방법 4 : 분리 연결 \n충돌이 발생하면, 연결리스트로직을 이용해 메모리에 저장. 한 메모리 내에 차지하는 데이터가 무한정 늘어날수 있음.\n\n\n### 3.자바스크립트에서 해시테이블을 사용하는 방법\n1. 배열\n2. 객체\n3. **[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) :** 키와 값이 다르게 저장. 키로 여러가지 타입을 저장할 수 있음.\n4. **[Set](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set) :** 키와 값이 동일하게 저장. 중복된 내용 제거\n"},{"excerpt":"1. Javascript 구조분해할당을 통해 Swap을 구현 할 수 있다. ES6 문법이므로 이하 지원브라우저에서는 사용할 수 없음. 2. Javascript shift() 를 이용한 큐 구현은 효율적이지 못하다. shift를 이용하게 되면, 빈 첫번째 메모리를 메우는 동작을 하기 때문에 n의 속도가 보장된다.\n따라서, 1의 속도를 보장해야하는 큐에서 적…","fields":{"slug":"/22_08_25/"},"frontmatter":{"date":"August 25, 2022","title":"✏️ 2022-08-25 Today I Learn","tags":["TIL","HTTP","Javascript"]},"rawMarkdownBody":"\n### 1. [Javascript] 구조분해할당을 통해 Swap을 구현 할 수 있다.\nES6 문법이므로 이하 지원브라우저에서는 사용할 수 없음.\n```javascript\nlet [a, b] = 1, 2\n\nconsole.log(a) // 1 \nconsole.log(b) // 2\n\n[b, a] = [a, b]\nconsole.log(a) // 2\nconsole.log(b) // 1\n```\n\n### 2. [Javascript] shift() 를 이용한 큐 구현은 효율적이지 못하다.\nshift를 이용하게 되면, 빈 첫번째 메모리를 메우는 동작을 하기 때문에 n의 속도가 보장된다.\n따라서, 1의 속도를 보장해야하는 큐에서 적절하지 못하다. 아래와 같이 delete 를 이용하여 사용하면된다.\n```javascript\nclass Node {\n    constructor(location, priority){\n        this.location = location;\n        this.priority = priority;\n    }\n}\n\nclass Queue {\n    constructor(){\n        this.queue = [];\n        this.head = 0;\n        this.rear = 0;\n    }\n    \n    enqueue(location, priority){\n        // 추가 시 길이를 1늘려준다.\n        this.queue[this.rear++] = new Node(location, priority)\n    }\n    \n    dequeue(){\n        // 삭제시 앞에 빈칸을 하나 추가하고, head의 인덱스를 1증가시킨다.\n        const value = this.queue[this.head]\n        delete this.queue[this.head++] // delete를 이용했기 때문에, 1의 속도를 보장한다.\n        return value\n    }\n}\n```\n\n### 3. [HTTP] 상태코드의 종류\n**1xx :** 요청이 수신되어 처리중 (거의사용하지않음)\n**2xx :** 정상처리\n**3xx :** ***요청을 완료하기 위해 추가적인 행동이 필요***\n**4xx :** ***클라이언트 오류***\n**5xx :** ***서버 오류***\n\n### 4. [HTTP] 상태코드 추론\n클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면 클라이언트는 **상위 상태코드**로 해석해서 처리한다.<br/>\n따라서, 미래에 새로운 상태코드가 추가되어도 클라이언트를 변경하지 않아도 된다. \n```\n388 -> 3xx\n499 -> 4xx \n```\n\n"},{"excerpt":"1. form 을 통한 데이터 전송 시 http contents type aplication/x-www-form-urlencoded : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다. multipart/form-data : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다. 2…","fields":{"slug":"/22_08_24/"},"frontmatter":{"date":"August 24, 2022","title":"✏️ 2022-08-24 Today I Learn","tags":["TIL","HTTP","자료구조","Javascript"]},"rawMarkdownBody":"\n### 1. form 을 통한 데이터 전송 시 http contents type\n- **aplication/x-www-form-urlencoded** : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다.\n- **multipart/form-data** : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다.\n\n### 2. HTML form으로 GET요청도 가능하다.\n\n### 3. PUT은 일부 업데이트가 아니다.\n기존의 리소스를 삭제하고 다른 리소스로 갈아치우는 것이기 때문에, 주의하여 사용해야한다.\n\n### 4. PATCH는 리소스의 일부 업데이트를 의미한다.\n\n### 5. HTTP 메소드의 속성\n- **안전** : 호출해도 리소스를 변경하지 않는다.\n    - GET, HEAD, OPTION, TRACE\n- **멱등** : 여러번 호출해도 같은 결과를 보여준다.\n    - GET, PUT, DELETE \n- **캐시** : 응답결과의 리소스를 반복하여 사용가능하다.\n    - GET, HEAD\n    - POST, PUT : 캐시키를 이용해 body값까지 모두 캐싱해야하기 때문에 번거로워서 잘 쓰이지 않는다.\n\n### 6. 메서드 설계 시 리소스에 해당되는 것은 '명사'이다.\nex) 미네랄을 캔다 에서 캔다가 중요요소가 아니라 미네랄을 기준으로 메서드를 설계해야한다.\nGET /minerals -> O\nGET /dig -> X \n\n### 7. GET은 스펙상으로 body를 붙힐 수 있다.\n구현이 되지 않은 서버가 많은 것일 뿐.\n\n### 8. HEAD는 body를 붙힐 수 없는 GET이라고 보면된다.\n\n### 9. POST는 리소스 상태의 변경을 위한 용도로도 사용된다.\n```\nPOST /car/{id}/start\nPOST /car/{id}/stop\n```\n이때는 메서드에 동사를 사용한다.\n\n### 10. POST와 PUT의 차이는 리소스의 정보를 어디서 알고있느냐의 차이다.\n- POST : 리소스의 생성을 요청하면, 서버에서 생성정보를 보내줌\n- PUT : 클라이언트에서 업데이트 할 리소스를 정해서 보내줌. 이 때, 클라이언트 내에 스토어로 리소스를 따로 관리해줘야하는 전제조건이 있다.\n\n### 11. 배열은 연속되는 순서로 메모리를 차지한다. 인덱스 값은 연속되지만, 주소값은 반드시 연속되어 증가하지 않는다.\n\n### 12. 자바스크립트 배열은 해시맵과 같아서, 논리값 할당이 가능하다. 단, 배열의 실제길이에 영향을 주지는 않는다.(사용권장X)\n\n### 13. 연결리스트는 메모리를 순서대로 차지하지 않는다. "}]}},"pageContext":{}},"staticQueryHashes":[]}