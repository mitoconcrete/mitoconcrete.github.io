{"componentChunkName":"component---src-templates-post-jsx","path":"/JS_프로토타입/","result":{"data":{"site":{"siteMetadata":{"title":"mitoconcrete"}},"markdownRemark":{"id":"cea0f027-de2c-57d0-b923-50161b911433","excerpt":"prototype 원형을 의미합니다.\n원형의 속성을 조회하고 싶다면 아래와 같이 조회하면 된다. 하지만 new 키워드를 통해서 만든 복제품 에게는 원형의 속성을 조회할 수 없다.\n예를 들어 아래의 코드에서는 prototype 이 undefined 로 동작한다. [Prototype] 원형의 속성의 주소를 저장하고 있는 내부 속성인  을 이용하여, 자식들에게…","html":"<h2>prototype</h2>\n<p>원형을 의미합니다.\n원형의 속성을 조회하고 싶다면 아래와 같이 조회하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {...}</span></code></pre></div>\n<p>하지만 new 키워드를 통해서 만든 <strong>복제품</strong> 에게는 원형의 속성을 조회할 수 없다.\n예를 들어 아래의 코드에서는 prototype 이 undefined 로 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nobj<span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// undefined</span></code></pre></div>\n<h2>[[Prototype]]</h2>\n<p>원형의 속성의 주소를 저장하고 있는 내부 속성인 <code class=\"language-text\">[[Prototype]]</code> 을 이용하여, 자식들에게 할당한다.\n조회는 <code class=\"language-text\">__proto__</code> 혹은 <code class=\"language-text\">getPrototypeOf()</code>을 이용하여 접근가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span> <span class=\"token operator\">:</span> <span class=\"token string\">'foo'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">__proto__</span> <span class=\"token operator\">:</span> Foo\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Coo <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Bar<span class=\"token punctuation\">)</span>\n\nBar<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 1. foo</span>\nCoo<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 2. foo</span></code></pre></div>\n<p>Bar와 Coo에는 직접적인 name이라는 프로퍼티가 할당되어 있지않다. 하지만, 어떻게 name이라는 속성에 접근할 수 있었을까?\nname을 조회하기 위해서 자바스크립트 엔진은 현재 인스턴스에 name이란게 없다면, 내부속성인 <code class=\"language-text\">[[Prototype]]</code> 을 순차적으로 조회하며 name이라는 속성이 있는지 조회한다.</p>\n<p>아래는 Bar.name 시 foo가 출력되는 순서이다.</p>\n<blockquote>\n<ol>\n<li>Bar.name -> 없음</li>\n<li>Bar.<code class=\"language-text\">[[Prototype]]</code>.name (=Foo.name) -> <strong><em>있음!</em></strong></li>\n<li>foo 출력</li>\n</ol>\n</blockquote>\n<p>아래는 Coo.name 시 foo가 출력되는 순서이다.</p>\n<blockquote>\n<ol>\n<li>Coo.name -> 없음</li>\n<li>Coo.<code class=\"language-text\">[[Prototype]]</code>.name (=Bar.name) -> 없음</li>\n<li>Coo.<code class=\"language-text\">[[Prototype]]</code>.<code class=\"language-text\">[[Prototype]]</code>.name (=Foo.name) -> <strong><em>있음!</em></strong></li>\n<li>foo 출력</li>\n</ol>\n</blockquote>\n<p>실제로 <code class=\"language-text\">[[Prototype]]</code> 이 쓰이진 않고 위에서 언급한 것 처럼 <code class=\"language-text\">__proto__</code> 혹은 <code class=\"language-text\">getPrototypeOf()</code>를 이용해 조회할 수 있다.</p>\n<p>그렇다면 아래의 상황에서는 어떻게 동작할까? </p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span> <span class=\"token operator\">:</span> <span class=\"token string\">'foo'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">__proto__</span> <span class=\"token operator\">:</span> Foo\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Coo <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Bar<span class=\"token punctuation\">)</span>\n\nBar<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 1. foo</span>\n\nCoo<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'coo'</span> \n\nFoo<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 2. ?</span>\nBar<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 3. ? </span>\nCoo<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 4. ? </span></code></pre></div>\n<p>정답은 </p>\n<blockquote>\n<ol start=\"2\">\n<li>foo</li>\n<li>foo </li>\n<li>coo\n이다. </li>\n</ol>\n</blockquote>\n<p>2, 3의 동작은 위와 같지만, 4의 동작이 조금 달라진다.</p>\n<blockquote>\n<ol>\n<li>Coo.name -> 있음</li>\n<li>coo 출력</li>\n</ol>\n</blockquote>\n<p>새롭게 name을 자식에 할당함으로서, <code class=\"language-text\">[[Prototype]]</code>을 조회하지 않고, 곧바로 name을 가져올 수 있었다.</p>\n<h2>프로토타입 체인</h2>\n<p>위의 과정에서 아래와 같은 과정을 거쳤다.\nCoo.<code class=\"language-text\">[[Prototype]]</code>.name (=Bar.name)\nCoo.<code class=\"language-text\">[[Prototype]]</code>.<code class=\"language-text\">[[Prototype]]</code>.name (=Foo.name)</p>\n<p>이 처럼 없는 속성을 계속 연결된 <code class=\"language-text\">[[Prototype]]</code>주소를 통해 찾아내려가는 현상이 마치 체인처럼 이어졌다고하여, <strong>프로토타입 체인</strong> 이라고 명명한다.</p>\n<h2>constructor</h2>\n<p>constructor는 new 키워드를 이용하여 생성된 인스턴스가 자신을 낳은 주체가 무엇인지 표현하기 위해 사용되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\narray<span class=\"token punctuation\">.</span>constructor <span class=\"token comment\">// function Array</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nfoo<span class=\"token punctuation\">.</span>constructor <span class=\"token comment\">// function Foo</span>\n\n<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span></code></pre></div>\n<h3>참고</h3>\n<p><a href=\"https://tecoble.techcourse.co.kr/post/2021-06-14-prototype/\">https://tecoble.techcourse.co.kr/post/2021-06-14-prototype/</a>\n<a href=\"https://ko.javascript.info/function-prototype\">https://ko.javascript.info/function-prototype</a></p>","frontmatter":{"title":"프로토타입에 관하여","date":"August 30, 2022","update":"August 30, 2022","tags":["TIL","Javascript","prototype"],"series":"JAVASCRIPT"},"fields":{"slug":"/JS_프로토타입/","readingTime":{"minutes":3.465}}},"seriesList":{"edges":[{"node":{"id":"24f66539-38a6-5c0d-b633-a61580aa9d0a","fields":{"slug":"/JS_버블링과캡쳐링/"},"frontmatter":{"title":"이벤트 버블링/캡쳐링"}}},{"node":{"id":"cea0f027-de2c-57d0-b923-50161b911433","fields":{"slug":"/JS_프로토타입/"},"frontmatter":{"title":"프로토타입에 관하여"}}}]},"previous":{"fields":{"slug":"/22_08_30/"},"frontmatter":{"title":"✏️ 2022-08-30 Today I Learn"}},"next":{"fields":{"slug":"/22_09_02/"},"frontmatter":{"title":"✏️ 2022-09-02 Today I Learn"}}},"pageContext":{"id":"cea0f027-de2c-57d0-b923-50161b911433","series":"JAVASCRIPT","previousPostId":"e7fa8d30-d7ed-5f18-bf98-47bf3ac8d5c8","nextPostId":"309ca8c2-75e7-525c-86b9-e4209dd09006"}},"staticQueryHashes":[]}