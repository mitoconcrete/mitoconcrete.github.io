<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of mitoconcrete]]></title><description><![CDATA[어제보다 조금 더 성장하기 위해 기록합니다.]]></description><link>https://mitoconcrete.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 15 Mar 2023 23:44:58 GMT</lastBuildDate><item><title><![CDATA[웨이팅 캐치 프로젝트 과정 및 회고]]></title><description><![CDATA[0. 여는 글 K-Digital Training 내일배움캠프 스프링 과정은 프로젝트 기반 교육(Project Lead Educate)을 실행한다. 그 중 마지막 장식인…]]></description><link>https://mitoconcrete.github.io/waitingcatch/</link><guid isPermaLink="false">https://mitoconcrete.github.io/waitingcatch/</guid><pubDate>Tue, 14 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;0. 여는 글&lt;/h2&gt;
&lt;p&gt;K-Digital Training 내일배움캠프 스프링 과정은 프로젝트 기반 교육(Project Lead Educate)을 실행한다. 그 중 마지막 장식인 5주간 진행되는 최종프로젝트가 어제부로 마무리가 되었고, 살짝 아련해져서 프로젝트 과정을 톺아볼겸 회고를 해보려고한다. 긴 기간동안 진행되었기 때문에, 모든일들을 다 적을 순없고 스프린트 별 인상깊었던 사건들 위주로 적어보려고 한다.&lt;/p&gt;
&lt;h2&gt;1. 프로젝트 소개&lt;/h2&gt;
&lt;p&gt;&apos;테X블X&apos; 이라는 서비스에서 많은 영감을 받은 서비스이다.
전국 레스토랑의 정보를 불러모아 집, 카페등 편한 장소에서 줄서기를 한 뒤 레스토랑 관리자가 호출 시 방문하도록 유도하는 서비스이다.
손님 입장에서는 식당 앞에 찾아가 줄을 설 필요없는 편의성이 있고, 가게 관리자 입장에게는 붐비지 않는 가게 앞을 만들고 손님관리를 손쉽게 할 수 있다는 장점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://waitingcatch.com&quot;&gt;클라이언트 페이지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://api.waitingcatch.com/general/templates/seller/login&quot;&gt;판매자 페이지&lt;/a&gt; (sel119 / Test1234!)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://api.waitingcatch.com/general/templates/admin/login&quot;&gt;관리자 페이지&lt;/a&gt; (admin01 / Test1234!)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 프로젝트 진행 과정&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;2-1. 프로젝트 아이템 선정 및 기획 (23.02.06 ~ 23.02.10)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;아이템 선정&lt;/strong&gt;&lt;br&gt;
우리조는 내일배움캠프 측에서 따로 면접을 보고 모인 &lt;strong&gt;챌린지&lt;/strong&gt;팀이 었다. 기존에 홍보할때 해당 팀에서는 다양한 기술적 도전을 할 수 있고, 특히 &apos;대용량 트래픽&apos;을 경험 할 수 있다고 말씀해주셨다. 이전 프로젝트까지 해왔던 것은, 내가 이전 경험에서 했던 것들이라 막막함이 없었지만, &apos;대용량 트래픽&apos;을 경험할 기회는 한 번도 없었기 때문에, 한치의 고민없이 지원하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그래서 그런지 팀원모두 새로운 경험에 관심이 많았고, 특히나 &apos;대용량 트래픽&apos;에 관심을 가지고 있었다.
총 3개의 아이디어가 나왔는데 채팅, 줄서기, 내배캠 통합 플랫폼 이었다. 채팅의 경우엔 타 프로젝트에 서브기능으로 들어갈 수 있었으며, 내배캠 통합 플랫폼은 아이디어는 좋지만, &apos;대용량 트래픽&apos;을 발생시키기엔 억지스러운 것들이 많다고 판단했다.&lt;/p&gt;
&lt;p&gt;따라서, 아이템은 &lt;strong&gt;줄서기 서비스&lt;/strong&gt;로 정하고 이름은 &apos;기다림을 잡는 서비스&apos;라는 뜻으로 &apos;웨이팅 캐치&apos;라고 짓게 되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[팀장 선정]&lt;/strong&gt;&lt;br&gt;
팀원들의 만장일치로 감사하게도 팀장이 내가 되게 되었다. 팀장이란게 사실 거창한 자리는 아니고, 일정을 관리하고 회의 개최하고 그런 역할이라서 나도 큰 부담은 없었고, 그동안 프로젝트를 진행해오면서 일정관리에 대한 경험을 해보고 싶다는 니즈가 있었다. 따라서, 투표결과를 겸허히 받아들이고 팀장의 역할을 수행해보기로 했다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[일정 수립]&lt;/strong&gt;&lt;br&gt;
기간을 정하고, 각 스프린트에 대한 due를 정했다. 여기까지는 반드시 해야한다! 라는 공통된 목표날짜를 잡고, 그에따라 날짜를 분배했다. 지나고 생각해보면 계획대로 거의 된 것 같아서 뿌듯하긴 하다 ㅎㅎㅎ 각설하고, 내배캠 측에서 정해놓은 due도 있어서, 그에 맞게 기획-개발-개선-최종 의 기간을 정했다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[그라운드 룰]&lt;/strong&gt;&lt;br&gt;
프로젝트 진입 전 원활한 프로젝트 진행을 위해, 팀원들이 어떤 약속을 지켜야 할지에 대한 약속을 정했다. 계속해서 수정되긴했지만, 아침 10시와 저녁 20시에는 반드시 모여서 오늘 무슨일을 할지 공유하고, 무슨일을 했는지 공유하기로 했다. 또한, 인상깊었던 룰은 &apos;투표&apos;였는데, 개발을 하다보면 각자의 생각이 부딫히는 순간이 오는데, 서로의 말이 모두 옳기 때문에 대화가 계속 수평으로 가기만 하고 마무리는 되지않는 상황이 발생했다. 거의 반나절 이상을 한 주제로 토론하고, 그 과정에서 감정이 상하는 과정이 너무 에너지 소비라고 생각되서 &apos;투표&apos;라는 정책을 마련했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&apos;투표&apos;가 개최되기 위해선 아래와 같은 조건이 필요했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2지 선다로 의견이 좁혀진 상태에서 서로의 의견이 논리적으로 타당하다고 생각했을 때&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;팀원 전체가 &apos;투표&apos;에 대해서 동의 할 때&lt;/p&gt;
&lt;p&gt;이 정책 도입 후, 우리 팀은 불필요한 토론이 사라져서 빠르게 다음단계로 넘어갈 수 있었다. 대신, 토론은 언제든지 주최 할 수 있도록 제한을 두진 않았다.
추가적으로 우리조는 코드리뷰를 모든 팀원이 해야지 merge될 수 있는 룰이 있었는데, 따라서, 오전은 코드리뷰에 시간을 쏟고 오후에는 개발에 몰두하기로 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[기능 선정]&lt;/strong&gt;&lt;br&gt;
서비스가 정해졌으니, 그에 따른 기능들을 선정을 해야했다. 기본 기능 외에 &apos;대용량 트래픽&apos;을 실험해볼만한 기능에 대해서, 선정해야했다.
다른 생각하는 기능들이 다르고, 이 과정에서 선정 서비스에 대해서 충분히 토론했음에도 불구하고, 우리가 어떤 서비스를 개발하려고하는지 오해하고 계신 팀원들도 계셨다. 따라서, 이 시간을 통해 다시금 &apos;우리가 뭘 개발하려고 하는지&apos; 싱크를 맞추게 되었다. 다들 욕심이 많고, 개발에 대한 두려움이 없으신 분들이라, 너무 많은 기능들을 개발하고자 하셨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;나는 이전에 프로젝트를 해온 경험도 있고, 이번 프로젝트는 프론트엔드도 우리가 직접 개발해야했기 때문에, 이 모든 기능들을 개발한다는 것이 불가능 할 것이란게 어렴풋이 느껴졌다. 따라서, 기능들을 필수/추가/추추가 로 나눈 뒤, 필수기능들을 우선적으로 구현 한 뒤, 다른 기능들을 붙혀보잔 제안을 드렸다.
&lt;img src=&apos;/image/waitingcatch01.png&apos; width=&apos;800&apos; alt=&apos;01&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[ERD작성]&lt;/strong&gt;&lt;br&gt;
정해진 기능에 따라, Entity Relation Diagram을 작성해보았다. 구현하려는 기능에 따라 엔티티가 필요한 항목들이 있었고, 그것에 어떻게 접근할 것이며, 분리하는 것이 효율적인지 쪼개는 것이 효과적인지 지속적으로 토론하며 수정해나갔다.
팀원 중에 최적화에 대해 신경을 많이쓰시는 분이 계셨는데, 한편으로 고맙긴 했지만 추후에 테스트 해보고 진행해도 될 법한 것들을 지속적으로 제안주셔서 당황스러웠다. 개인적인 판단으로 오버엔지니어링이 될 것 같은 부분들이 있어서, 해당 팀원을 설득하고 다른 팀원들의 의견을 구하면서 필요한 부분들은 수용하고, 불필요한 부분들은 추후에 시도해보기로 합의보고 메모하면서 진행했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;논의중에 가장 기억에 남는 토론들이 있었는데, 지금은 해결된 문제였지만.. 거의 하루종일 토론했던 기억이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이미지만 관리하는 테이블을 만들어서 사용 vs 엔티티 별로 이미지 테이블을 만들어서 관리 vs 엔티티안에 이미지를 넣어서 관리 : 이미지를 그냥 주소만으로 관리하고 추가적인 정보가 필요하지 않기 때문에 &apos;엔티티안에 이미지를 넣어서 관리&apos;하기로 합의&lt;/li&gt;
&lt;li&gt;줄서기 테이블을 하나로 관리 vs 두개로 분리 : 지속적인 조회가 필요한 상황이 생기면, 풀 스캔을 해야하는 상황이 지속발생하기에 하루단위로 줄서기 기록을 쌓고 그것을 영구저장 테이블에 올려서 관리하기로 함.&lt;/li&gt;
&lt;li&gt;리뷰 남겨야 할 줄서기를 줄서기 내역을 통해서 알게 할지 vs 유저가 곧바로 자신이 리뷰를 남겨야 할 줄서기 내역을 알 수 있도록 할지 : 유저가 리뷰를 남겨야 할 무조건적인 책임은 없기 때문에 &apos;리뷰 남겨야 할 줄서기를 줄서기 내역을 통해서&apos; 알 수 있도록 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;치열한 토론 끝에 엄청 복잡한.. 구조의 ERD구조가 완성되었다. (이후에도 계속 변경된 것은 안비밀..)
&lt;img src=&apos;/image/waitingcatch02.png&apos; width=&apos;800&apos; alt=&apos;01&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[API 문서]&lt;/strong&gt;&lt;br&gt;
완성된 ERD 기반으로 정해진 기능을 페이지 별로 나누어 재 리스트업 한 뒤, 페이지별로 탭을 나누어 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/1Hhjp6eKlJxv6ZLsFz1xe50t-xMe478o5_Je7RIvn1YA/edit?usp=sharing&quot;&gt;해당문서&lt;/a&gt;안에 기능 별 API를 정의하기 시작했다. RESTful 한 상태를 유지하면서 진행하려고 했지만, 우리가 기능별, 권한별로 api를 구분 짓하고 약속을 한 상태라 무조건 적으로 RESTful 하게 작성하기는 어려웠다.
따라서, 어떤 자원을 가지고 올때는 RESTful하게(GET /members, /members/3), 그게 아닌 단순히 기능(POST /login, /logout)을 나타 낼 때는 단수를 써서 자원을 가지고 오는 것과 그렇지 않은 것을 구분짓기로 약속했다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[역할분리]&lt;/strong&gt;&lt;br&gt;
우리조는 원활한 협업을 위해 많은 토론을 나눴고, 결론적으로 &apos;도메인&apos;기준으로 분리하는 것이 좋겠다는 결론이 지어졌다. 기존에는 API에서 원하는 기능들을 개발하자는 방식으로 하려고 했지만, 그러다보니 파일 혹은 디렉토리의 분리라던지, 브랜치 별로 개발하는 것이 힘들겠다는 판단이 들었다. 컨플릭트가 매우 많이 날것 같다는 우려가 있었다ㅎㅎ
따라서, &apos;도메인&apos;기준으로 나누기로 했는데, &apos;도메인&apos;이라는 개념이 매우 추상적이었기 때문에 튜터님께 문의를 드려보니 &apos;바운더리 컨텍스트&apos;라는 개념을 말씀해주셨다. &apos;바운더리 컨텍스트&apos;는 어떤 서비스를 기능, 역할 단위로 쪼개어 그룹핑하는 개념이다. 따라서, 우리의 서비스의 기능과 역할을 쪼개보았다.
그러니 다음과 같은 그룹이 나뉘어 졌다.&lt;/li&gt;
&lt;li&gt;줄서기 : 우리 서비스의 핵심 도메인&lt;/li&gt;
&lt;li&gt;유저 : 서비스의 이용자. 관리자, 판매자, 고객이 될 수 있다.&lt;/li&gt;
&lt;li&gt;레스토랑 : 줄서기의 대상이 되는 도메인&lt;/li&gt;
&lt;li&gt;이벤트 : 유저에게 부여될 수 있는 도메인으로서, 서비스 전체적인 이벤트와 레스토랑 개인의 이벤트로 분리 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;팀원 5명이 각자 하고 싶은 도메인을 담당하게 되었고, 나는 인증,인가에 대한 지식이 부족하다고 생각하여 &apos;유저&apos; 도메인을 담당하게 되었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;2-2. 개발 (23.02.13 ~ 23.02.22)&lt;/h3&gt;
&lt;p&gt;유저 도메인을 개발하면서 가장 인상 깊었던 기억은, 인증 인가 시 스프링 시큐리티를 거쳐야하는데, 우리조는 JWT 토큰을 이용한 인증인가를 사용했기 때문에, 토큰이 만료되는 상황을 고려해야했다. 이전 프로젝트에서는 다음과 같이 처리했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그인 성공 시, 클라이언트에게 access token, refresh token 을 발급하고, 클라이언트는 해당 값을 로컬스토리지에 저장한다.&lt;/li&gt;
&lt;li&gt;일반 요청에는 access token을 전달하고, 토큰 만료 시 특정 요청을 보내어 토큰 재 갱신 API에 요청을 할 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;재 갱신 API에는 refresh token을 발급하여 전달하고, 서버에서 refresh token의 유효여부를 판단 한 뒤, 유효하다면 새로운 access token을 발급한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만, 리프레시 토큰 탈취를 예방하기 위해 redis를 사용하여 다음의 플로우를 만들었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그인 성공 시, 클라이언트에게 access token를 발급하고, refresh token은 redis에 저장한다.&lt;/li&gt;
&lt;li&gt;일반 요청에는 access token을 전달하고, 토큰이 만료되면 redis에 refresh token이 살아있는지 확인한다.&lt;/li&gt;
&lt;li&gt;refresh token이 있다면, 새롭게 access token을 발급할 수 있도록 성공응답을 보내고, 없다면 오류를 뱉는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 플로우에서 갱신 API를 제외하고는 모두 만들어놓았다.
redis연결도 끝내서, key-value 형태로 토큰을 저장하고, 토큰 만료 시 유효성을 redis를 이용해 유효성을 판별하여 결과값을 뱉어주는 것에 성공했다.&lt;/p&gt;
&lt;p&gt;하루만에 기능구현을 끝내고 &lt;a href=&quot;https://github.com/mitoconcrete/waiting-catch-project/pull/122&quot;&gt;PR&lt;/a&gt;을 올렸는데, 리뷰가 굉장히 많이 남겨졌다. 이 때, dirty checking과 remove를 가로채서 soft delete 시키는 방법이 리뷰로 달렸는데, 해당 부분을 학습하고 적용하는 과정이 매우 재미있고, 흥미롭게 다가왔다.&lt;/p&gt;
&lt;p&gt;동시에, 프론트작업을 실시했는데, 우리가 영감을 받은 테X블X이라는 서비스와 캐X테X블의 디자인을 어느정도 참고하고, meterial UI에서 제공하는 무료 아이콘들과 이미지를 가지고 작업을 시작했다. 개발해야할 페이지가 20개정도 되었는데, 2일에 걸쳐서 10개씩 작업하니깐 금방 마무리 할 수 있었다. 본래 리액트를 사용하려다가, props를 엄청 내리거나 올릴 필요도 없고, css 파일을 따로 분리하여 관리하기엔 시간이 부족하다고 생각하여, 한 화면에서 컴포넌트에 해당되는 모든 파일을 모아놓고 볼 수 있는 vue.js를 기술스택으로 선정하였다. 밤을 좀 새긴 했지만, 어쨋던 2일만에 화면작업을 완료했다.&lt;/p&gt;
&lt;p&gt;API를 화면에 붙혀야하는데, 의도대로 백엔드에서 데이터를 내려주지 않고 있어서, 해당 도메인 담당자들께 데이터 형식수정을 요청드리고 그것이 코드리뷰를 거쳐서 적용 될 때까지 기다려야했기 때문에, 시간이 꽤나 걸렸다. 따라서, 비는 시간동안은 다른 사람의 코드를 찬찬히 보면서 리뷰를 드렸다. 문제가 발생할 우려가 있는 것, 컨벤션이 약속한 것과 일치하지 않는 것에 대해 주로 리뷰를 드렸다.&lt;/p&gt;
&lt;p&gt;이후에 API를 모두 마친 뒤, 프론트와의 기본 연결작업을 마쳤다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;2-3. 중간발표 준비 및 발표실행 (23.02.23 ~ 23.02.24)&lt;/h3&gt;
&lt;p&gt;1차적으로 기본 구현 기능으로 계획해 놓았던, 모든 기능의 구현을 마무리했다. 지금까지 해 온 것 들을 기반으로 영상촬영 및 중간발표준비를 시작했다.
본래는 나혼자 진행하려고했는데, 생각보다 할 일이 많아질 것 같아서, 팀원들에게 분담을 제안드렸다. 협의 끝에 5개의 포지션으로 나눌 수 있었고, 각 포지션에 맞게 작업을 시작했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;1. 영상촬영
2. 영상편집
3. 발표
4. 발표자료준비
5. 현재까지 기능 QA 및 개선사항 정리  # 아직 프로젝트가 끝나지 않았기 때문에 다음 단계 개발을 위해서 마련한 포지션&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해당 과정을 &lt;a href=&quot;https://nervous-linseed-2d2.notion.site/cde90590bd314d06ab48bcee39b53d19&quot;&gt;기록&lt;/a&gt;하며 진행하였고, 문서화 하여 관리하니 팀원들이 불필요한 커뮤니케이션을 할 필요 없이 원활하게 업무가 진행되었다.&lt;/p&gt;
&lt;p&gt;모든 팀원들이 자신의 역할을 충실히 이행해주셔서, 성공적으로 중간 발표를 마무리 할 수 있었다.&lt;/p&gt;
&lt;p&gt;중간 발표 이후, 팀 차원에서 회고를 진행하였고, 남은 기간을 어떻게 진행하면 좋을지에 대한 토론을 진행했다. 팀원들도 직접 코드를 작성하고 프로젝트를 진행하시다보니, 조금은 계획이 바뀌신 부분들도 있었다. 따라서, 그에 따라, 모두가 하고 싶은 것을 충족하고 프로젝트의 완성도도 높힐 수 있도록, 다시금 전략을 수립했다.
역시나, 해당과정은 &lt;a href=&quot;https://www.notion.so/MVP-3f610c3ca30247a5a692300e99b19824&quot;&gt;문서화&lt;/a&gt; 하여 시각적으로 모든 팀원들이 리마인드 할 수 있도록 했다.&lt;/p&gt;
&lt;p&gt;총 3개의 스프린트로 쪼갤 수 있었고, QA 바탕으로한 기능보완 및 개선을 우선적으로 진행 한 뒤, 대용량 테스트를 진행하고자 했다.
우선적으로 각자 남은 업무에 대해서 리스트업하고 체크리스트를 만들었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;2-4. 기능보완 및 개선 (23.02.27 ~ 23.03.05)&lt;/h3&gt;
&lt;p&gt;우리는 기능이 마무리 되었지만, 아주아주 디테일 한 부분들이 작업이 되어있지 않은 상황이었다. 예를들어 로그인이 풀린 뒤 대응이 안되어있는 상황이었다. 또한, 판매자 페이지도 UI가 아직 완성이 되지 않은 상황이라서, 그런 부분들에 대한 개선도 진행되어야 했다. 추가적으로, 예외처리, 배포, 테스트 코드 작성과 같은 부분들도 남아있었다.&lt;/p&gt;
&lt;p&gt;내가 맡은 기능 중에서 가장 이슈가 되었던 부분은 토큰 만료로 로그인이 풀린 뒤, 그 뒤에 대한 대처방안이 없다는 것이었다. 나를 포함한 모든 팀원이 로그인이 풀리면 다시 로그인해야하는 상황을 겪었고, 이를 반드시 해결해서 부드럽게 흘러가는 서비스를 만들어야 했다.&lt;/p&gt;
&lt;p&gt;또한, 나를 제외한 모든 팀원들이 프론트엔드 작업에 익숙하지 않아서, fetch나 ajax를 이용하여, 서버와 소통하는 일은 최대로 줄여야 했다. 기존에는 로컬스토리지에 저장해놓고 필요 시 마다 요청에 토큰을 담아서 사용하던 방식을, 팀원들을 위해 쿠키에 담는 로직으로 변경하였고, 그에 따라 jwt filter에 쿠키에서 토큰을 꺼내와서 검증하는 방식도 추가되었다.&lt;/p&gt;
&lt;p&gt;또한, 팀원들이 갱신된 access token을 발급받기 위해 서버에 다시 요청하는일이 없도록 로직을 아래와 같이 변경하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그인 성공 시 access token과 refresh token을 발급한다. access token 은 헤더에 실어서 보내고, refresh token은 redis에 저장한다.&lt;/li&gt;
&lt;li&gt;access token이 만료되면, refresh token이 유효한지 검증하고, 유효하다면 새로운 토큰을 발급하여 일단 로직을 수행하도록 한다.&lt;/li&gt;
&lt;li&gt;응답 결과와 함께 헤더에 새로발급한 토큰을 싣어 보낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 과정으로 클라이언트에 특정로직만 추가되면 지속적으로 로그인이 끊기지 않게 되었다. 정말 극단적으로 1초뒤에 access token이 만료되어도, refresh token이 살아있다면 지속적으로 세션이 유지되는 것을 확인해보았다.&lt;/p&gt;
&lt;p&gt;refresh token이 redis에 지속적으로 쌓이고 있는 상황에서 TimeToLive를 적용하여, 일정 시간이 지나면, 해당 토큰이 사라지도록 하였다.&lt;/p&gt;
&lt;p&gt;위 개선 외에도, 프론트 단에 아직 연결되지 않은 로직들과, 변경된 이후로 바뀐 데이터 포맷에 대한 대응이 되지 않아서, 그것들을 연결하는데 일주일을 보냈다.
또한, 서버에 테스트 코드가 작성되어있지 않기에, 로직 수행에 대한 검증이 전혀되지 않고 있었는데, 팀원 전체가 테스트를 작성하여 빌드 시 한번더 검증하여 코드가 배포되어도 안전 할 수 있는 장치를 마련하는 시간을 가졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;2-5. 퍼포먼스 테스트 및 배포 (23.03.06 ~ 23.03.11)&lt;/h3&gt;
&lt;p&gt;이제 완전히 약속한 기능들에 대한 작업을 마치고, 이제는 정말 모든 기능들이 정상동작하는지 테스트 해보고 버그들을 잡는 수순을 밟아야 했다. 또한, 배포를 시켜 유저의 피드백도 돌려야 했었다. 따라서, 팀원 중 한분이 배포 및 CI/CD 연결을 담당해주시고, 다른 팀원은 기능테스트를 하고, 다른 팀원은 부하 성능 테스트도구인 nGrinder와 PINPOINT환경을 셋팅하는데 시간을 쓰기로 했다. 나는 유저 기능테스트 담당이라서, QA문서를 작성하고 기능테스트 하는 것에 집중했다. 또한, 배포 후 도메인 구매 및 ssl연결 등 디테일한 부분은 시간 단축을 위해 경험자인 내가 맡았다. 다른 조에서는 몇일씩 걸렸다고 했는데, 나는 경험이 있기에 금방 해내었다. 또한, 완전한 테스트를 하기 위해서는 더 많은 레스토랑 정보들이 필요했는데, 나는 쉘파일을 작성하여 for 문을 이용해 해당 쉘을 실행함으로서, DB에 전국 각지의 레스토랑 데이터가 쌓이게 만들었다. 그리고, 그렇게 생성된 더미데이터들을 실제 DB에 반영하였다. 꼬박 반나절이 걸렸다.
위의 작업들이 진행되는 동안 부하 성능 테스트 담당 팀원들은 해당 툴에 대한 학습을 한 뒤, 시나리오 스크립트를 작성하였다.&lt;/p&gt;
&lt;p&gt;배포 작업이 마치고, 도메인 연결도 끝난 뒤 주변 지인들과 내배캠 수강생들에게 해당 프로젝트의 설문지를 돌렸다.
그와 동시에 모든 팀원들은 퍼포먼스 테스트 시나리오를 갖추는 것에 집중했다.&lt;/p&gt;
&lt;p&gt;문제는 nGrinder라는 프로그램이 아무래도 환경적인 이슈가 있는 지 잘 동작을 하지않는 상황들이 발생했고, 또한, 스크립트를 직접 코드로 작성해야되다 보니, 지친 팀원들에게는 오히려 독으로 다가왔다. 따라서, 부하성능 테스트 도구를 조금더 시각화 되어있는 도구인 Jmeter를 이용하기로 하였다.&lt;/p&gt;
&lt;p&gt;이렇게 셋팅을 마치고, 내배캠 측에서 요구하는 자료의 제출이 3.11일까지여서, 모든 팀원들이 해당 자료 제출을 위해 개발을 잠시 놓고 내 업무를 도와주셨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;2-6. 최종 발표 준비 (23.03.11 ~ 23.03.14)&lt;/h3&gt;
&lt;p&gt;최종 발표를 원래 주말에 하려고 했는데, 시간 관계 상 주말동안 퍼포먼스 테스트를 해야했다. 우리의 셋팅이 너무 늦게 끝났기 떄문이다.
우리는 사전에 여러 테스트 시나리오를 고려했는데, 시간 관계 상 하나의 퍼포먼스에 집중하기로 했다.&lt;/p&gt;
&lt;p&gt;그것은 바로 우리의 핵심기능인 &apos;줄서기&apos;였다. 10만개 이상의 트래픽을 동시다발적으로 한 레스토랑에 몰아넣어서, 어떻게 동작하는지 보고자 했다.
그렇다면, &apos;이걸 이용해 우리는 어떤 개선을 할 것인가&apos;가 우리 모두를 혼란스럽게 했다.&lt;/p&gt;
&lt;p&gt;가장 먼저 우리가 들이부을 트래픽 수에 대한 기준을 잡아야했다. 대한민국 평균 외식인구, 서울 평균 외식인구 등등 외식인구에 대한 자료를 찾아보려고했는데, 다 2~3년 이상된 자료였다. 팀원 중 한 분이 &lt;a href=&quot;https://www.innoforest.co.kr/company/CP00011325&quot;&gt;테x블x&lt;/a&gt;어플리케이션에 대한 지표들을 찾아주셨고, 추가적으로 22년 말 기준으로 총 가입자 대비 MAU가 얼마나 있는지에 대한 기준도 찾을 수 있었다.&lt;/p&gt;
&lt;p&gt;현재 우리 서비스에 mock 유저가 10만명이 있었기 때문에, 위 서비스 기준으로 인원기준을 잡으니 2.5만이라는 기준이 잡혔다. 또한, 일평균 트래픽이 2만이상이라, 우리의 서비스는 최소 2만이상을 감당할 수 있는 서비스여야 한다라는 기준을 잡을 수 있었다. 이렇게 실험에 대한 모수는 2.5만으로 잡게 되었다.&lt;/p&gt;
&lt;p&gt;그다음 몇번 트래픽을 부어보니, PINPOINT 상에서 딱봐도 응답속도가 너무 느린것을 볼 수 있었고, 우리가 들이붓는 트래픽 대비 실제 줄서기 성공률도 매우 낮았다. 거의 8%가 안되었을거니깐.. 우리는 10번의 시도를 한 뒤, 어떤 기준으로 이 실험을 할 것인지 다시 얘기해보았다.&lt;/p&gt;
&lt;p&gt;나는 지금 사용하고 있는 컴퓨터 사양이 좋지 않기 때문에, 트래픽 응답속도가 느린것이라고 판단했고, 그렇기에 일단 줄서기 성공률을 최대한으로 높이는게 좋겠다는 제안을 했다. 하지만, 다른 팀원은 &apos;우리가 사용하고 있는 낙관적락의 설정때문에 서비스가 받아들이지 못하는 트래픽이 너무 많다보니, 설정 수치를 조정해가면서 일단 서비스 자체가 받아들이는 트래픽을 높이자&apos;라는 제안을 했다. 다시 생각해보니, 1명의 성공률이 높다고 해도, 나머지 사람들이 이 1명의 성공을 위해 대기열조차 들어오지 못하는 상황이 말이안된다는 생각을 했다. 따라서, 팀원의 제안을 받아들이고, 들이붓는 트래픽대비 받아들이는 트래픽의 비율을 높히기로 했다.&lt;/p&gt;
&lt;p&gt;또한, 응답속도가 너무 낮았는데, PINPOINT 내역을 확인해보니 &lt;code class=&quot;language-text&quot;&gt;getConnection&lt;/code&gt; 하는 속도가 너무나 느렸다. 이 문제는 미리 커넥션풀을 만들어 놓고, 서비스에게 할당하는 식으로 하면 해결된다고 했다. 하지만, 얼마나 미리 커넥션풀을 생성해야 그 수치가 적당할지 감이 오질 않았고, 팀원들과 실험을 통해 조정해보기로 했다.&lt;/p&gt;
&lt;p&gt;팀원들과 많은 실험을 통해 적정한 양의 커넥션 풀과 락 설정을 정할 수 있었다.
&lt;img src=&apos;/image/waitingcatch03.png&apos; width=&apos;800&apos; alt=&apos;03&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;많은 실험을 통해, 우리의 서비스가 아무리 트래픽을 100% 받아들인다고 해도, 100% 줄서기를 성공시킬 수 없는 구조였다는 것을 찾을 수 있었다.
따라서, 해결방법을 찾아보니, 메시지큐를 사용해서 성공률을 높일 수 있다고 했다. 따라서, 아래의 구조와 같이 변경하여 줄서기 성공률을 높혀보기로 팀원들과 협의를 본 뒤, 시간관계 상 실험을 마무리했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&apos;/image/waitingcatch04.png&apos; width=&apos;800&apos; alt=&apos;04&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;2-7. 최종 발표 (23.03.14)&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;실험이 마무리된 뒤, 우리 팀은 곧바로 해당 결과를 바탕으로 발표자료를 준비하기 시작했다.
중간 발표 때 PPT자료에는 너무 줄글이 많아서 가독성이 떨어지는 이슈가 있었다. 따라서, 나와 영상편집을 담당했던 팀원이 해당 페이지들을 이미지로 바꾸는 작업을 진행했다. 발표를 하시는 팀원과 실시간으로 해당 자료들을 공유하면서, 스크립트를 짜시는데 다시금 일을 하시지 않도록 신경썼다.&lt;/p&gt;
&lt;p&gt;이렇게 각자의 업무를 한 뒤, 최종 리허설을 진행했다. 발표자에게 좋았던 점과 수정했으면 하는 점들을 피드백드리고, 최종발표 전까지 피드백을 반영하시는데 막히는 게 없으시도록 빠르게 팔로우업 해드렸다.&lt;/p&gt;
&lt;p&gt;정신없이 준비하다보니.. 어느새 발표시간이 점점 다가오고 있었고, 드디어 3월 14일 오후 19시가 되었다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;2-8. 최종발표 결과&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&apos;/image/waitingcatch05.jpg&apos; width=&apos;800&apos; alt=&apos;05&apos;&gt;&lt;/img&gt;
&lt;img src=&apos;/image/waitingcatch06.png&apos; width=&apos;800&apos; alt=&apos;06&apos;&gt;&lt;/img&gt;
2등과 4표차를 내면서 최고의 프로젝트로 뽑혔다! 매니저께서 좋은 피드백도 많이 들어왔다며 공유도 해주셨다. 또한, 현업 선배개발자들이 우리조에 오셔서, 인상깊었다고 피드백도 많이 해주셨다.&lt;/p&gt;
&lt;p&gt;이렇게 우리조는 23.03.14를 유종의 미를 거두며 마무리 할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 프로젝트 회고&lt;/h2&gt;
&lt;p&gt;우리의 서비스가 규모가 세세하게 신경쓸 부분이 많았다보니, 자칫하면 많은 부분에서 삐끗했을 가능성이 높았던 프로젝트였다고 생각한다. 하지만, 팀원들이 모두 프로젝트에 애착을 가지고 있었고, 나 또한 이 프로젝트를 성공적으로 운용하는 것에 대한 집착이 있어서 성공적으로 결과물을 낼 수 있었어서 나름 뿌듯했다.&lt;/p&gt;
&lt;p&gt;주요 기술을 하지못한 것에 대한 아쉬움이 많이 남긴하지만, 코드리뷰를 통해 대략적인 플로우는 알고 있기 때문에 너무 아쉽지는 않다.&lt;/p&gt;
&lt;p&gt;하지만, 커뮤니케이션 부분이 정말 많이 아쉬웠던 것 같다. &apos;기분이 태도가 되지말자&apos;라는 주의지만, 컨디션과 일정의 압박이 있는 경우 내가 어떻게 변하는지 나도 모르는 내모습을 볼 수 있었다. 아무래도 나는 목표를 향해 계속 팀을 앞으로 밀어야 하는 역할을 가지고 있는데, 조금의 브레이크가 걸리려는 액션이 있을 때, 예민하게 반응했던 것 같다. 되돌아봤을 때, 조금만 여유를 가지고 둥글게 말했다면 어땟을까 하는 후회가 많다.&lt;/p&gt;
&lt;p&gt;이전까지는 커뮤니케이션을 많이하지않던 환경에 있다보니, 내 이런 모습을 돌아볼 기회가 없었다고 생각한다. 그래서, 내배캠에서 운용하는 이 프로젝트 베이스 교육이 정말 맘에 들었다. 내 모습을 돌아보고 고치는 시간을 확보 할 수 있었기 때문이다. 또한, 같은 목표를 가지고 달려가는 동료들이 많기에, 커뮤니케이션을 많이많이 시도해 볼 수 있는 환경이 마련된 것도 너무 좋았다.&lt;/p&gt;
&lt;p&gt;사람들을 많이 마주하면서 좋은 점은, 많은 타인들의 많은 장점들을 볼 수 있고, 그것들을 흡수 할 수 있었다는 점 이었다. 사람은 성장의 동물이기에, 최종프로젝트에서 했던 실수들을 반복하지 않음으로서 조금 더 &apos;함께 일 하고 싶은 동료&apos;에 가까워질 것 이다.&lt;/p&gt;
&lt;h2&gt;4. 관련 링크 및 자료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1Hhjp6eKlJxv6ZLsFz1xe50t-xMe478o5_Je7RIvn1YA/edit?usp=sharing&quot;&gt;API문서, 유저피드백 등 정리 시트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.canva.com/design/DAFdOIBqaiU/Vostlw_fVXDA0hZvnCa2EQ/view?utm_content=DAFdOIBqaiU&amp;#x26;utm_campaign=designshare&amp;#x26;utm_medium=link&amp;#x26;utm_source=publishsharelink&quot;&gt;발표자료&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mitoconcrete/waiting-catch-project-client&quot;&gt;프로젝트 클라이언트 코드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mitoconcrete/waiting-catch-project&quot;&gt;프로젝트 서버 코드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/users/mitoconcrete/projects/6&quot;&gt;프로젝트 관리 및 진행&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nervous-linseed-2d2.notion.site/S-A-e0603e170f0f4a9da949ad475682a2d9&quot;&gt;팀 노션&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-03-1st Weekly I Learn]]></title><description><![CDATA[FACT-O1. 최적화 작업 및 테스트 작성을 했다. FEELINGS 모든 서비스의 테스트를 작성하려니, 막막했다. 이미 너무 사이즈가 커버린 프로젝트 규모 덕분에 어디서부터 손을 대야할 지 막막했다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/23_03_1st/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_03_1st/</guid><pubDate>Sun, 05 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 최적화 작업 및 테스트 작성을 했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;모든 서비스의 테스트를 작성하려니, 막막했다.&lt;/li&gt;
&lt;li&gt;이미 너무 사이즈가 커버린 프로젝트 규모 덕분에 어디서부터 손을 대야할 지 막막했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트를 작성하면서, 의도가 잘 기억이 나지않아서, 내부에 사용되는 동작관련 로직을 다시금 리마인드 하는 상황이 발생했다.&lt;/li&gt;
&lt;li&gt;또한, 리팩토링을 다시 하려다보니, 하다가 기존 서비스들을 건드리는 곳들이 많아서 고쳐야하는 곳이 많아졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트는 그때그때 작성해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;또한, 의존성 분리를 통해 유지보수 시에 다른 파일들에 영향이 가지 않도록 하는게 중요하다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-03-03 Today I Learn]]></title><description><![CDATA[…]]></description><link>https://mitoconcrete.github.io/23_03_03/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_03_03/</guid><pubDate>Fri, 03 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;효율적으로 더미데이터를 만들기&lt;/h2&gt;
&lt;p&gt;이제 도메인 배포도 했고, 점차 프로젝트 마무리를 향해 달려가고 있다.
하지만, 우리의 서비스가 실제로 구동되고 있는 서비스가 아니기 때문에, 더미 데이터들을 우선적으로 셋팅해야했다.
위치 기반으로 근처에 있는 레스토랑 목록을 가져오는 것이기 때문에, 최대한 많은 데이터를 수집하여야 고객 피드백도 받고 우리의 부하테스트도 진행 할 수 있는 상태였다.
따라서, 팀원 분께서 제작하신 더미생성 api를 이용하려고 했는데, 퍼포먼스가 너무 좋지 않았다. 긁어온 데이터가 총 9만개 였는데, 그걸 불러와서 반복문을 돌려가며 업데이트하는 방식이었는데, 불러오는 것 자체가 1분이상이 되는 현상이 발생하였고, 가장 중요한 건 생성 쿼리가 날라가지 않고 영속성 컨텍스트에 쌓이기만 한다는 것이었다.&lt;/p&gt;
&lt;p&gt;따라서, 1개의 데이터만 가져와서 업데이트하는 식으로 만들어보았는데, 위의 로직보다 성능이 꽤 좋았다. 그래서 해당 api를 postman으로 계속 호출하면서 더미를 업데이트 했는데, 이렇게 9만개의 데이터를 만드는것이 말이 안된다고 생각하여 자동화를 위한 방안을 고민했다.&lt;/p&gt;
&lt;p&gt;결론적으로, 아래와 같이 쉘스크립트를 사용하여, curl을 통해 더미 api로 호출하게 만들었고, 이것을 레코드 수 만큼 반복하게 하여 자동화를 할 수 있었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;COUNT=1
while [ $COUNT -le 90876 ]; do
        echo 누적 전송 횟수 : $COUNT
        let COUNT=COUNT+1;
        curl --location --request POST &apos;http://localhost:8080/api/general/seller-managements/dummy&apos;;
done;
echo 완료&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기술을 갖고 있다는게 편하게 느껴지는 순간이었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-03-02 Today I Learn]]></title><description><![CDATA[CI 를 뚫어라..! 오늘 CI를 진행하는 중 그동안 잘 돌아갔던 테스트가 막히는 일이 발생했다. 로그인, 로그아웃, Oauth…]]></description><link>https://mitoconcrete.github.io/23_03_02/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_03_02/</guid><pubDate>Thu, 02 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;CI 를 뚫어라..!&lt;/h2&gt;
&lt;p&gt;오늘 CI를 진행하는 중 그동안 잘 돌아갔던 테스트가 막히는 일이 발생했다.&lt;/p&gt;
&lt;p&gt;로그인, 로그아웃, Oauth 테스트와 같이 레디스에서 토큰을 잘 가져오는지 테스트를 하는 로직들이 있었는데,&lt;/p&gt;
&lt;p&gt;알고보니, 로컬에서 돌릴 때는 레디스가 켜져있으니, 테스트가 원활하게 돌아갔지만, 테스트환경에서는 레디스를 돌릴 수 없기 때문에 발생하는 일이라고 했다.
좀 더 찾아보니, docker pull 을 당겨 가상의 서비스 환경을 만들어서, 해결한다고 한다.
따라서, 아래의 커멘더를 입력하여, 테스트시 레디스를 실행할 수 있도록 하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    services:
      redis:
        image: redis
        options: &gt;-
          --health-cmd &quot;redis-cli ping&quot;
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

          ....

      - name: Test with Gradle
        run: ./gradlew test
        env:
          REDIS_HOST: redis
          REDIS_PORT: 6379&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 이렇게 해도 똑같은 곳에서 동작을 하지않았다. 조금 더 고민을 해보니, 해당 테스트는 액션 내부의 가상환경에서 돌거고, 거기에 도커를 받아서 돌리는데, 가상환경과 도커를 연결하는 셋팅이 아무곳에도 없었다. 따라서, 테스트 환경에서 도커에 올려져있는, 레디스에 연결하여 테스트를 정상적으로 실행시키도록 아래의 커멘드를 수정하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    services:
      redis:
        image: redis
        options: &gt;-
          --health-cmd &quot;redis-cli ping&quot;
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:                           &amp;lt;&amp;lt; 추가
          - 6379:6379

          ....

      - name: Test with Gradle
        run: ./gradlew test
        env:
          REDIS_HOST: localhost          &amp;lt;&amp;lt; 수정
          REDIS_PORT: 6379&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;성공!&lt;/p&gt;
&lt;p&gt;이후에, 리스트 페이징 테스트를 하는데, 계속 실제 데이터와 다른 숫자가 찍히는 현상이 발생했다.
확인해보니, 다른 테스트에서 넣어놓은 유저가 그대로 남아있어서 발생하는 이슈였다.&lt;/p&gt;
&lt;p&gt;해당 테스트를 작성하신 팀원분은 파일을 두개로 분리하여, 테스트를 진행중이셨는데, 두개의 파일에서 같은 유저리스트를 사용해야했기 때문에, 롤백을 해선 안된다고 말씀주셨다.
좀 더 찾아보니, 테스트가 마쳐지고 난 뒤, 컨텍스트를 비우는 설정이 가능했고, 해당 설정을하여 테스트를 마치고 DB를 비움에 따라서, 내 테스트까지 영향을 미치지 않도록 만들 수 있었다.&lt;/p&gt;
&lt;p&gt;통합테스트를 할 때는 주의를 해야겠다는 깨달음을 얻었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-28 Today I Learn]]></title><description><![CDATA[테스트 오지게 작성해보기 (불편한 것에 익숙해지기) 오늘 하루동안 총 40…]]></description><link>https://mitoconcrete.github.io/23_02_28/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_28/</guid><pubDate>Tue, 28 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;테스트 오지게 작성해보기 (불편한 것에 익숙해지기)&lt;/h2&gt;
&lt;p&gt;오늘 하루동안 총 400라인의 테스트를 작성해보았다. 원래는 컨트롤러단 부터 시작되는 통합테스트를 실시했어야했지만, 우리조는 구조의 변경에 대비하여 서비스단에서만 로직을 작성하기로 했다.
처음엔 막막했는데, given-when-then의 순서로 assertThat, assertEqules, assertFalse, assertThrows 등을 적절하게 잘 사용하여, 테스트를 모두 작성하였다.
이게 TDD의 목적과는 다르게, 모든 어플리케이션이 작성되고, 그걸 커버하기위해 후순위로 테스트가 작성된 거긴하지만, 어플리케이션 내부의 동작의 일관성을 해당 테스트로 커버가능하다는 점에서 모든 테스트를 작성하고 안도감이 찾아왔다.&lt;/p&gt;
&lt;p&gt;처음에 테스트를 작성 할 때는 이걸 왜 사용하지? 에 대한 의문부터 시작해서 익숙하지 않다보니 많은 불편함을 느꼈다.
하지만, 내가 소화가능한 수준부터 시작해서 하나씩 붙혀나가다 보니, 익숙해졌고, 그에 따라 필요성을 느낄 수 있는 상태로 되었다.&lt;/p&gt;
&lt;p&gt;개발중에는 굉장히 많은 요소들을 공부해야하기 때문에, 어떤 것들을 학습하다보면 그동안 경험하지 못한것을 마주했을 때 의도치않은 불편함을 느끼게 되었다. 그런 경우 나는 주로 피해가거나, 돌아가거나 가장늦게 수행하는 방식으로 업무를 진행해왔는데, 이번에는 그냥 부딫치면서 진행해보았다.&lt;/p&gt;
&lt;p&gt;부딫치다보니 익숙해지고, 익숙해지다보니 깨달음이 왔다. 나의 가장 큰 문제점은 어떤 문제를 직면했을 때 완벽하게 해내려고 한다는 점이었다. 하지만, 내가 소화할 수 있는 수준으로 욕심을 줄이고 하나씩 붙혀서 앞으로 나아가는게, 나의 성장에 더욱 도움이 된다는 사실을 뼈져리게 느끼고 있는 중이고, 테스트도 그 중 하나이다.&lt;/p&gt;
&lt;p&gt;개발공부는 항상 새로운 것을 마주해야하는데, 앞으로 이런스탠스를 유지하여 불편한것을 피하기보다, 돌파하려고 노력해야겠다는 생각을 했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-27 Today I Learn]]></title><description><![CDATA[paging 을 좀더 영리하게 처리하기 기존에 paging 을 page를 이용해서 처리하고 있었는데, 오늘 적용 중에 팀원으로 부터 좋은 피드백을 받았다. 먼저, 나는 size, page, isAsc, sortBy 등을 DTO…]]></description><link>https://mitoconcrete.github.io/23_02_27/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_27/</guid><pubDate>Mon, 27 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;paging 을 좀더 영리하게 처리하기&lt;/h2&gt;
&lt;p&gt;기존에 paging 을 page를 이용해서 처리하고 있었는데, 오늘 적용 중에 팀원으로 부터 좋은 피드백을 받았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;먼저, 나는 size, page, isAsc, sortBy 등을 DTO로 만들어서 사용중이었다.
하지만, 굳이 DTO를 만들필요없이, Pageable을 곧바로 DTO처럼 만들어서 사용 할 수 있다는 사실을 알았다.
size, page, isAsc, sortBy 중 없는것이 있으면, 자동적으로 스킵하고 pageable을 만들어서 곧바로 repository에 넘길 수 있다.&lt;/li&gt;
&lt;li&gt;page를 사용하게 되면, 가장 큰 이슈가 풀스캔을 이용해 total 레코드 수를 불러온다는 것이다.
이것은 매 페이지 요청마다 전체 레코드 수를 세는 로직을 수행함으로서, 디비에 많은 부하를 준다. JPARepository는 Page외에도 Slice, List와 같은 형태도 사용할 수 있다.
이것을 사용하게 되면, total 레코드를 사용하지 않고, 그에 따라 불필요한 count쿼리가 날라가는 것을 방지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-4th Weekly I Learn]]></title><description><![CDATA[FACT-O1. 코드가 꼬인것을 풀어내었다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/23_02_4th/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_4th/</guid><pubDate>Sun, 26 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 코드가 꼬인것을 풀어내었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;서로 작업한 사항들이 잘 동작하지 않아서, 당황했다.&lt;/li&gt;
&lt;li&gt;마음이 급해졌을 때와는 다르게 침착하게 생각하려고하니, 조금씩 솔루션이 떠오르기 시작했다.&lt;/li&gt;
&lt;li&gt;도메인이 분리되어 있기에, 수정이 많이 발생하지 않을 거라고 생각했는데 많은 부분들을 건들여야해서 수정이 많이 발생했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stash 와 reset 을 적절하게 이용하여, 문제를 해결할 수 있었다.&lt;/li&gt;
&lt;li&gt;도메인이 분리되어있어도 기능을 구현하기 위해선, 이번 방식을 사용하면 안된다고 생각했다.&lt;/li&gt;
&lt;li&gt;깃 관리는 조금더 보수적으로 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;깃에 대한 허용은 자칫하면 꼬일 위험이 있다고 많다고 생각한다. 따라서, 깃 컨벤션과 같은 협업에 필요한 플로우는 조금더 보수적으로 다뤄야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;reset 보단 revert를 이용해서 과거내역으로 되돌리고 관리하는 방법도 익숙해져야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 팀 리더로서 어려움을 경험했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;일정이 다가오지만, 팀원들의 스케쥴을 관리하고 통합하는것이 쉽지 않았다.&lt;/li&gt;
&lt;li&gt;우선순위와 상관없이 밀려들어오는 의견들과 요구사항들에 대해서 컨트롤하기 쉽지않았다.&lt;/li&gt;
&lt;li&gt;쿠션어를 사용하여 팀원들을 설득하지 못했다.&lt;/li&gt;
&lt;li&gt;어쩔 수 없이 해야하는건 알지만, 일정사항 때문에 팀원들의 모두 요구사항을 수용하지 못하는 것이 찝찝했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 일단 여유가 없다보니, 쿠션어를 통해 설득하는 것이 어렵다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;내 입장에선 옳다고 생각하는게, 상대 입장에서는 고집이라고 생각할 수도 있겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;일정에 따른 우선순위와 성능적 개선 사이의 밸런스를 맞추기가 힘들다는 것을 느꼈고, 초반엔 일정에 따른 우선순위가 선점되는 것을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;우선 순위를 항상 팀원들에게 리마인드 하면 팀원들에게 현재 우리가 해야할 목표가 명확해지면서 조금은 불필요한 커뮤니케이션이 줄어들지 않을까 생각했다.&lt;/li&gt;
&lt;li&gt;일정과 목표를 잘 세워놓고, 그 due를 항상 리마인드 시켜줌으로서 불필요한 커뮤니케이션과 설득과정을 줄여야겠다고 다짐했다.&lt;/li&gt;
&lt;li&gt;감정적인 부분을 제발 내려놓자. 이성적으로 판단하고 행동하자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-24 Today I Learn]]></title><description><![CDATA[엑세스 토큰을 이용한 세션유지 플로우 변경 기존 서비스는 아래와 같이 엑세스 토큰을 이용한 플로우가 진행되었다. 엑세스 토큰을 발급한다. 해당 토큰이 만료되면, 서버에서 특정응답을 보낸다. 특정응답을 받은 클라이언트는 서버의 토큰 재발급 api…]]></description><link>https://mitoconcrete.github.io/23_02_24/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_24/</guid><pubDate>Fri, 24 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;엑세스 토큰을 이용한 세션유지 플로우 변경&lt;/h2&gt;
&lt;p&gt;기존 서비스는 아래와 같이 엑세스 토큰을 이용한 플로우가 진행되었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;엑세스 토큰을 발급한다.&lt;/li&gt;
&lt;li&gt;해당 토큰이 만료되면, 서버에서 특정응답을 보낸다.&lt;/li&gt;
&lt;li&gt;특정응답을 받은 클라이언트는 서버의 토큰 재발급 api로 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;서버는 새로운 토큰을 클라이언트에게 발급해주고, 클라이언트는 새로받은 토큰을 첨부하여, 같은 요청을 서버에 전송한다.
&lt;img src=&apos;/image/230224_01.png&apos; width=&apos;300&apos; alt=&apos;기존플로우&apos;&gt;&lt;/img&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 방법은 아래와 같은 상황을 야기했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 서버의 특정응답을 인지하기 어렵다.&lt;/li&gt;
&lt;li&gt;다시금 요청을 보내 발급을 받고, 또 다시 서버로 동일 요청을 보내는 일은 클라이언트에게 이전에 요청을 보낸 페이로드와 엔드포인트를 다시 알아와야하는 번거로움을 야기시킨다.&lt;/li&gt;
&lt;li&gt;클라이언트 - 서버간 연결이 원활하지 않을경우 여러번 티키타카하는 것에 문제가 발생할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;최종적으로 문제로 대두되었던 것은, 팀원들이 클라이언트와의 소통에 익숙하지 않으셨기때문에, 연결에 굉장한 애를 먹고 계셨고, 나또한 재발급을 위한 api를 따로 마련해두지 않았기 떄문에, 팀원들은 로그인이 풀릴때마다 다시 로그인을 해야하는 번거로움을 호소하셨다.&lt;/p&gt;
&lt;p&gt;따라서, 이 과정을 단순화하기 위해 아래전략을 세웠다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;엑세스토큰을 발급한다.&lt;/li&gt;
&lt;li&gt;토큰이 만료되면, 서버내부에서 새로운토큰을 발급받아 해당 토큰으로 일단 로직을 통과시킨다.&lt;/li&gt;
&lt;li&gt;응답값과 함께 헤더에 새로 발급한 토큰을 실어 보내준다.&lt;/li&gt;
&lt;li&gt;클라이언트는 헤더에 새로운 토큰이 있다면, 자신의 로컬저장소의 엑세스토큰을 재갱신한다.
&lt;img src=&apos;/image/230224_02.png&apos; width=&apos;300&apos; alt=&apos;기존플로우&apos;&gt;&lt;/img&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 되니 세션이 끊기지도 않고, 서버에 로직이 조금 추가되었을 뿐, 좀 더 플로우가 심플해졌다.
극단적으로 엑세스토큰의 만료 시간을 1초로 뒀는데, 끊임없이 갱신되며 세션이 유지되었다.
&lt;img src=&apos;/image/230224_03.png&apos; width=&apos;300&apos; alt=&apos;기존플로우&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;의미있는 개선이었다. 하지만, 아직 리프레시토큰이 만료되었을 경우에 대한 대처가 미흡하고, TTL적용이 되어있지 않아서 더 개선이 필요하다. 다음주 유지보수 때 좀 개선해보아야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-23 Today I Learn]]></title><description><![CDATA[중간 발표 준비 오늘은 MVP…]]></description><link>https://mitoconcrete.github.io/23_02_23/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_23/</guid><pubDate>Thu, 23 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;중간 발표 준비&lt;/h2&gt;
&lt;p&gt;오늘은 MVP를 마치고, 중간 발표를 위한 테스트와 발표전략을 짜기로 했다.
가장 큰 이슈는 아직 많은 기능들이 미흡하고, 완성이 되지 않았다는 것 이었다. 다들 시간에 쫒겨서 진행하다보니 테스트도 진행하지 못하고 완성하지 못한 화면들도 있었다.
그래도 일정은 맞춰야하기 때문에, 해당 신경쓰이는 사항들에 대해서는 일단 체크만 해두고, 내일중으로 함께 리팩토링 해보자고 말씀드렸다.
전날 팀원들이 다같이 밤을 지새우고 6시에 잤기 때문에, 회의시간은 12시로 늦추고 개인시간을 가졌다.
모두 코드에 대한 미련은 버리지 못하는게 보였지만, 그래도 할건해야하기에.. 팀원들을 모아서 태스크들을 쳐냈다. 모든게 처음이라 막막했지만 그래도 큰 틀을 잡고, 순서대로 쳐내보자 라는 마인드로 다음과 같은 순서를 정했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;역할분담&lt;/li&gt;
&lt;li&gt;발표 플로우 결정&lt;/li&gt;
&lt;li&gt;시연영상 플로우 결정&lt;/li&gt;
&lt;li&gt;기술적 의사결정 + 트러블 슈팅 공유&lt;/li&gt;
&lt;li&gt;추후 나아갈 방향 결정&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5개의 역할은 분배하고, 4명은 발표준비 1명은 앞으로 나아갈 프로젝트를 위해 QA를 부탁드렸다. 팀원분들 중 가장 예리하고 최적화에 대한 지식이 많으신분이 역할을 자진해주셨다.
또한 나머지는 영상촬영 영상편집 발표준비 피피티준비로 역할을 나눴다. 이후에 발표 진행 플로우를 결정했다. 다행이도 캠프 측에서 준 큰 틀이 있어서 해당 틀을 참고했다.
각 순서별로 어떤 자료를 어떤 전략으로 수집해서 사용할지, 우리가 중점을 둬야할 곳은 어딘지 결정했다.&lt;/p&gt;
&lt;p&gt;시연영상 플로우는 우리서비스는 유저,판매자,관리자페이지로 나뉘고 각각의 기능을 분리해서 보여주기엔 너무 연계성이 없어서 스토리를 정하고, 그에 따라 시연을 하기로 정했다.
전반적인 서비스 플로우를 보여주되 살짝 코믹한 요소를 집어넣었다.&lt;/p&gt;
&lt;p&gt;기술적 의사결정 및 트러블 슈팅은 이번 발표에서 가장 중점이 될 수 있는 사안이었다. 따라서, 2시간정도의 시간을 잡고 이야기를 나누었다. 기술적의사결정은 프로젝트 진행 중 어떤 갈래가 생겼을 때 어떤 과정을 통해서 현재의 결정을 했는지이고 트러블 슈팅은 잘 구동되지만, 더 나은 퍼포먼스에 대한 개선경험을 의미했다. 해당 워딩을 정의하고, 각 의미에 맞게 이번 프로젝트에서 의미있고 기억에 남았던 것들을 1시간 동안 적어보기로 했다. 1시간이 넉넉하다고 생각했는데, 정말 부족했다. 그만큼 프로젝트 때 많은 고민을 했다고 생각이 되어 약간은 뿌듯했다. 하지만, 앞으로 할일들이 많이 남아서 막막하긴했다.&lt;/p&gt;
&lt;p&gt;마지막으로 우리가 해야할 일들에 대해 정리를 해보았는데, 다들 기능에 대한 욕심이 줄어든 것을 보고 다들 현실적으로 변한게 느껴졌다.
다들 웃음으로 이 현실을 마주하면서, 앞으로 우리가 해나가야 할 것들에 대해 이야기를 나눠보았다.&lt;/p&gt;
&lt;p&gt;이후 각자역할에 맡는 액션을 나누고 헤어졌다. 다행히도 늦지않은 시간까지 모두 마무리하고, 잠을 청할 수 있게 되었다. 오늘 하루는 좀 뿌듯했다.
나름 틀을 잘 잡은 것 같기도 하고, 팀원들도 정말 잘 따라줬기 때문이다. 그리고 원래 해당 준비를 혼자해야할 수도 있어서 막막했는데, 알아서 분배해서 가져가시고, 가져간 역할에 대해 최선을 다하는 모습을 보면서 더 뿌듯했던 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-22 Today I Learn]]></title><description><![CDATA[코드 컨플릭트 1차 해결 오늘까지가 due…]]></description><link>https://mitoconcrete.github.io/23_02_22/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_22/</guid><pubDate>Wed, 22 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;코드 컨플릭트 1차 해결&lt;/h2&gt;
&lt;p&gt;오늘까지가 due라서 오늘까지 프론트작업을 마무리해달라고 팀원들에게 부탁했다. 다들 자신있어하셨다. 이 땐 몰랐지.. 우리의 코드가 엉겅퀴처럼 꼬일 줄은.. ㅋㅋ
위에서 말한대로 코드를 병합하는 과정에서 많은 충돌이 발생했다. 문제는 2분의 코드가 꼬임에 따라 발생한 것인데, 1분은 PR을 날리고 4일동안 업데이트가 안된 코드였고, 1분은 파일명과 다른사람이 작업하신 파일들을 수정하신것들이 있었고, 그에 따라 코드충돌이 어마무시하게 일어났다.&lt;/p&gt;
&lt;p&gt;원래, 프론트 작업 남은게 있어서 그거하고 일찍 잠들려고 했는데.. 심지어 밥먹으려고 아내는 기다리고 있는데.. 갑작스러운 상황에 머릿속이 캄캄해졌다.&lt;/p&gt;
&lt;p&gt;침착하고 순서를 다시잡았다. 일단 머지된 코드 중 가장 많은 충돌이 난 코드를 리버트 시켜 걷어낸 뒤, 기존에 있던 컨플릭트를 해결하였다. 이후에, 걷어낸 코드를 PR을 날리신 분에게 컨플릭트해결을 부탁드렸다. 아무래도 수정한 분이 이유가 있으실테니, origin 에서 풀을 당겨 진행해달라고 말씀드렸다. 그리고 전략이 잘 세워지지 않거나, 막막한 경우 같이 해결해드린다고 했는데 어디가 문제인지 알 것 같다고 말씀주셔서 부탁드렸다.&lt;/p&gt;
&lt;p&gt;이렇게 일단락 되는가 싶었으나..&lt;/p&gt;
&lt;h2&gt;코드컨플릭트 2차 해결&lt;/h2&gt;
&lt;p&gt;나포함 많은 분들이 작업하신, 파일들이 사라지거나 수정되는 현상을 발견할 수 있었다. 즉, 어딘가에서 문제가 발생했고, 그 문제에 따라 각자의 입장에 맞는 코드가 작성되었고, 그에따라 코드가 사라진 현상이 발생한 것이다.
나는 팀원들을 소집해서 작업을 중단시켰다. 일단 작업도 중요하지만, 컨플릭트는 산으로가면 백두산까지 가기 때문에 이걸 먼저 맞추고 가는것이 좋겠다고 말씀드렸다.전략은 다음과 같았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;일단 origin 과 가장 거리가 먼 head를 가진 사람을 찾는다.&lt;/li&gt;
&lt;li&gt;문제가 발생되기 전으로 되돌린다.&lt;/li&gt;
&lt;li&gt;문제가 발생되지 않는 코드로 컨플릭트를 수정한다.&lt;/li&gt;
&lt;li&gt;머지한다.&lt;/li&gt;
&lt;li&gt;그다음 origin 과 가장 먼 head를 가진 사람을 찾는다.&lt;/li&gt;
&lt;li&gt;문제가 발생되기 전으로 되돌린다.&lt;/li&gt;
&lt;li&gt;문제가 발생되지 않는 코드로 컨플릭트를 수정한다.&lt;/li&gt;
&lt;li&gt;머지한다.
..
.
..
.
이렇게 5명이 모두 같은 방법으로 일단 dev에 있는 코드를 맞추고 그걸 기점으로 다시 시작하는 것이다.
이렇게 하니 2,3시간이 후딱가긴했는데, 문제가 해결되었고 모두가 동일한 선상에서 코드작성을 시작할 수 있었다.
stash와 reset 을 적절히 병합해서 문제를 해결했다.
문제의 원인은 프론트작업 할 때 각자 필요한부분들이 다르니, 다른 도메인 작업자에게 요청하지말고, 컨플릭트났을 때 수정하자! 라는 전략을 팀원들에게 제안해서 였다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;뼈져리게 후회하고 있고 해당전략을 다음엔 사용하지 말아야겠다는 다짐을 했다.
그래도 해결되서 다행이다!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-21 Today I Learn]]></title><description><![CDATA[프론트 작업을 1차로 마무리하다. 오늘은 api를 하나씩 붙히는 작업을 진행하였다. 유저단에는 총 23개의 api를 붙혔어야했는데, 생각보다 백엔드와 로직을 맞추는 과정이 시간이 많이 소요 되었다.
많은 분들이 CORS…]]></description><link>https://mitoconcrete.github.io/23_02_21/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_21/</guid><pubDate>Tue, 21 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;프론트 작업을 1차로 마무리하다.&lt;/h2&gt;
&lt;p&gt;오늘은 api를 하나씩 붙히는 작업을 진행하였다. 유저단에는 총 23개의 api를 붙혔어야했는데, 생각보다 백엔드와 로직을 맞추는 과정이 시간이 많이 소요 되었다.
많은 분들이 CORS를 해결하지 못하고 어려워하는 모습을 보았다. 그래도 나에게 질문이 들어왔을때, 지난번에 공부한 탓에 발생원인에 대해서 파악하고, 설명드리고 이해시켜드릴 수 있어서 좋았다.&lt;/p&gt;
&lt;p&gt;그나저나 도메인 별로 코드를 분리해서 브랜치작업을 쭉 진행하다보니, 각 도메인 별로 작업사항이 점차 많아짐에 따라, origin dev와 점점 멀어지는 현상이 발생하고 있다. 어쩔 수 없이 중간중간 한번씩 모여서 진행사항을 확인하고, 언제쯤 병합을 해야하는지 체크하고 있다.
조원들도 다들 프론트 작업으로 힘겨워하고 계시긴한데, 문제들을 잘 해결해나가시는 중이라 믿고 맡길 수 있어서 든든하다. 이번 프로젝트에서 &apos;뒤를 맡길 수 있는 동료&apos;가 있는게 얼마나 좋은 일인지 느낄 수 있어서 좋다. 나는 과연 다른사람들에게 그런사람일지는 모르겠지만.. 그런 사람이 될 수 있도록 노력해야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-20 Today I Learn]]></title><description><![CDATA[순환 참조 발생을 해결하다. 오늘 중요로직을 작업 중, 끔찍한 순환참조 이슈를 마주했다.
주요 원인은 협업을 유리하게끔 하기 위한 도구인 internal service…]]></description><link>https://mitoconcrete.github.io/23_02_20/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_20/</guid><pubDate>Mon, 20 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;순환 참조 발생을 해결하다.&lt;/h2&gt;
&lt;p&gt;오늘 중요로직을 작업 중, 끔찍한 순환참조 이슈를 마주했다.
주요 원인은 협업을 유리하게끔 하기 위한 도구인 internal service가 서로가 서로를 참조하며 빈을 등록할 때 이슈가 발생한 것이다.
따라서, 각 서비스들 내부에서 각각 어떤 internal service를 참조하는지 확인해보았다. 처음에는 머리가 잘 돌아가지 않아서, 문제를 해결하는 것에 난항을 겪었다. 따라서, 종이를 열고 알고리즘 문제 푸는 것 처럼 어느곳이 어느곳을 현재 참조하고 있는지 확인해보았다.
확인해보니, 레스토랑이라는 서비스를 여러군데에서 호출하고 있었고, 이에 따라 레스토랑 서비스가 자신을 호출하는 곳을 다시 internal service로 호출함에 따라 해당 문제가 발생한 것이었다. 해당문제는 초반설계 시 고려하지 못한 이슈여서 많이 당황했다. 로직 상 서로가 서로를 참조하진 않지만, 빈들이 등록되는 과정에서 순환참조오류가 발생하는 문제는 다음 설계부터는 신경써야겠다는 깨달음을 얻었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-3rd Weekly I Learn]]></title><description><![CDATA[FACT-O1. 코드리뷰를 진행했다. FEELINGS 생각보다 코드리뷰에 쏟는 시간이 길어져서 당황했다. 생각보다 리뷰를 꼼꼼하게 달아주셔서 당황했다. 내 코드를 남이 보고 평가한다는 점에서 부담되었다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/23_02_3rd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_3rd/</guid><pubDate>Sun, 19 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 코드리뷰를 진행했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;생각보다 코드리뷰에 쏟는 시간이 길어져서 당황했다.&lt;/li&gt;
&lt;li&gt;생각보다 리뷰를 꼼꼼하게 달아주셔서 당황했다.&lt;/li&gt;
&lt;li&gt;내 코드를 남이 보고 평가한다는 점에서 부담되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;점점 코드를 작성할때 남이 어떻게 읽을 수 있을지 신경쓰면서 코드를 작성하는 내 모습을 볼 수 있었다.&lt;/li&gt;
&lt;li&gt;처음에는 다른 기준이 나의 코드에 접목되는 점이 부담되었지만, 무조건 적용을 하는것이아니라, 의견을 주고 받으면서 컨벤션같은 것들을 맞춰나갈 수 있어서 좋았다.&lt;/li&gt;
&lt;li&gt;코드들이 점점 일관되어지고, 깔끔해지는 것이 보여서 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;코드리뷰는 반드시 적용을 하되, 컨벤션 뿐만 아니라 흐름을 읽을 수 있게 작은 단위로 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;또한, 중점적으로 짚어야 할 기준들을 잘 세워야겠다고 생각했다. 크리티컬/하드/미디움/소프트와 같이 우선순위를 매겨서 라벨링을 달고, 추후에 개선해야할 것들 당장에 개선을 해야 할 점들을 팀차원에서도 구분해야겠다고 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-17 Today I Learn]]></title><description><![CDATA[캐시의 역할은
CPU…]]></description><link>https://mitoconcrete.github.io/23_02_17/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_17/</guid><pubDate>Fri, 17 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;캐시의 역할은
CPU와 메모리 사이의 데이터 전송 지연속도를 개선하기 위한 전략이다.&lt;/p&gt;
&lt;p&gt;지역성(캐싱 알고리즘)을 이용하여 캐싱할 데이터를 결정한다.&lt;/p&gt;
&lt;p&gt;시간적 지역성은 어떤 데이터를 사용했을때 가까운 미래에 해당 데이터를 재사용한다고 믿는것이고
공간적 지역성은 어떤 데이터를 사용했을때 인접한 데이터도 사용한다고 믿는것이다.&lt;/p&gt;
&lt;p&gt;캐싱알고리즘은 시간적, 공간적 지역성에 따라 데이터를 캐싱한다.&lt;/p&gt;
&lt;p&gt;다이나믹 어레이는
자료가 추가되면, 해당 자료형 만큼 메모리가 추가된다.
base offset + (index + 자료형 byte)
ex) const a = []
a.push(1)
b.push(2)&lt;/p&gt;
&lt;p&gt;a[0] 주소는 100 이라면
a[1]의 주소는 어디인가? -&gt; 104번지 이유는 int형은 4바이트이므로
a[0]은 메모리의 100~103번지의 4바이트를 차지한다. 따라서, 다음 값의 시작점은 104번지이다.&lt;/p&gt;
&lt;p&gt;캐시의 목적은 메모리의 데이터를 CPU가 빠르게 가져와 접근하기 위해
L1~3 단계의 캐시가 있는데 넘버가 올라갈수록 cpu에 가까워지며, 용량이 작아진다.&lt;/p&gt;
&lt;p&gt;캐시코히런스 : 캐싱된 데이터의 원본이 변경되었을때 캐시에 저장된 데이터의 일관성과 무결성이 보장되지 않는상태&lt;/p&gt;
&lt;p&gt;x to y 관계에대해 y가반드시 있을경우 관계를맺눈다&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-16 Today I Learn]]></title><description><![CDATA[JPA 는 DB를 다루기 위한 인터페이스의 모음들이다.
Hibernate는 이 인터페이스를 실제로 사용할 수 있도록 JPA를 implement…]]></description><link>https://mitoconcrete.github.io/23_02_16/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_16/</guid><pubDate>Thu, 16 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JPA 는 DB를 다루기 위한 인터페이스의 모음들이다.
Hibernate는 이 인터페이스를 실제로 사용할 수 있도록 JPA를 implement하여 실제로 사용가능하게 만든 구현체이다. 객체지향도메인모델을 관계형 데이터베이스로 맵핑하기 위한 프레임워크이다.&lt;/p&gt;
&lt;p&gt;영속성은 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 특성이다.
어플리케이션 데이터는 일회성이면 안되기때문에 데이터를 DB에 저장하여 영속성을 부여한다.&lt;/p&gt;
&lt;p&gt;ORM 객체(Entity)를 DB와 연결하여 관리를 편하게 해주는것
JDBC 는 JPA - DB간의 연결해주는 것. 즉, 개발자가 JPA를 사용하면, JPA내부에 위치한 JDBC API가 DB에 트랜젝션을 보내 수행한다.&lt;/p&gt;
&lt;p&gt;application -&gt; (Spring Data JPA(Repository 사용))-&gt; Raw JPA(Entity Manager 사용) -&gt; Hibernate -&gt; JDBC -&gt; DB&lt;/p&gt;
&lt;p&gt;연관관계 맵핑
방향 : 단방향, 양방향
다중성 : 일대일, 일대다, 다대일, 다대다
연관관계의 주인이 되는곳에 @JoinColumn을 표시해준다.
연관관계의 주인은 외래키를 관리하는 곳이다.&lt;/p&gt;
&lt;p&gt;1:1 관계를 지정하기에 앞서, 이 관계를 굳이 분리시켜야하는지를 고민해봐야한다.&lt;/p&gt;
&lt;p&gt;mappedby를 이용해 자식에서 주인을 설정해준다.
@ManyToOne 은 항상 연관관계에서 주인이 되기 때문에 mappedby를 사용하지않는다.&lt;/p&gt;
&lt;p&gt;다대일관계에서 주로발생하는 에러
다는 일에 해당되는 정보가 저장되어있는데, 일은 다에 대한 정보를 들고 있지 않음&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-15 Today I Learn]]></title><description><![CDATA[access token - refersh token 사용 전략 원래는 로그인 시, access token과 refresh token 을 같이 보내고, access token 의 주기를 짧게하여, 만료되면 특정 url…]]></description><link>https://mitoconcrete.github.io/23_02_15/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_15/</guid><pubDate>Wed, 15 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;access token - refersh token 사용 전략&lt;/h2&gt;
&lt;p&gt;원래는 로그인 시, access token과 refresh token 을 같이 보내고, access token 의 주기를 짧게하여, 만료되면 특정 url로 요청을 보내고, 그때서야 비로스 리프레시 토큰을 검증하여 엑세스 토큰을 재발급하는 형식으로 진행되었다.
rfc에는 oauth2에 대해 아래와 같은 방식을 추천했고, 위에 서술한 방식은 방식을 그대로 따르는 것이기 때문에 이것이 맞다고 생각하고, redis 의 사용에 대해서 의도적으로 배제했다. redis는 인메모리이긴 하지만, 엄연히 db이고 검증을 위해 db에 다녀오는 일은 말그대로 맨 뒷단(Repository)에 다녀오는 것이기 때문에, 의도적으로 배제시키려고했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant ---------&gt;|               |
  |        |                                           |               |
  |        |&amp;lt;-(B)----------- Access Token -------------|               |
  |        |               &amp;amp; Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&amp;lt;-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&amp;lt;-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token -----------&gt;|               |
  |        |                                           |               |
  |        |&amp;lt;-(H)----------- Access Token -------------|               |
  +--------+           &amp;amp; Optional Refresh Token        +---------------+&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;redis 사용하기&lt;/h2&gt;
&lt;p&gt;하지만, 위의 그림에서 인가서버와 리소스서버를 따로 이용하는 것을 보면서, 인증/인가만을 위한 서버를 따로 두는것이 더 낫겠다고 판단했다. 리소스서버 즉, 실제 비즈니스 로직이 돌아가는 서버와 단일 기능을 가진 서버는 따로 두는것이 맞으며, 그에따라 DB의 역할도 나뉘어야한다고 어느순간 깨달음이 왔다. 또한, JWT자체에 클레임들이 들어가기 때문에, 만료되지 않은 토큰이 클라이언트에 보여지는 상황자체가 기존에도 와닿지 않아서, 서버측에 refreshtoken을 저장하는 방식에 대한 호감이 증가했다. 따라서, 나는 아래와 같이 코드전략을 짰다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;로그인 시도 시, accesstoken 과 refreshtoken을 동시에 발급하며, accesstoken은 매우 짧은 주기(30분)으로 설정한다.
refreshtoken은 redis에 저장하고, accestoken은 response header에 넣어서 전달한다.&lt;/li&gt;
&lt;li&gt;access token 이 만료됨에 따라 redis에 저장한 refreshtoken을 확인한다.&lt;/li&gt;
&lt;li&gt;refreshtoken이 유효하다면, accesstoken을 발급하여 세션을 이어나갈 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;refreshtoken이 유효하지않다면, 그냥 로그아웃 한다. 그리고 더이상 사용하지 않아도 좋으니, redis에서 삭제해준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그리고 로그아웃할때 accesstoken을 redis에 저장해주는데, 소위 &lt;strong&gt;블랙리스트&lt;/strong&gt; 라고 하는데, 이걸 그동안 왜 해야하는지 이해하지 못했다.
어차피 클라이언트에서 지워주면 다시 사용할 수 있으니깐!&lt;/p&gt;
&lt;p&gt;그런데 다시 생각해보니, 해당 토큰을 재 사용하는 경우 해킹된다면 유효기간이 남은 토큰을 그대로 쓸 가능성이 있고, 이런경우를 위해 로그아웃 처리가 되면 이 토큰은 이미 죽어버린 토큰이라는 마킹을 해줘야하는 것 이다.
이렇게 redis를 사용한, 우당탕탕 플로우 개발이 끝났다.&lt;/p&gt;
&lt;h2&gt;firebase hosting시 새로고침 해도 페이지가 뜰 수 있도록 하기&lt;/h2&gt;
&lt;p&gt;그동안 SPA를 이용해서 작업을 할 때, 고질적으로 겪었던 문제는 개발환경에서는 괜찮은데, /login 과 같이 /하위의 페이지에서 리다이렉트를 하게되면, 404.html이 보이게 되던 이슈가 있었다. 해당이슈는 백엔드를 배우니 조금더 잘 이해가 되었다. 리액트나 뷰등으로 만들어진 싱글페이지어플리케이션은 index.html 이라는 엔트리포인트를 기준으로 렌더링이 되는 것이다. 보통 백엔드는 login.html, signup.html 과 같이 해당 페이지에 맵핑되는 html이 있는반면, SPA는 index.html 에 작성한 로직들이 모이는 식이다. 따라서 /login 위치에 실제로 login.html이 존재하지 않고, 그에 따라 404.html를 보여주고 있었던 것 이다.&lt;/p&gt;
&lt;p&gt;그럼 어떻게 하면 될까?&lt;/p&gt;
&lt;p&gt;보통 이런 권한은 호스팅하는 곳에 맡기면 된다. 다른페이지 요청이 들어와도 index.html이 덮어쓰게 해줘라는 명령어를 적어주면 되는데, firebase는 firebase.json에 아래와 같이 설정을 해주면 해결된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;    &lt;span class=&quot;token property&quot;&gt;&quot;rewrites&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token property&quot;&gt;&quot;source&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;**&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token property&quot;&gt;&quot;destination&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/index.html&quot;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해당 이슈의 해결을 통해 SPA에 대한 이해가 한단계 높아졌다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-14 Today I Learn]]></title><description><![CDATA[1. enum 비교 시 equles 대신 == 를 사용해야하는이유. == 는 null safe 합니다. equals는 내부적으로 == 를 사용하여 비교합니다. 2. soft delete 를 사용하는 엔티티의 삭제 구현하기 soft delete…]]></description><link>https://mitoconcrete.github.io/23_02_14/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_14/</guid><pubDate>Tue, 14 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. enum 비교 시 equles 대신 == 를 사용해야하는이유.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;== 는 null safe 합니다.&lt;/li&gt;
&lt;li&gt;equals는 내부적으로 == 를 사용하여 비교합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. soft delete 를 사용하는 엔티티의 삭제 구현하기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;soft delete 는 엔티티를 직접삭제하는 것이 아니라, is&lt;em&gt;deleted/is&lt;/em&gt;removed 와 같은 value 값을 전환함으로서, 레코드는 그대로 두고 삭제를 구현하는 것이다.&lt;/li&gt;
&lt;li&gt;본래는 엔티티의 is_delete 값을 업데이트 하고 save함으로서, 처리를 하였는데 @SQLDelete 라는 것을 사용하게 되면 로우쿼리를 날려, softdelete 를 구현할 수 있다.
아래와 같이 표현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@SQLDelete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sql &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;UPDATE user SET is_deleted = true WHERE id = ?&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. soft delete 엔티티를 제외하고 조회하기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;soft delete 를 사용할 때, 굳이 is_delete 된 것을 조회하고 싶지 않을 수도 있고, 굳이 JPA문법을 이용해 매번 조건을 붙히기 귀찮은 경우도 있다. 이럴땐 @Where 절을 이용하여, 특정 컬럼에 대한 필터링을 할 수 있다.&lt;/li&gt;
&lt;li&gt;하지만, 만약 delete 된 값을 불러오고 싶다면, native쿼리를 사용하거나(@Query), @FilterDef와 @Filter 를 사용하면 된다고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. 코드리뷰지옥&lt;/h2&gt;
&lt;p&gt;오늘은 하루종일 코드리뷰를 주고받으면서, 악취를 걷어냈다.
우리조에 JPA 고수가 계셔서 많은 도움을 받았다. 계속 대응하다보니 어느새 40개가 넘는 개선 사항이 쌓였다. 악취가 많이 난다는 뜻이겠지..
확실히 혼자하는 것 보다 같이 함으로서 얻어가는게 많은 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-13 Today I Learn]]></title><description><![CDATA[1. 그래들에서 의존성 충돌이 발생했을 경우 해결하기 Test코드를 작성하려고 하는데, Log4j 라이브러리가 충돌하여 Bean…]]></description><link>https://mitoconcrete.github.io/23_02_13/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_13/</guid><pubDate>Mon, 13 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 그래들에서 의존성 충돌이 발생했을 경우 해결하기&lt;/h2&gt;
&lt;p&gt;Test코드를 작성하려고 하는데, Log4j 라이브러리가 충돌하여 Bean 등록이 원홯라게 안되는 이슈가 있었다. 팀원 분들이 다같이 통합테스트를 못하는 상황이 발생하였는데, 한 팀원분께서 솔루션을 찾아서 공유주셨다.
자바스크립트로 개발을 할 때는 이런 상황이 생기면, 어떻게 할 줄 몰랐는데, 그래들에서는 아래와 같이 사용할 의존성과 배제할 의존성을 구분지을 수 있는 것 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;testImplementation &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&apos;it&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ozimov&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;embedded&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;redis&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.3&lt;/span&gt;&apos;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        exclude group&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;org.slf4j&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;slf4j-simple&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아직 빈의 등록에 대해 이해하고 있지 못하는 것들이 많다. 슬슬 예전에 배웠던 것들도 까먹고 있는데 슬슬 리마인드 해야할 시기가 오고 있다.&lt;/p&gt;
&lt;h2&gt;2. 벽이 느껴질 때 마인드 컨트롤&lt;/h2&gt;
&lt;p&gt;오늘 선발대 수업을 들었는데, 이제는 점점 내 역량을 넘어서는 기분이 든다. 백엔드 개발자는 쿼리를 개선하고, 로직을 수정해나가면서 퍼포먼스를 개선해야하는데, 어느 순간이 되면 내가 소화를 못하는 느낌이 든다. 여태까지 개발을 공부하면서, 이 벽을 넘기가 매우 힘들었던 것 같다.&lt;/p&gt;
&lt;p&gt;나의 속도를 아직 나는 모르는 것 같다. 나보다 뛰어난 다른사람을 쫒아가려다보니 큰 벽이 느껴지고, 그 벽을 한번에 넘으려고 하다보니 더욱이 거부감은 크다.
마라톤을 하기전에 막막한 기분과 비슷한 기분이다. 내가 마라톤을 뛰는 길은 일정한 간격마다 가로수가 있다. 체력이 너무 안될때는 내 바로앞 가로수를 지속적으로 목표로 잡으며, 최종목적지 까지 향했고, 이 목표는 점차 두칸 - 열칸씩 늘어났다.&lt;/p&gt;
&lt;p&gt;개발도 비슷한 것 같다. 나보다 한참 앞서있는 상대를 보면서 박탈감을 느끼는 것은 어쩔 수 없지만, 내가 그 곳에 다다르지 못할 이유도 없다.
꾸준히 바로 앞에 있는 것을 바라보면서 전진하다보면, 언젠가 내가 이상적으로 보고 있는 사람들의 위치에 도달 할 수 있지 않을까.. 생각한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-2nd Weekly I Learn]]></title><description><![CDATA[FACT-O1. 프로젝트 구조를 위해 다른사람들과 치열하게 토론했다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/23_02_2nd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_2nd/</guid><pubDate>Sat, 11 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 프로젝트 구조를 위해 다른사람들과 치열하게 토론했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;기존에는 주도하던 입장이었기에, 이런 토론이 낯설었다.&lt;/li&gt;
&lt;li&gt;계속 발생하는 브레이크에 당혹스러웠고, 어쩔때는 답답했다.&lt;/li&gt;
&lt;li&gt;기획 진도가 나가지 않아서 힘들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의견을 내는 것에 대해 타당한 이유를 들어 팀원들을 기술적으로 설득하는 과정을 반복함에 따라, 내가 아는것과 모르는 것에 대한 메타인지능력을 키울 수 있었습니다.&lt;/li&gt;
&lt;li&gt;그동안 기술을 선택하는 것에 대해 스스로에 대한 납득만 있었으면 되었었는데, 다른 사람들의 이해를 뚫어야 최종적으로 선발이 될 수 있기 때문에 기술선택에 대해서는 더욱더 많은 기준과 잣대를 둬야겠다는 생각이 들었습니다. 또한, 그것을 혼자하는 것이 어렵기 때문에 팀과함께하는 것이 얼마나 소중한 일인지 깨달았습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;개발자로 성장하기 위해서, 소통하는 것에 대해 거부감을 느끼지 않고 끊임없이 타인과 소통하는 과정을 즐겨야겠다고 생각했습니다.&lt;/li&gt;
&lt;li&gt;또한, 이 과정을 통해서 실수를 점차줄이며 뒤를 맡겨도 든든한 개발자가 되고 싶습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-10 Today I Learn]]></title><description><![CDATA[…]]></description><link>https://mitoconcrete.github.io/23_02_10/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_10/</guid><pubDate>Fri, 10 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;프로젝트를 하면서 배워나가기&lt;/h2&gt;
&lt;p&gt;오늘은 문서를 완성하고, 코드작업을 시작했다.
엔티티 점검을 받았는데, 정규화가 필요한 곳이 있다는 피드백을 받았다. 이전에 오갔던 이야기이긴 했는데, 변경이 자주일어나는 필드들은 따로 분리했다.
또한 어떤 애너테이션을 사용하게 되면 리스트형태로 저장된 데이터를 컨트롤 하기 편하단 것을 배웠다.&lt;/p&gt;
&lt;p&gt;또한 SuperMappedClass 같은 경우에는 실제로 생성되는 객체가 아니기 때문에 추상클래스로 선언하여 사용한다고 한다.
이외에 메소드 규칙이나 네이밍 규칙같이 정말 사소한 것들도 협업에서는 잡고가는 게 좋다고 생각했고, 오늘은 사소하다고 생각하는 것을 맞추는 데 시간을 많이 썼다.&lt;/p&gt;
&lt;p&gt;최종적으로 엔티티, 서비스, 레파지토리 등을 만들고 저장했는데, 아무리 맞춘것이 많다고 하지만, 그것에 익숙치 않다보니 다들 오타도 많이 나고 그래서 리뷰하는 시간이 꽤나 걸렸다.&lt;/p&gt;
&lt;p&gt;git 에 익숙하지 않은 팀원들도 있어서, 초반에는 조금의 우여곡절이 있지 않을까 생각한다.
하지만, 아직까진 일정에 대한 자신감은 있어서 좋은 서비스를 빨리 만들어서 선보여내고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-09 Today I Learn]]></title><description><![CDATA[…]]></description><link>https://mitoconcrete.github.io/23_02_09/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_09/</guid><pubDate>Thu, 09 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;함께 일하고 싶은 동료가 되기&lt;/h2&gt;
&lt;p&gt;챌린지 팀에서 뛰어난 동료들과 함께 최종프로젝트를 진행하고 있다.
지금은 설계 과정으로서, 가장 커뮤니케이션이 많은 시점이다. 어떤 프로덕트를 처음부터 만들어나가다보니, 빈 도화지에 그림을 그리는 것 만큼 많은 것들을 이야기하고, 맞춰나가고 있다.&lt;/p&gt;
&lt;p&gt;지난 5일동안 나와 가장 치열하게 의견을 나눈 동료분이 계시다. 동료와 같은 그림을 맞춰나가는 것에 집중해야하기에 나는 그동안 최적화나 구조에 전혀 신경쓰지 않고 프로젝트를 진행해왔다. 이런 것들은, 나중에 유지보수를 해가면서 신경써도 되는 부분이기때문이다.
하지만, 다른 동료는 최적화나 구조에 굉장히 많은 포커스를 맞추고 계신분이다. 따라서, 내 입장에서는 이 분이 신경쓰시는 부분들이 우선순위가 낮은 업무들이었다. 반대로 이분에게는 내가하는 설계가 우선순위가 낮은 설계방식이었다.&lt;/p&gt;
&lt;p&gt;첫 3일은 서로의 성향을 모르기에 치열하게 토론을 나누었다. 설계성향은 다르지만, 둘 다 모두 설계의 결함이나 워딩같은 사소하게 넘길 수 있는 문제들을 신경쓴다는 공통점이 있었다.&lt;/p&gt;
&lt;p&gt;의견이 충돌할 때 빠르게 해결 &apos;투표&apos;라는 방식을 선택한 뒤에도, 같은 뜻을 가졌더라도 restful하게 설계하는 방식이나, 사용하는 단어가 차이가 있기 때문에 왜 이것을 사용해야하는지 서로가 서로를 설득시킬 필요가 있었다.&lt;/p&gt;
&lt;p&gt;처음에는 이 과정이 지치고 머리아픈 일이라고 생각했지만, 어느순간 이 동료분이 내 의견의 모순점에 대해 지적해주지 않으면 뭔가 불안하게 느껴졌다.
&apos;내가 무엇이 그렇게 틀려서 지적하시는거지?&apos; 라는 생각에서 &apos;내 틀린부분을 왜 지적해주시지 않는거지?&apos; 라는 생각으로 점차 바뀌어갔고, 이렇게 느껴진 순간부터 &apos;난 이분에게 내 뒤를 맡길 수 있어&apos;라는 강력한 믿음을 가지게 된 것 같다.&lt;/p&gt;
&lt;p&gt;예전 &apos;태양의 후예&apos;라는 드라마 첫회에서 유시진과 미군장교와 처음으로 마주할때 칼이 오고가는 치열한 육탄전을 하는 장면이 있다. 비록 픽션이긴 하지만, 이 싸움의 이유가 연합작전 시 서로가 서로의 등을 맡길 수 있는 동료임을 확인하기 위해서라고 했다.&lt;/p&gt;
&lt;p&gt;개발자는 지식노동자이기 때문에, 군인과 다르게 지식으로 서로에게 믿음을 준다. 그 지식을 표현할 수 있는 것은 &apos;말&apos;이기 때문에 서로 다른환경에서 일을해오다 만난 사람들에게 서로 뒤를 맡길 수 있음을 개발자로서 확인 할 수있는 것은 &apos;말&apos;이고, 뒤를 맡겨야 하기 때문에 자연스럽게 치열하게 토론해야하는 것이다.
개발자에게 치열한 토론이란 숙명이며 그렇기 때문에 면접을 볼 때 꼬리물기하면서 질문을 하는 것이라고 생각이 들었다.&lt;/p&gt;
&lt;p&gt;나는 상대방의 의견을 무한수용하는 개발자가 아닌 허점을 잘 발견해 낼 수 있는 개발자가 되고 싶다. 너무 사소한 꼬투리가 아니라, 동료가 놓친부분이나 놓칠수 있을만한 것들을 바로잡고, 그 이유를 타당하게 설명함으로서 내 동료가 나를 믿고 시스템개발을 맡길 수 있도록 성장하고 싶다.&lt;/p&gt;
&lt;p&gt;나는 내 동료가 나를 믿고 뒤를 맡길 수 있는, 그래서 함께일하는데 신뢰를 줄 수 있는 개발자가 되고 싶어졌다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-08 Today I Learn]]></title><description><![CDATA[모두의 머릿속에 같은 그림을 만들기 오늘은 ERD를 최종적으로 마무리하고, API…]]></description><link>https://mitoconcrete.github.io/23_02_08/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_08/</guid><pubDate>Wed, 08 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;모두의 머릿속에 같은 그림을 만들기&lt;/h2&gt;
&lt;p&gt;오늘은 ERD를 최종적으로 마무리하고, API문서를 작성해야했다.
그 전에 튜터님께서 주신 피드백들 중 우리가 해결가능한 것부터 차근차근 해결해나갓다.
먼저 명확하지 않은 기능이 있어서, 해당기능에 대해서 토론하여 합의를 보았다.
우리가 정의했지만, 제대로 이야기 나누지 못했던 동시줄서기 기능과 평균줄서기 계산 알고리즘의 적용여부까지 사소한 것부터 중요한 핵심로직까지 모든팀원들이 끊임없이 토론했다.&lt;/p&gt;
&lt;p&gt;어제 나와 의견이 달랐던 팀원도, 끊임없이 내 의견에 의문을가져주고, 나또한 모든 팀원들의 의견을 보수적으로 들어주면서 정말 필요하고 이득이 되는 의견을 반영할 수 있도록 노력했다. 토론은 길어지지만, 어제 만들었던 투표시스템과 잘 콜라보레이션되어서, 빠른 의사결정이 이루어졌고, 그에따라 API명세를 시작할 수 있었다.&lt;/p&gt;
&lt;p&gt;토론이라는 시스템이 부담스러운 면은 많다고 느껴지지만, 항상 토론을 하면할수록 나의 사고가 넒어지는 기분이 들고, 팀워크가 맞아가는 기분이 든다.
나중에 api문서를 작성할때 느꼈는데, 별말하지 않아도 척척 api문서를 작성하시는 팀원들의 모습을 보며, 이 서비스에 대해 모두 같은 생각을 하는 게 맞구나 하는 깨달음을 얻었다.&lt;/p&gt;
&lt;p&gt;점점의사소통 속도도 빨라지고, 불필요한 커뮤니케이션이 사라지고 있다.
슬슬 코드작성을 시작해야하는데,얼마나 시너지를 낼 수 있을지 기대가 되긴한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-07 Today I Learn]]></title><description><![CDATA[함께 기획해나가는 과정 ERD…]]></description><link>https://mitoconcrete.github.io/23_02_07/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_07/</guid><pubDate>Tue, 07 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;함께 기획해나가는 과정&lt;/h2&gt;
&lt;p&gt;ERD를 설계해나가면서, 우리의 서비스에 대해서 지속적으로 얘기를 나눌 수 있었다.
또한, 끊임없는 토론을 통해서, 머릿속에 있는 실체가 없는 우리의 서비스기능에 대해 비슷한 그림을 맞춰갈 수 있었다.&lt;/p&gt;
&lt;p&gt;그 과정에서 다른 팀원분과 문제를 해결해 나가는 방식의 차이가 발생해서, 서로 오랫동안 실랑이를 하는 일이 있었다.
이미지를 여러개 저장해야하는 상황에서, 계속 토론을 하던와중 다른팀원분께서 좋은 의견을 내주셨고 다른팀원 모두가 협의된 상황에서, 다른 팀원분께서 현업에서 어떻게 사용되는지 튜터님의 의견을 묻자고 제안주셨다.&lt;/p&gt;
&lt;p&gt;나는 비슷한 문제에 대해서, 팀원들과 합의를 보면 된다는 입장이었고, 팀원분은 비슷한 문제가 발생하면 정답을 짚고 넘어가려고 하는게 스타일의 차이었다.
하지만, 해야할 것이 너무 많고, 이런 상황에서 튜터님의 의견을 일일히 묻고 정답을 얻는 것이 많은 브레이크를 걸 수 있기 때문에, 앞으로 우리끼리 합의를 볼 수 있는 것에 대해서는 합의를 보고 넘겼으면 좋겠다고 말씀드렸다. 반대로 팀원분은 정확하지 않은 것에 대해서는 짚고 넘어가는것이 더 도움이 되지 않냐고 의견을 주셨고, 둘의 입장이 틀리지 않고, 명확한 답이 없기 때문에 계속 토론이 이어졌다. 그리고, 점심시간이 되면서 토론은 흐지부지 끝나게 되었다.&lt;/p&gt;
&lt;p&gt;나는 우리가 갈등을 겪은 원인에 대해서 곰곰히 생각해보고, 상대와 나의 성향차이임을 깨닫고 팀원분께 나의 의견을 강요했음을 사과드렸다. 하지만, 이런일이 있으면 당시 상황에 적절한 솔루션이 튜터님이 될 수도 있고, 팀원끼리의 합의일 수도 있기 때문에 이런 상황에서는 솔루션이 있어야할 것 같다고 말씀드렸다.
고민하고 토론해본 결과, 모두의 의견이 틀린것이 없어 긴 토론이 이어질 경우, 토론을 통해 2가지의견으로 최대한 좁혀보고, &apos;투표&apos;라는 기능을 이용해 과반수 이상의 표를 가진 의견을 인정하고 받아들이는 그라운드룰을 넣기로 했다.&lt;/p&gt;
&lt;p&gt;해당 룰이 적용된 이후, 설전이 일어날만한 상황들을 유쾌하고, 빠르게 넘길 수 있어서 좋았다.
어제 이후로 계속 ERD를 설계해보고 있는데, 팀원들이 한땀한땀 이유있는 엔티티와 관계를 작성함으로서, 견고한 설계구조가 만들어지는 것 같아서, 어떤 서비스가 나올지 기대가 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-06 Today I Learn]]></title><description><![CDATA[최종프로젝트 시작 다들 목표로 하는 도메인과 기능들이 다를테니 프로젝트 아이템을 선정하기에 앞서, 팀원들과의 대화를 통해 니즈를 파악했다.
정말 다양한 이야기들을 통해 다양한 주제가 나왔는데, 총…]]></description><link>https://mitoconcrete.github.io/23_02_06/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_06/</guid><pubDate>Mon, 06 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;최종프로젝트 시작&lt;/h2&gt;
&lt;p&gt;다들 목표로 하는 도메인과 기능들이 다를테니 프로젝트 아이템을 선정하기에 앞서, 팀원들과의 대화를 통해 니즈를 파악했다.
정말 다양한 이야기들을 통해 다양한 주제가 나왔는데, 총 3가지의 아이템이 선정 되었다.
그리고 프로젝트의 니즈가 다음과 같이 정리되었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;대용량 트래픽을 적용하기에 설득력이 있을것 : 억지로 트래픽이 발생할 상황을 끼어넣지말자.&lt;/li&gt;
&lt;li&gt;외부 API 를 연동 할 수 있어야한다.&lt;/li&gt;
&lt;li&gt;프론트 리소스가 많지 않을 것&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각자가 원하는 기능과 솔루션에 따라 이야기를 나누어 보았고, 적절한 트래픽이 발생 할 수 있으며, 외부API를 끌어올 가능성이 있고, 프론트 리소스가 작지만 많은 것을 시도해 볼 수 있는 &apos;예약 대기 서비스&apos;를 구현해보기로 하였다.
쿠폰과 같은 API를 이용해 트래픽을 경험해볼 수 있도록 하고, 지도 API나 OAuth와 같은 기능을 통해 외부 API를 사용해 볼 수 있으며, 기반이 된 서비스인 &apos;테이블링&apos;을 찾고로 해보았을 때 크게 많은 화면이 필요하지 않겠다는 생각을 했다.&lt;/p&gt;
&lt;p&gt;따라서, 우리는 예약대기 서비스를 이용하기로 했다.&lt;/p&gt;
&lt;h2&gt;기능 결정하기&lt;/h2&gt;
&lt;p&gt;주제를 정했으니, 이제 세부기능을 정해야하는데 문제가 발생했다.
각자가 중요로하는 서비스의 핵심이 다 다르고, 그에 따라 각자가 상상하는 서비스의 모습이 모두 달랐던 것이다. 굉장히 심플한 서비스로 오해하고 계신 분도 계셨고, 주제를 선정하기 위해 굉장히 많은 아이디어들이 오갔는데, 실제 선정된 아이디어가 아닌, 유사한 다른 아이디어로 착각하신 분도 계셨다. 일단 모든 팀원들이 혼란을 겪고 있는 상태에서, 각자가 서비스를 한다고 했을 때 떠올랐던 이미지가 무엇인지 말해보자고 제안드렸다.
각자의 니즈가 달라서 그 니즈에 따라 서비스가 정해진 것 같았다.
따라서, 위에서 선정한 기준을 제시하며, 예약 대기 서비스를 해야하는 이유에 대해서 말씀드렸고, &apos;우리가 개발할 것은 예약대기 서비스야&apos;라는 것이 머릿속에 모두 잡히니, 필요기능들에 대해서는 술술 나왔다.&lt;/p&gt;
&lt;h2&gt;ERD결정하기&lt;/h2&gt;
&lt;p&gt;오래 걸릴 줄 알았는데, 생각보다 더 오래걸렸다. 또, 각자가 생각하는 Entity와 그 연관관계에 대한 기준이 다르다보니, 많은 이야기가 오갈 수 있었다.
대신 앱개발이후에 발생될 수 있는 문제점들을 다른 사람들의 시선으로 찾아서 미연에 방지할 수 있도록 하는데 의견이 다른 부분이 많았고, 주요 핵심 컴포넌트를 구성하고, 빠르게 구성해야하다보니, 본의아니게 다른 팀원 분 들께 푸시를 한 것 같아서 너무 죄송했다
그래도 대략적인 엔티티의 구조를 완성할 수 있었다. 하지만, 연관관계나 몇몇기능들에 대한 완성이 미흡해서 내일 진행하기로 했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-1st Weekly I Learn]]></title><description><![CDATA[FACT-O1. 처음으로 학습할 때 버거움을 느꼈다. FEELINGS JPA 심화를 학습하는데, 처음으로 학습의 벽을 느꼈다. 거의 영화보듯이, 영상만 보고 있는 나의 모습을 볼 수 있었다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/23_02_1st/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_1st/</guid><pubDate>Sat, 04 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 처음으로 학습할 때 버거움을 느꼈다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JPA 심화를 학습하는데, 처음으로 학습의 벽을 느꼈다.&lt;/li&gt;
&lt;li&gt;거의 영화보듯이, 영상만 보고 있는 나의 모습을 볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 자료와 모든 정보들을 언제나 한번에 소화하는 것은 어렵다는 것을 배울 수 있었다.&lt;/li&gt;
&lt;li&gt;또한, 내가 소화할 수 있도록 학습방식을 빠르게 바꾸는 것, 그리고 내가 소화할 수 있는 것과 그렇지 않은 것들을 구분해내는것이 학습효율에 좋다는 점을 깨달을 수 있었다.&lt;/li&gt;
&lt;li&gt;이해되지 않는 부분들을 팀원들과 소통하면서, 조금은 이해할 수 있는 시간을 가질 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지금부터는 모르는 것들 천지일텐데, 내가 소화 할 수 있는 범위로 업무의 스코프를 줄이는 것과, 모르는 것에 대해 능동적으로 소통하면서 실력을 키워나가는 것이 중요하겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;어떻게든 해내려는 의지가 있다면, 해낼 수 있다는 자신감을 가져야겠다는 다짐을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 알고리즘을 꾸준히 풀었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문제 안에서 해결점을 찾고, 그에따른 솔루션을 찾는 과정이 점차 빨라지고 있는 것이 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N의 범위를 알고, 그에 맞는 솔루션을 도출해내는 것이 얼마나 중요한 것인지 깨달았다.&lt;/li&gt;
&lt;li&gt;N의 범위를 계산하고 나니 어떻게 문제를 풀어나가야 할지 고민하는 선택지가 줄어들고, 그에 따른 효율적인 방법을 선택할 수 있게되는 점이 좋다고 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아직 엣지케이스를 찾아내는 힘이 부족해서 질문하기 탭을 통해서 계속 정답을 찾게 되는데, 최대한 스스로 고민해보며 알고리즘역량을 키울 수 있도록 노력해야겠다는 다짐을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-03 Today I Learn]]></title><description><![CDATA[1. 알고리즘 문제를 풀 때 N…]]></description><link>https://mitoconcrete.github.io/23_02_03/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_03/</guid><pubDate>Fri, 03 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 알고리즘 문제를 풀 때 N의 범위를 고려해보다.&lt;/h2&gt;
&lt;p&gt;오늘 아침 푼 문제는 &lt;a href=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/138476&quot;&gt;귤 고르기&lt;/a&gt;문제 였다.
문제를 이해하는 시간을 가졌다. 문제를 모두 이해한 뒤, 그에 맞는 풀이법을 고안했다.
처음 떠올린 풀이법은 &lt;strong&gt;조합&lt;/strong&gt; 이었다. 하지만, 문제의 조건으로 주어진 K의범위가 천만이었기 때문에, 만일 K가 천만인 케이스가 있다면, 이중 반복문을 이용하게 된다면, 시간초과가 반드시 날 것 이라고 판단했다.
역시나, 조합을 구하는 과정에서 시간초과가 지속적으로 발생하는 것을 발생 할 수 있었고, 그에따라 해답을 바꿔야했다.
조합을 이용하지 않고, 이중 반복문을 사용하지 않으며 이문제를 풀 수 있는 방법에 대해서 계속 고민했다. 그순간, &lt;em&gt;Greedy알고리즘&lt;/em&gt;이 생각났다. 최대한 적은 종류의 귤을 이용해 최대한 많이 담아야하기 때문에, 종류를 카테고리화 시키고, 그것을 많을 순으로 정렬하여 담게되면 정답을 도출 할 수 있게 될 것이라고 생각했다.&lt;/p&gt;
&lt;p&gt;그 생각에 맞는 식을 세우고, 도출해냈다!&lt;/p&gt;
&lt;p&gt;이번 시간을 통해 배운 사항은 &lt;code class=&quot;language-text&quot;&gt;K를 범위를 보기시작하면 시간초과를 바라보는 시선이 달라진다.&lt;/code&gt; 이다. 이것은 사용해야할 알고리즘의 종류를 줄여주고, 시간초과 오류를 방지할 수 있게된다. 그에따라, 빠르고 효율적인 알고리즘작성이 가능해진다!&lt;/p&gt;
&lt;h2&gt;2. 우당탕탕 JPA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;save를 수행했는데, Insert Select 쿼리가 날라가는 이유는?&lt;br&gt;
ID값이 존재하는 엔티티를 업데이트 하려고 할 때, 업데이트할 필드가 있는지 select 쿼리를 먼저날려서 조회한다. 만일 수정요청를 보냈지만, 변경사항이 아무것도 없다면 JPA는 쿼리를 날리지 않는다.&lt;/li&gt;
&lt;li&gt;@SpringBootTest : Spring 통합테스트&lt;/li&gt;
&lt;li&gt;@DataJpaTest : JPA슬라이스 테스트&lt;/li&gt;
&lt;li&gt;단위테스트는 PR시 검증하는 용도(CI)&lt;/li&gt;
&lt;li&gt;통합테스트는 정기배포 당일 해당 브랜치에 대해 검증하고, 검증이 완료되면 자동배포되는 프로세스에서 사용한다.(CD)&lt;/li&gt;
&lt;li&gt;트랜젝션 Propagation option을 통해 전파여부를 설정할 수 있다.
REQUIRES_NEW 는 부모트랜젝션과 구분되는 새로운 트랜젝션을 생성하는 것이다.
MANDATORY 는 부모 트랜젝션이 없으면, 에러를 발생시켜 무조건 트랜젝션에 참여하도록 강제한다.&lt;/li&gt;
&lt;li&gt;non-transacional 은 커밋에 실패했을 경우 롤백여부와 관련있다.&lt;/li&gt;
&lt;li&gt;TRANSACTION 고립&lt;br&gt;
READ UNCOMMITTED : 커밋되지 않은 레코드 조회가능
READ COMMITTED : 커밋된 레코드 조회가능
REPETABLE READ : 트랜젝션 시작전 마지막으로 커밋된 레코드 조회가능
SERIALIZABLE : 트렌젝션 진입 이후 타 트렌젝션을 막음.&lt;/li&gt;
&lt;li&gt;rollback - UNCHECKED Exception, ERROR 에서만 발생한다.
이유는 한 흐름에서 회복이 절대 불가능한 상황이기 때문이다.
흐름의 회복이 가능한 상황에서는 Checked Exception을 이용해 핸들링하여, 요청을 회복해주어야한다.&lt;/li&gt;
&lt;li&gt;N+1 엔티티 하나를 조회하기 위해 연관관계 엔티티또한 모두 조회하는 현상
1(대상엔티티) + N(연관관계에 있는 엔티티)
global fetch strategy - 엔티티생성시(컴파일시점)에 결정하는 전략
fetch join
entityGraph&lt;/li&gt;
&lt;li&gt;Spring Data JPA에서 적용하려는 메소드 위에 @EntityGraph 어노테이션을 달고 옵션을 준다&lt;/li&gt;
&lt;li&gt;attributePaths는 같이 조회할 연관 엔티티명을 적으면 된다.&lt;/li&gt;
&lt;li&gt;, (콤마)를 통하여 여러개를 줄 수도 있다
type은 EntityGraphType.LOAD, EntityGraphType.FETCH 2가지가 있다&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LOAD : attributePaths에 정의한 엔티티들은 EAGER, 나머지는 글로벌 패치 전략에 따라 패치한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일단 attributePaths 는 EAGER, 나머지는 매핑 설정 따라서&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FETCH : attributePaths에 정의한 엔티티들은 EAGER, 나머지는 LAZY로 패치한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나빼고 다 LAZY!!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@SpringBootApplication이 구동되면서, 그 안에서 인식하도록 셋팅되어있는 의존성들이 bean으로 주입된다.&lt;/li&gt;
&lt;li&gt;delete 와 remove의 차이는 CRUDRepository에 속해있는 delete는 non-transactional하고, remove는 JPAREpository에 속해있기 떄문에 transactional하다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;고립레벨에 따른 트랜젝션 읽기 이슈들..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dirty Read : 다른곳에서 쿼리를 날렸을 때, 커밋되지 않은 정보를 다른트랜젝션에서 볼 수 있는것 L0에서 발생&lt;/li&gt;
&lt;li&gt;Unchecked Read : (??) L1에서 발생&lt;/li&gt;
&lt;li&gt;Panthom Read : 아직 커밋하지 않은 데이터를, 레벨이 낮은 트랜젝션이 조회해가는것. L1에서 발생&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-02 Today I Learn]]></title><description><![CDATA[1. Auditing 없이 Audit을 구현해보기 - createdby, modifiedby auditing은 스프링이 엔티티의 상태를 감시(audit…]]></description><link>https://mitoconcrete.github.io/23_02_02/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_02/</guid><pubDate>Thu, 02 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. Auditing 없이 Audit을 구현해보기 - createdby, modifiedby&lt;/h2&gt;
&lt;p&gt;auditing은 스프링이 엔티티의 상태를 감시(audit)하는 것인데, 주로 엔티티의 생성일자와 수정일자를 감시하여 엔티티 생성/수정 시점을 기록하는 timestamped기능을 구현할 때 사용한다. 엔티티의 상태는 &lt;code class=&quot;language-text&quot;&gt;@PostConstruct&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;@PrePersist&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;@PreUpdate&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;@PreDelete&lt;/code&gt; 등을 통해 엔티티의 생성직전, 영속상태직전, 업데이트직전, 삭제직전을 제어할 수 있다. 이를통해 createdby, modifiedby를 구현가능한데, 본래는 AuditorAware이라는 것을 이용해 getCurrentAuditor을 구현하여, 이곳에서 return되는 유저의 principal을 createdby, modifiedby에 넣어주는 방식이라고 한다.&lt;/p&gt;
&lt;p&gt;시큐리티에서 제공하는 ContextHolder가 있어서 이걸통해 쉽게 Principal를 저장할 수 있지만, 굳이 이 기능구현을 위해 스프링시큐리티를 의존성주입하고 싶지않았다.
대신 HttpRequestSevlet 생성 시 Spring에서 static하게 생성해주는 RequestContextHolder를 이용해보기로 했다.
처음에는 RequestContextHolder가 HttpRequestSevlet과 비슷한 놈이라고 생각해서 계속 헤더에 username을 key값으로 하는 value를 셋팅해주려고 했는데, 잘 되지 않았다. 따라서, setAttribute를 이용해 RequestContextHolder를 사용하기로 했다.&lt;/p&gt;
&lt;p&gt;이 한줄을 통해 나는 전역에서 HttpRequestSevlet에 넣어진 attribute를 가져올 수 있게 되었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentUserName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;HttpServletRequest&lt;/span&gt; request &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ServletRequestAttributes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;RequestContextHolder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;currentRequestAttributes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getRequest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그럼 이걸 어떻게 이용하면 좋을까? 이제 엔티티에서도 해당 컨텍스트에 접근이 가능해지니, @PrePersist 시에 해당 컨텍스트에서 username을 가져와 넣어주고, @PreUpdate 시에도 해당컨텍스트에서 username에 가져와 넣어주면된다.&lt;/p&gt;
&lt;p&gt;아래와 같이 우선 내가만든 UserStamped라는 MappedSuperClass를 상속받은 Message 클래스를 만들어주고,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserStamped&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래와 같이 해당 엔티티안에 라이프사이클어노테이션을 이용해, 적재적소에 상속받은 클래스의 메소드를 사용할 수 있도록 만들어준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;token annotation punctuation&quot;&gt;@PrePersist&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PrePersist&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;updateCreatedBy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;updateModifiedBy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token annotation punctuation&quot;&gt;@PreUpdate&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PreUpdate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;updateModifiedBy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게되면 엔티티의 생성/수정 시점에 contextholder안에 있는 username을 가져와, createdby, modifiedby에 넣어준다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그럼 테스트는 어떻게 해야할까?&lt;/strong&gt;&lt;br&gt;
내 어플리케이션에는 엔티티와 레파지토리만 있는 상태였는데, 나는 굳이 이 기능을 테스트하기위해 컨트롤러와 서비스를 만들고 싶지않았다.
따라서, 테스트에서 가상의 request를 생성해서, 거기에서 값을꺼내와 contextholder에 넣어주면 되지 않을까..? 라고 생각했다.&lt;/p&gt;
&lt;p&gt;하지만, HttpRequestServlet은 또 인터페이스라 구현할 수가 없었는데, 좀 찾아보니 HttpRequestServlet을 구현한 MockHttpRequestServlet 이라는 것이 있었고, 이것을 이용해서 가상의 request를 생성한 뒤 여기에 값을 넣어주고, 그것을 RequestContextHolder로 전달하는 방법이 있었다.&lt;/p&gt;
&lt;p&gt;아래와 같이 구현했고, 성공적으로 db에 해당값들이 저장되는 것도 확인되었다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;    &lt;span class=&quot;token class-name&quot;&gt;MockHttpServletRequest&lt;/span&gt; request &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MockHttpServletRequest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 가상의 request생성&lt;/span&gt;
    request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; createUsername&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// attribute할당&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;RequestContextHolder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setRequestAttributes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletRequestAttributes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// context에 값 할당&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 우당탕탕 JPA 심화&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;@DynamicInsert, @DynamicUpdate 를 통해 null column은 제외하고 쿼리를 날릴 수 있다. 이를 통해 쿼리최적화가 가능해진다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Projection&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select * 은 많은 리소스를 소모한다. 따라서 조회를 원하는 필드만 선언해서 조회를 해줘야한다.&lt;/li&gt;
&lt;li&gt;get필드 메소드로 정의 - 원하는 필드만 조회가 가능해서 closed projection이라고 한다.&lt;/li&gt;
&lt;li&gt;@Value로 정의. 전체 필드를 조회하고 그다음 원하는 필드를 조회하는방식이다. 전체필드를 한번은 조회하기 때문에 open projection이라고한다. 이후 spring expression language를 이용하여 원하는 필드를 호출한다.&lt;/li&gt;
&lt;li&gt;인터페이스, 클래스, 다이나믹 프로젝션이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;quertbyexample - 예시객체를 만들어 그걸 조건절로 이용하는것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;repository에 QueryByExampleExecutor를 추가해준다.&lt;/li&gt;
&lt;li&gt;withIgnorePaths 를 통해 원하는 필드 이외에 다른 필드의 조회를 방지할 수 있다.&lt;/li&gt;
&lt;li&gt;example을 잘 넣어주면 where 절을 이용해 조회가 가능해진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-02-01 Today I Learn]]></title><description><![CDATA[1. n을 고려하여 알고리즘 짜보기 기존에는 case로 주어지는 n의 범위를 고려하지 않고, 알고리즘을 풀었는데 n의 범위 고려하여 로직의 시간복잡도가…]]></description><link>https://mitoconcrete.github.io/23_02_01/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_02_01/</guid><pubDate>Wed, 01 Feb 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. n을 고려하여 알고리즘 짜보기&lt;/h2&gt;
&lt;p&gt;기존에는 case로 주어지는 n의 범위를 고려하지 않고, 알고리즘을 풀었는데 n의 범위 고려하여 로직의 시간복잡도가 1억연산횟수를 넘지 않게 해야한다는 조언을 들었다.
적용해볼 일이 많지 않아서, 사실 아무생각없이 코드를 짜다가 오늘나온 문제가 이런 상황을 고려해야했다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://school.programmers.co.kr/learn/courses/30/lessons/87390&quot;&gt;문제 링크&lt;/a&gt; 에 들어가보면 n 의 범위가 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;1 &amp;lt; n &amp;lt; 10^7&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.68354em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.5782em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8141079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 이라고 적혀있는데, 이말인 즉슨 이중for 문을 사용하는 즉시 연산 수가 1억이 넘어가는 케이스가 발생한다느 것이다.&lt;/p&gt;
&lt;p&gt;하지만, 이 문제의 경우 2차원 배열을 사용해야하는 문제였고, 처음 마주했을 때는 막막했지만 문제를 계속 보다보니, 특정한 규칙이 보였다.
2가지의 규칙을 발견할 수 있었는데, 1번째는 해당 값이 x,y 좌표라고 쳤을 때 x, y값중 큰값의 + 1 이 셋팅된다는 것이었다.
또한 2번째는 일차원 배열 인덱스로 x, y의 값을 곧바로 구할 수 있다는 것인데, x의 경우에는 n 이상을 채워야 row가 바뀔 수 있기 때문에 i/n이고, y의 경우 계속 같은 인덱스를 반복하기 때문에 i % n 로 값을 구할 수 있다.&lt;/p&gt;
&lt;p&gt;즉, 이렇게 되면 이중 반복문을 거치지 않고 곧바로 값을 구할 수가 있는 것이다.&lt;/p&gt;
&lt;p&gt;여태껏 n의 범위를 생각하지 않아도 문제가 풀렸었지만, 앞으로는 n의 범위를 고려하며 문제를 풀 수 있도록 노력해야겠다는 생각을 했다.&lt;/p&gt;
&lt;h2&gt;2. 우당탕탕 JPA 심화&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스프링 데이터 : 스프링을 위한 다양한 데이터 저장소 연동 및 최적화 패키지&lt;/li&gt;
&lt;li&gt;스프링데이터 jpa는 스프링 데이터의 한 종류이다.&lt;/li&gt;
&lt;li&gt;스프링 데이터 common에 Respository + CrudRepository(save, exist, count, delete) + PagingAndSortingRepository 가 있고, 이것들을 영속성을 관리하는 기능들을 가진 JpaRepository가 상속받아 SimpleJapRepository를 생성해준다.&lt;/li&gt;
&lt;li&gt;JpaRepsotory는 Bean이 아니다. 그러면 어떻게 Bean으로 등록되는걸까?&lt;br&gt;
@SpringBootApplication을통해 @EnableJpaRepository가 등록되고, 이것은 JpaRepository에 엔티티와 엔티티아이디의 타입을 넘겨주면 자동으로 SimpleJpaRepository를 Bean으로 등록해준다.&lt;/li&gt;
&lt;li&gt;@RepositoryDefinition을 이용하여, 사용해야할 메서드를 제한 할 수 있다.&lt;br&gt;
이걸 주입하면, JpaRepository를 implement해줄 필요없음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@NoRepositoryBean을 이용해 인터페이스를 구현한 뒤, 그것을 상속받아도 똑같이 제한가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;        |  application transaction   DB transaction   |&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;서비스 -&gt; (persist) -&gt; 1차캐시 -&gt; (flush) -&gt; DB Transaction -&gt; (commit) -&gt; DB&lt;/p&gt;
&lt;p&gt;롤백은 어플리케이션단과 DB단 모두에서 발생할 수 있고, 롤백이 어디에서 발생하느냐에 따라 분류가 아예다르다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-31 Today I Learn]]></title><description><![CDATA[1. 지속적인 배포를 해보자 어제 하지 못하고 넘겼던, CD를 직접해보았다.
CD는 다음과 같이 진행했다. S3 생성 코드를 저장 할 저장소를 생성해줘야한다. EC2 에서 S3 FullAccess 허용 및 EC2 태그 설정 CodeDeploy 시 S…]]></description><link>https://mitoconcrete.github.io/23_01_31/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_31/</guid><pubDate>Tue, 31 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 지속적인 배포를 해보자&lt;/h2&gt;
&lt;p&gt;어제 하지 못하고 넘겼던, CD를 직접해보았다.
CD는 다음과 같이 진행했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;S3 생성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드를 저장 할 저장소를 생성해줘야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EC2 에서 S3 FullAccess 허용 및 EC2 태그 설정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CodeDeploy 시 S3에서 코드를 가져오기 때문에 허용해줘야함.&lt;/li&gt;
&lt;li&gt;CodeDeploy 시 대상 EC2를 태그를 이용해 찾아오기 때문에 태그를 설정해줘야함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CodeDeploy 권한 생성 및 Codedeploy 어플리케이션 추가&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CodeDeploy 전용 권한을 생성 한 뒤, Codydeploy어플리케이션을 추가하여 역할을 부여함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EC2에 CodeDeploy Agent install 및 2번에서 설정한 태그를 이용해 Codydeploy 어플리케이션 측에서 EC2 - CodeDeploy 연결&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github actions 에서 사용할 사용자를 생성하고 IAM을 할당&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S3에 파일을 업로드하고, Codedeploy를 실행시켜 파일배포작업을 수행하도록 큐를 줘야하기 때문에, S3 FullAccess와 Codedeploy FullAccess IAM 을 생성한다.&lt;/li&gt;
&lt;li&gt;github actions 에 셋팅할 사용자를 만들고, 위에서 만든 IAM을 할당한다. 또한 github actions에 등록할 수 있도록 ACCESS&lt;em&gt;KEY, SECRET&lt;/em&gt;KEY를 발급받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Codedeploy 시 사용할 appspec.yml 작성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Codedeploy는 파일의 appspec.yml 을 읽고 그에 따라 코드를 배포를 해준다. 따라서, 이곳에는 파일을 배포할 위치나 권한등의 정보를 넣어 작성해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EC2에서 실행시킬 start.sh와 stop.sh를 작성한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;appspec.yml 에 해당 스크립트의 위치와 경로가 적혀있으며, 기존에 사용하던 서버를 끄고 -&gt; 다시 빌드하여 시작할 수 있도록 셋팅한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.github/workflow 재작성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이전과 모든 과정을 거치고, &lt;code class=&quot;language-text&quot;&gt;aws deploy&lt;/code&gt;를 run 하여, s3에 코드를 업로드하고, codedeploy를 실핼 할 수 있도록 스크립트를 재작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;중간에 github actions가 동작하지 않는 이슈가 있었다. 해당 이슈는 스크립트를 아예 덮어쓰면서 발생했는데, 기존 스크립트에 한줄한줄 추가하면서 해결했다. 하지만, 아직 정확한 원인을 밝혀내지 못해서 github actions 메커니즘 공부할 겸 원인을 알아보려고 한다.&lt;/p&gt;
&lt;h2&gt;2. 심화 JPA&lt;/h2&gt;
&lt;p&gt;JPA 는 영속성이라는 기능을 통해RDB를 객체지향적으로 사용할 수 있게 만들어준 라이브러리이다.
JPA 이전에는 DB를 어떻게 다뤘을까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JDBC&lt;/code&gt;의 등장&lt;/li&gt;
&lt;li&gt;JAVA와 DB간의 연결을 관리하기 위해서 나온 기능이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JDBC Driver Manager&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;Connect&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;Statement&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;ResultSet&lt;/code&gt; 이라는 것을 순차적으로 호출하여 쿼리를 수행하고 그 결과를 반환하도록 설계했다.&lt;/li&gt;
&lt;li&gt;일일히 모든 단계를 열고 닫아줘야하기 때문에, 번거로움이 발생했다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;QueryMapper&lt;/code&gt;의 등장&lt;/li&gt;
&lt;li&gt;JDBC를 사용하면 중복로직을 계속적으로 작성해야한다거나, open과 close 등의 트랜젝션 라이프사이클을 일일히 관리해줘야하기 때문에 번거로운 상황들이 많이 발생했다. 따라서, 영속성이라는 상태를 부여하여, 위의 번거로운 과정을 대신해줄수 있는 &lt;code class=&quot;language-text&quot;&gt;QueryMappe&lt;/code&gt;r가 등장하였다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JDBC Template&lt;/code&gt; 는 Connection, Statement, ResultSet 반복적 처리 대신 해주고, &lt;code class=&quot;language-text&quot;&gt;RowMapper&lt;/code&gt;를 이용하여, ResultSet을 VO에 손쉽게 맵핑해서 사용가능 하도록 만들어주었다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Mybatis&lt;/code&gt; 는 SQL과 Mapper을 따로 작성하여 관리할 수 있도록 해주고, 미리 작성한 sql문을 mapper에 설정된 interface와 연결함으로서, 쿼리의 결과를 손쉽게 받아올 수 있도록하였다. 하지만, sql를 직접작성하는 것은 번거로운 일이기 때문에, 대처방안이 필요했다.&lt;/li&gt;
&lt;li&gt;ORM의 등장&lt;/li&gt;
&lt;li&gt;ORM은 객체를 하나의 테이블과 연관지음으로서, 어플리케이션에서 DB를 신경쓰지 않고 객체지향적으로 사용할 수 있도록 도와주었다. 이는 객체지향이 갖고있는 디자인패턴등을 활용하여, DB를 사용할 수 있게됨을 의미한다.&lt;/li&gt;
&lt;li&gt;하지만, DB와 객체의 관계는 동일한 모양이 아니기 때문에, 상속문제, 관계문제, 밀도문제, 식별성문제등 해결할 문제들이 있었고, 이를 잘 해결해 나감으로서 ORM은 DB을 하나의 객체와 연결짓는 것이 가능해졌다.&lt;/li&gt;
&lt;li&gt;이것이 가능해짐으로서, 1차캐시와 2차캐시와 같이 객체지향의 캐싱기능을 이용하여, 쿼리를 최적화 시킬 수 있었다.&lt;/li&gt;
&lt;li&gt;flush는 DB에 쿼리문을 날리는 것을 의미하며, 이 전까지는 1차캐시에서 쓰기 지연을 통해 쿼리를 최적화시킨다. 즉, 같은 테이블에 비슷한 요청이 들어오거나 합칠 수 있는 로직들은 flush이전에 영속성컨택스트에서 최적화하여 DB 발송한다는 것이다. 즉, 여러번 날릴 쿼리를 하나로 합쳐서 보낸다는것이다. (PK생성전략이 IDENTITY인 경우 제외)&lt;/li&gt;
&lt;li&gt;flush이전도 데이터 조회가 가능한데, 그이유는 1차캐시에서 가져오기 때문이다. 하지만, 이것은 실제로 DB 반영된 데이터가 아니기에 적절한 사용이 필요하다.&lt;/li&gt;
&lt;li&gt;기타 알게된 정보들&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Enumerated&lt;/code&gt; 는 String으로 사용한다. 이유는 &lt;code class=&quot;language-text&quot;&gt;ORDINARY&lt;/code&gt;로 사용하게 되면 나중에 ID값이 바뀔경우 사이드이펙트가 커진다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Cascade&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;orphanRemoval&lt;/code&gt; 는 영속성을 전파하기위한 용도로 쓰이며, 부모엔티티에 쓰인다. (DB는 자식에 쓴다.)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Cascade.REMOVE&lt;/code&gt;은 부모에서 자식을 삭제할 경우 자식엔티티를 제거하지않는다. 이유는, 관계의 삭제가 엔티티의 제거와 동일한 개념이 아니기 때문이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;orphanRemoval&lt;/code&gt; 은 위에서 발생한 고아 엔티티를 삭제할 수 있도록 설정해주기 위한 셋팅이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Cascade.ALL + orphanRemoval=ture&lt;/code&gt; 의 조합은 자식과 부모의 라이프사이클을 동일하게 만들어주는 조합이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;EAGER&lt;/code&gt; 은 부모엔티티가 조회되면 자식엔티티의 실제객체도 받아오는 설정이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;LAZY&lt;/code&gt;는 부모엔티티가 조회되면 자신엔티티를 받아오지 않고, 나중에 필요한 시점에 조회하는 설정이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본타입은 LAZY로 두되, 필요한 곳에 fetch join을 이용하여, 실제객체를 가져올 수 있도록 셋팅해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-30 Today I Learn]]></title><description><![CDATA[220130 : CI/CD를 해보자 CI(Continuous Integration…]]></description><link>https://mitoconcrete.github.io/23_01_30/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_30/</guid><pubDate>Mon, 30 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;220130 : CI/CD를 해보자&lt;/h2&gt;
&lt;p&gt;CI(Continuous Integration) 는 지속적인 통합이라는 뜻이다. 말이 좀 와닿지가 않는데, 개발자들이 안전이 보장된 환경에서 개발을 할 수 있도록 테스트와 빌드를 지속적으로 테스트하여 코드의 품질을 체크하는 일이다.&lt;/p&gt;
&lt;p&gt;CD(Continuous Deployment) 는 지속적인 배포라는 뜻으로, 코드가 자동으로 원격서버로 배포되어 구동되도록 만드는 것이다. 배포가 되는 코드는 품질검증이 끝난 코드여야하기 때문에, 보통은 CI와 함께 진행한다.&lt;/p&gt;
&lt;p&gt;github는 actions라는 CI 환경을 제공한다. 나는 작은 프로젝트를 만들어서 PR시 해당 코드의 검증을 자동으로 할 수 있도록 설정해두었는데, 지속적으로 test 시 오류가 나는 에러상황이 발생했다. actions를 선택하고, gradle java환경을 선택하게되면 .github이라는 파일을 자동으로 생성해주는데, 이 파일에 적혀진 내용대로 내부적으로 테스트를 하는 것 같았다. 하지만, 이 테스트 환경에서 gradlew 경로를 잘 잡지 못해서 test를 돌리지 못했고, 그에따라 파일이 빌드도 되지않는 불상사가 일어났다.&lt;/p&gt;
&lt;p&gt;처음에는 직접 gradlew 의 경로를 셋팅해주었는데, 테스트환경의 내부가 어떻게 구성되어있을지 몰라서, 상대경로로 작성했다. 하지만, 이걸 잘 인식하지 못하는 것 같았다. 따라서, .github의 경로가 있는 곳으로 모든 어플리케이션파일들을 이동시켰더니, 잘 동작하기 시작했다. 내부적인 경로를 잘 셋팅해줘야함을 깨달았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-5th Weekly I Learn]]></title><description><![CDATA[FACT-O1. 다른 팀원들과 기술적인 토론을 나누면서 지식을 나누었다. FEELINGS 처음엔 토론을 통한 공부가 효율적이지 못하다고 생각했다. 내가 모르는 것을 함께 공부하는 동료와 주고받는게 제자리 걸음이지 않을까 생각했다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/23_01_5th/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_5th/</guid><pubDate>Sun, 29 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 다른 팀원들과 기술적인 토론을 나누면서 지식을 나누었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음엔 토론을 통한 공부가 효율적이지 못하다고 생각했다.&lt;/li&gt;
&lt;li&gt;내가 모르는 것을 함께 공부하는 동료와 주고받는게 제자리 걸음이지 않을까 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서로 질문을 주고받으면서, 모르는 것이 명확해지는 경험을 할 수 있었다.&lt;/li&gt;
&lt;li&gt;상호간 교류를 통해, 선의의 경쟁구도로 정보가 점점 수정되면서 오정보 -&gt; 정확한 정보로 수정되어 나가는 것이 보여졌고 서로가 옳음을 증명하기 위해 공부해나가는 경쟁구도가 매우 효율적이라는 것이 느껴졌다.&lt;/li&gt;
&lt;li&gt;혼자 해결하는 것 보다 빠른속도로 문제를 개선하고 해결해냈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동료들과 되려 질문을 주고받으면서 얻는게 많았어서, 적극적으로 토론의 장을 열어봐야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;그동안, 스스로 너무 폐쇄적이었다는 생각을 했고, 튜터님들을 비롯해 동료들에게 내가 궁금한 것과 탐구하고 싶은 것들을 오픈하며 함께 성장할 수 있는 발판을 마련해야겠다고 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 질문들에 대답하지 못하는 순간들이 생겼다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팩트가 아닌, 뇌피셜로 대답을 했고, 증명을 통해 내가 아는 게 전부가 아니란 사실이 드러난 순간 굉장히 민망했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;뇌피셜이 들어가면서, 논리가 흔들리기 시작하는 것을 느꼈고, 스스로 CS지식이 매우 부족하다는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;논리적이지 못한 답변은 상대방에게끔 의문이 생기도록 하였고, 결국 금방해결할 수 있는 문제를 길게 끌어가는 상황들이 생김을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모르는 것은 모른다고 확실히 말할 수 있는 용기를 낼것이다.&lt;/li&gt;
&lt;li&gt;모르는 것은 함께 공부해나가며 주먹구구식 추론 공부법이 아닌 빈틈없이 성장할 수 있는 빽빽한 공부법을 실행할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-27 Today I Learn]]></title><description><![CDATA[220127 : AUTOINCREMENT가 ROLLBACK이 되지 않는이유 오늘 같이 공부하시는 분과 이야기를 하다가, 만약, IDENTITY전략을 사용하는 repository가 save 이후 롤백이 되었을 경우, PK…]]></description><link>https://mitoconcrete.github.io/23_01_27/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_27/</guid><pubDate>Fri, 27 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;220127 : AUTOINCREMENT가 ROLLBACK이 되지 않는이유&lt;/h2&gt;
&lt;p&gt;오늘 같이 공부하시는 분과 이야기를 하다가, 만약, IDENTITY전략을 사용하는 repository가 save 이후 롤백이 되었을 경우, PK가 증가할것인가? 증가하지 않을 것인가에 대한 토론을 했다.
동료는 증가할것이라고 생각하셨고, 나는 증가하지 않을거라고 추측했다.
나의 주장에 대한 근거는 다음과 같았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;트랜잭션을 롤백하는 주체가 영속성 컨택스트이다.&lt;/li&gt;
&lt;li&gt;AUTOINCREMENT가 증가하는 시점은 트랜젝션이 DB에 도달하는 시점이다.&lt;/li&gt;
&lt;li&gt;영속성 컨택스트 단에서 롤백을 하면, 트랜젝션은 아예 flush를 하지않기 때문에 PK는 증가하지 않을 것이다.&lt;/li&gt;
&lt;li&gt;또한, 롤백이기 때문에 증가해도 AUTOINCREMENT값이 되돌아 올 것이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;의도적으로 회원가입하는 로직에서 롤백을 하도록 설정해놓았고, 결과를 살펴보았다.
결과는 의도와 다르게 동작했다. 롤백된 트랜젝션이 DB에 영향을 주어, AUTOINCREMENT가 증가하고 있었기 때문이다. 해당 이슈의 원인을 살펴보기 위해 리서치를 해보았다. 위처럼 동작하는 이유는 아래와 같았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;영속성 컨택스트에서 엔티티가 관리되기 위해서는 고유의 PK가 필요하다.&lt;/li&gt;
&lt;li&gt;내가 사용하는 ID생성전략은 DB에 ID생성권한을 위임하는 IDENTITY전략이다. 따라서, save이후 플러시 전까지 해당 엔티티가 영속성 컨택스트에서 관리되어야하는데 그러기 위해서는 PK를 받아와야한다.&lt;/li&gt;
&lt;li&gt;따라서, DB에 INSERT쿼리문을 날려서 PK를 받아와 할당해준다. 이후, 롤백 시 아직 transaction을 커밋하지 않아 db에 해당 entity는 flush되지 않지만, 이미 AUTOINCREMENT는 증가한 상태라 다시 되돌아오지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;만일 ID를 직접할당해주는 전략을 사용하게되면, INSERT문을 날리는 타이밍이 트랜젝션 커밋이후가 되기 때문에, AUTOINCREMENT가 증가하지 않는 결과를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;몰랐던 상황을 스터디하면서, 깨달을 수 있어서 좋았다.
또한, 오늘 테스트코드 작성 및 프론트엔드 셋팅등을 동료들과 하면서, 처음알게 된 사실이 생겼다. 이에 따라, 교류를 통해 성장하는게 이런것이구나 하는 유의미한 교훈을 얻을 수 있었다.&lt;/p&gt;
&lt;p&gt;사람들이 잘한다 잘한다 해주시니, 정말 내가 뭔가를 잘하고 있구나 생각하고 있었는데, 다른 분들과 교류하면서 굉장히 우물 안 개구리였음을 요새들어 더 많이 느끼는 중이다. 초반에도 되새겼지만, 항상 겸손한 자세로 상대에 대한 리스펙을 유지하며 대화하는 예의를 갖춰야겠다고 다시금 다짐하게 되었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-26 Today I Learn]]></title><description><![CDATA[회고 220126 : 토론을 통해 함께 문제 해결하기 오늘 테스트 코드를 작성 중 로그인관련 로직을 작성하는데, JWTUtil…]]></description><link>https://mitoconcrete.github.io/23_01_26/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_26/</guid><pubDate>Thu, 26 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220126 : 토론을 통해 함께 문제 해결하기&lt;/h2&gt;
&lt;p&gt;오늘 테스트 코드를 작성 중 로그인관련 로직을 작성하는데, JWTUtil에 값을 초기화하기 위해 적어놓은 &lt;code class=&quot;language-text&quot;&gt;@PostConstruct&lt;/code&gt; 메서드가 실행이 되지않아 테스트가 실행되지 않는 일이 발생했다. 해당 이슈가 나에게만 생긴것이 아니라, 거의 대부분의 사람들이 겪었기 때문에 많은 사람들이 모여서 해당이슈를 해결하기 위해 토론했다.
해당이슈가 발생하는 원인부터 시작해서 다른 팀원분들이 자신의 화면을 공유하며, 디버거를 동작시키며 트랙킹하는 모습도 보았다. 토론에서 영감을 받아 &apos;junit spy postconstruct not working&apos; 과 같은 키워드를 검색해본결과, junit에서는 postconstrct 로 선언된 메서드가 동작하지않기때문에, @BeforeEach와 같은 테스트 어노테이션을 이용하여 수동으로 초기화 시켜주고 &lt;code class=&quot;language-text&quot;&gt;@Value&lt;/code&gt; 로 선언한 어노테이션의 경우에도 런타임시 받아와지지 않아 Mock 에 Relflection 을 이용하여 강제로 주입시켜줘야 한다는 솔루션이 있었다. 많은 사람들이 굉장히 많이 돌아갔지만, 결국엔 문제를 해결할 수 있었고, 많은 사람들이 성취감을 느낄 수 있었다는게 신기한 경험이었다.&lt;/p&gt;
&lt;p&gt;또한, 기존 로직에서 JWT를 사용하지만 UserRepository를 거치는 로직에 관하여 다른조 팀원분들과 이야기를 나누는 시간을 가졌다. JWT를 사용하지만 결국 DB에서 유저정보를 가져오기 때문에, 세션방식과 비슷해지는것이 아닌가 하는 의문을 다른조 팀원분이 가지고 계셨고, 그 이유에 몇몇 팀원분들이 납득하시면서 이야기꽃이 펼쳐졌다.
이야기를 하면서 쿠키-세션방식에 대한 복습도 할 수 있었고, JWT를 사용할 때와 쿠키-세션방식을 할 때 각각의 장단점이 무엇일지 의문을 가질 수도 있었다. 더 나아가, 기존 JWT로직을 협의가 된 의도에 맞는 로직으로 개선할 수 있었다.&lt;/p&gt;
&lt;p&gt;많은 사람들과 모여, 이렇게 진지하게 개발에 대해 이야기를 나눌 수 있는 환경이 있어서 너무 행복했고, 커뮤니케이션을 통해 나뿐만 아니라 다른 사람들도 함께 생각이 확장되는것이 느껴져서 좋았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-25 Today I Learn]]></title><description><![CDATA[회고 22012…]]></description><link>https://mitoconcrete.github.io/23_01_25/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_25/</guid><pubDate>Wed, 25 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220125 : 프로젝트 회고&lt;/h2&gt;
&lt;p&gt;최종프로젝트 직전 마지막프로젝트가 어느새 마무리되었다. 일주일이라는 짧은 시간동안, 많은 것들을 배웠고 이를 회고하고자 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;기술적으로 배운 것
코드로 소통하는 직업이지만, 코드작업 이전 설계를 꼼꼼히 하는 것이 얼마나 중요한지 이번에야말로 깨달았다. 프론트를 고려했다고 생각하고 API를 작성했지만, 직접 프론트를 붙히고 작업을 하면서 굉장히 많은 수정을 거쳤다. RESTful 하다고 생각했지만, 때에 따라서 RESTful한 api를 포기하고 서비스에 맞게 작업해야하는 경우도 있다는 것을 느꼈다.
또한, CORS를 잡으면서 해당 이슈의 정확한 원인과 발생메커니즘에 대해서 이해할 수 있었다. 앞으로 면접때 유사한 질문이 나온다면, &apos;서버에서 내는 에러입니다.&apos;라는 바보같은 대답은 하지 않을 수 있게되었다.
추가적으로, DTO를 이용한 계층간 분리가 의존성을 낮춰준다는 점이, 이전 프로젝트보다 더 많은 데이터를 주고받으면서 확실해진 것 같다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;얻어낸 소프트 스킬
비교를 하는 것은 좋은 것은 아니지만..주변 조를 보면, 추가구현기능을 구현하기 위해 &quot;잘&quot;하는 팀원이 해당스킬을 앞서서 구현하는 상황들이 있다. 나도 사람인지라, 그런모습을 보면 사실상 마음이 조급해지고 욕심이 나는 것은 사실이다. 해당 기술이 몇시간만 주어지면 구현가능한 기능일 때는 브랜치를 따로 따서 해볼까 하는 생각도 들고 그런다. 하지만, 저번도 그렇고 이번에도 나는 팀원모두가 이번 프로젝트를 통해 하나라도 얻어갈 수 있는 방법을 선택했다. 추가 기능 구현이 가능한 시간을, 코드리뷰에 써서 모두가 컨벤션을 잘지키며 프로젝트를 작성할 수 있게돕고, 나의 고민을 공유하고, 다른팀원들과 함께 고민하는 시간에 투자를 했다.&lt;/p&gt;
&lt;p&gt;이런 방법들은 모두가 자신이 어떤것을 하고있는지 느낄 수 있도록 만들었고, 모두들 자신의 한계를 뛰어넘고 성장했기 때문에 분위기는 항상 좋게 유지되었던 것 같다. 팀원들의 사기가 높고, 좋은채로 프로젝트가 유지되는 것은 나에게 정말 기분 좋다. 처음엔 더디지만, 조금의 한계를 넘고나면, 해당 팀원들은 스스로 앞서서 나가려고 했던 것 같다. 그것이 개인마다 차이가 있지만, 해당 한계를 넘고 자신이 스스로 뭔가를 하고 있다는 것을 깨닫게 되면 개발속도나 분위기가 엄청 좋아졌다.&lt;/p&gt;
&lt;p&gt;많은 사람들이 다른 기준을 가지고 있었지만, 프로젝트 기반의 내배캠을 처음 지원하면서 마음먹었던 것이 딱하나 있다. &quot;같이가려고 노력하자&quot; 맨 첫 조에서 API가 뭔지도 모르는 조원들에게 API를 쫘라락 나열하여 벙찌게 한 상황이 아직도 선명하게 떠오른다. 그 때, &apos;아차&apos;했던 충격 덕분에, 프로젝트를 진행하다 욕심이 나면 마음을 다잡곤 한다. 그러다보니, 팀을 모두에 속도에 맞게 조율해나가며 앞으로 나갈 수 있게 하는 방법을 깨닫게 되었다. 아직은, 감사하게도 많은 대원분들이 나를 믿고 의지해주시지만, 오히려 많은 팀원분들 덕분에 나도 성장하게 되었다. 그래서 감사하다.&lt;/p&gt;
&lt;p&gt;챌린지 팀에 들어가면 조금은 빠른 대원분들과 함께 할 텐데, 어떤 일들이 있을지 기대가 된다. 이를 통해 얻는 교훈들이 분명히 있을거라고 생각한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-4th Weekly I Learn]]></title><description><![CDATA[FACT-O1. 프로젝트에서 코드리뷰를 적용해보았다. FEELINGS 거의 대부분을 혼자서 리뷰하다보니, 시간이 많이 소요되었다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/23_01_4th/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_4th/</guid><pubDate>Sat, 21 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 프로젝트에서 코드리뷰를 적용해보았다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;거의 대부분을 혼자서 리뷰하다보니, 시간이 많이 소요되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음에는 나혼자 리뷰를 하면서 힘들었지만, 팀원들이 직접 컨플릭트도 잡고 상호간 리뷰도 진행하면서 프로젝트 전체의 흐름을 파악하는 것을 발견할 수 있었다.&lt;/li&gt;
&lt;li&gt;점차 코드컨벤션이 획일화 되면서 프로젝트 코드가 조금은 일관성있는 규칙을 가질 수 있게되었다.&lt;/li&gt;
&lt;li&gt;같은 기능을 구현하는데 있어서, 생각의 차이가 조금씩 있다는 것을 느낄 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 코드의 일관성을 유지하는 장점이 있기 때문에, 팀원들이 의미없는 승인을 하지 못하도록 추후에 규칙을 좀 빡세게 선정하더라도 코드리뷰는 진행해보려고한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 프론트를 붙히기로 했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 4~5시간이면 하겠지 하고, 안일하게 생각되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기능에 맞는 템플릿을 찾고, 프로젝트에 적절한 형태를 선택하는데 시간이 오래소요되었다.&lt;/li&gt;
&lt;li&gt;기능별 로직을 구현하고, 서버와 연결하는 과정이 굉장히 쉽지 않은 작업이라는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;프론트를 붙히는 과정에서 API의 결함등을 찾을 수 있었고, API 문서를 자주 수정하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프론트와 협업하는 API를 만들 수 있도록, 조금은 요구사항 위주가 아니라 만약 화면이 연결되었다면? 이라는 가정을 들어서, 디테일하게 API를 짤 것이다.&lt;/li&gt;
&lt;li&gt;내가 생각한 것 만큼 손이 빠르지 않기 때문에, 어떤 것을 제안 할 때는 맥시멈 예상 시간 기준으로, 현실적으로 생각해보아야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-20 Today I Learn]]></title><description><![CDATA[회고 220120 : CORS? CORS! 프론트 작업을 시작하다보니, 이후 서버연결 시 CORS(Cross Origin Resource Sharing) 문제가 발생했다. 스프링에서 allow origin…]]></description><link>https://mitoconcrete.github.io/23_01_20/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_20/</guid><pubDate>Fri, 20 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220120 : CORS? CORS!&lt;/h2&gt;
&lt;p&gt;프론트 작업을 시작하다보니, 이후 서버연결 시 CORS(Cross Origin Resource Sharing) 문제가 발생했다. 스프링에서 allow origin 설정을 해주었는데도, 잘 동작하지 않아서 근본적인 문제를 해결하기 위해 CORS에 대해 간략히 공부해보았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SOP(Same Origin Policy)&lt;/strong&gt;&lt;br&gt;
최신 브라우저는 같은 Origin 에서만 리소스를 교환할 수 있다는 원칙이 있다. 따라서, &lt;a href=&quot;http://localhost:8000&quot;&gt;http://localhost:8000&lt;/a&gt; 의 사이트에서 작업중이라면 &lt;a href=&quot;http://localhost:8000%EC%9D%98&quot;&gt;http://localhost:8000의&lt;/a&gt; 주소를 가진 리소스에서만 정보를 가져다 쓸 수 있다. 이는 XSS(Cross Site Scripting), CSRF(Cross Site Request Forgery)와 같은 보안공격이 다른 리소스에서 요청을 주고받는 것이 허용됨에 따라 무분별하게 일어나기 때문에 브라우저에서 지원하게 되었다.&lt;/p&gt;
&lt;p&gt;하지만, 현실적으로 하나의 웹사이트에서 하나의 Origin만 사용되는데는 무리가 있다. 따라서, CORS정책을 통해 보안성을 유지하며, 다른 출처를 가진 곳에서도 리소스를 공유하도록 허용했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CORS 에러는 어디서 발생되는 것인가?&lt;/strong&gt;&lt;br&gt;
CORS 에러는 브라우저에서 발생한다. 그럼 우리가 서버에 설정하는 것은 무엇인가..? 라는 질문을 할 수 있다. 첫 의문과 두번째 의문은 CORS의 메커니즘을 알게되면 왜 CORS 에러를 브라우저가 내고, 내가 왜 서버에다 무언가를 설정해야 그 문제가 해결되는지 이해할 수 있다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CORS 의 메커니즘&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트는 서버에게 Preflight (OPTION)를 보내어 내가 어떤 메서드(GET,POST,DELETE,PUT..) 를 이용해 요청을 하려고하는지 미리 알린다.&lt;/li&gt;
&lt;li&gt;서버는 자신이 허용하는 메소드를 클라이언트에 전달하고, 또한, 자신이 허용하는 Origin에 대한 정보도 함께 보내준다.&lt;/li&gt;
&lt;li&gt;클라이언트는 Preflight에 대한 응답을 통해 서버가 어떤 메서드를 허용하고 있고, 자신이 해당 서버에 요청할 권한이 있는지 확인한다.&lt;/li&gt;
&lt;li&gt;이 때, 서버가 허용하는 Origin과 클라이언트의 Origin이 다를 때 해당 클라이언트가 브라우저라면, 브라우저는 자동적으로 CORS에러를 발생시켜 Preflight다음 발생하는 본요청을 취소시켜버린다. 이로인해 브라우저는 보여지기에 위험한 요소를 보여주지 않고 보안을 유지 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;서로가 아는상태인 것만 아는 상태에서 정보를 주고받도록 하는게 해당 규칙의 원칙이기 때문에, 서버에서는 클라이언트의 주소를 허용하여 Preflight요청시 &apos;나 너가 아는 놈이야&apos; 라는 시그널을 브라우저로 보내 CORS에러를 방지시키는 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Postman은 왜 CORS가 발생을 안함..?&lt;/strong&gt;&lt;br&gt;
브라우저가 아닌 서버-서버간의 요청주고받기는 CORS를 굳이 신경쓰지 않아도된다. Postman은 브라우저가 아니기 때문에, CORS를 우회 할 수 있는 것 이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CORS를 해결하는 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;프록시 서버&lt;br&gt;
서버와 서버간의 통신은 CORS를 발생시키지 않는다는 것을 이용한 기술이다. 이것은 개인적으로 생각했을 때, 꼼수같다는 느낌을 많이 받았다. 브라우저에서는 조금의 불편함이 있더라도, 신뢰하는 정보만을 보여줘야하기 때문에, 우회하는 기술을 사용하는 것은 개인적으로 선호하지 않는다.&lt;/li&gt;
&lt;li&gt;서버에 ACCESS-ORIGIN 허용&lt;br&gt;
각 서버 프레임워크는 허용할 클라이언트의 주소들을 설정할 수 있는 셋팅들이 있다. 따라서, 서버에 이런 설정을 하여 브라우저에게 신뢰를 맺고 데이터를 전달할 수 있다. 서버또한 자신의 리소스에 접근할 클라이언트를 정의할 수 있기 때문에 상호간 보안이 유지되는 방법이라고 생각한다. 개인적으로는 이 방법을 선호한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스프링에서 CORS 해결하기&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@CrossOrigin&lt;/code&gt;&lt;br&gt;
특정 컨트롤러 메소드의 위에 붙혀서 허용할 Origin 을 정할 수 있다. 이는 매번 모든 컨트롤러에 origin 을 설정해줘야한다는 단점이있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;WebMvcConfigurer&lt;/code&gt;&lt;br&gt;
main 함수에서 &lt;code class=&quot;language-text&quot;&gt;WebMvcConfigurer&lt;/code&gt;를 impl한 Configure을 이용하여 아래와 같이 사용이 가능하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;   &lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebConfig&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebMvcConfigurer&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addCorsMappings&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;CorsRegistry&lt;/span&gt; registry&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       registry&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addMapping&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/**&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;allowedOrigins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://localhost:8080&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;allowedMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HttpMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Spring Security&lt;/code&gt;&lt;br&gt;
시큐리티가 있으면, 가끔 어떤 메소드에 대해서 CORS에러를 발생시킨다. 따라서, 시큐리티 설정에 들어가서 명확하게 정의를 해주면 된다. 아래 코드가 있다면 &lt;code class=&quot;language-text&quot;&gt;WebMvcConfigurer&lt;/code&gt; 을 굳이 사용하지 않아도 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;       &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
   http&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;cors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;configurationSource&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; cors &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CorsConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
       cors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAllowedOrigins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://localhost:3000&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 이 주소에 한해 오는 요청을 허용&lt;/span&gt;
       cors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAllowedMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 모든 메소드를 허용&lt;/span&gt;
       cors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAllowedHeaders&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 모든 헤더를 혀용&lt;/span&gt;
       cors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addExposedHeader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Authorization&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// 클라이언트로 보낼 헤더를 셋팅한다. 이게 없으면 나머지는 다 가리고 Content-Type만 전송한다.&lt;/span&gt;
       &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cors&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CORS에 대해서 개념을 다시한번 쯤 잡을 필요가 있었는데, 이렇게 다잡을 수 있어서 좋았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-19 Today I Learn]]></title><description><![CDATA[회고 220119 : 성장하는 팀이 되기 Q. A보다 B의 개발 실력이 좋다고 가정해보자, B는 A가 하는말에 대해 의심하지않고 그냥 받아들인다. 그렇다면 A의 말은 모두 옮은 것 일까? 단, A와 B…]]></description><link>https://mitoconcrete.github.io/23_01_19/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_19/</guid><pubDate>Thu, 19 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220119 : 성장하는 팀이 되기&lt;/h2&gt;
&lt;p&gt;Q. A보다 B의 개발 실력이 좋다고 가정해보자, B는 A가 하는말에 대해 의심하지않고 그냥 받아들인다.&lt;br&gt;
그렇다면 A의 말은 모두 옮은 것 일까? 단, A와 B의 공부기간은 비슷하다고 가정하자.&lt;/p&gt;
&lt;p&gt;정답은 &quot;아니다&quot; 이다. 어떤 이론적인 부분에 있어서, 논란의 여지가 없는 확실한 개념은 그럴가능성이 높을 수 있다.&lt;br&gt;
하지만, 계층의 구분, 연관관계 맵핑, 코드컨벤션, DTO사용, 라이브러리 사용여부 등 개인의 신념에 따른 차이가 있는 개념에 대해선, A의 의견이 정답이 아닐 확률이 높다.
B는 자신보다 맞는 말을 하는 A에게 책임을 전가하고, 그의 의견에 동조한다. 그동안 A의 말이 대부분 맞는 것처럼 보였기 때문이다. 이 프로젝트의 완성여부는 전적으로 A의 능력에 달려있게 된다. A의 코드나 신념에 문제가 발생한다면, 어플리케이션은 그 결함때문에 와르르 무너지게 된다.&lt;/p&gt;
&lt;p&gt;이것은 좋은 팀이 아니라고 생각한다. 팀은 유기체다. 실력의 여하에 관계없이, 내가 맞다고 믿는 것을 근거를 들어 주장하는 것은 팀을 건강하게 만든다. 팀은 유기체이기 때문이다. 서로의 결점을 메워나가며 팀은 단단한 돌이 된다.&lt;/p&gt;
&lt;p&gt;단, 전제조건은 상대에 대한 존중이다. 주장의 목적이 비난이 되서는 안된다. 그렇다면 제자리를 걸을 것이다.
서로가 서로의 의견을 존중하며, 살을 붙혀나가면 나 한사람이 두명분의 생각과 의견을 가지게 되는 것 이다.&lt;/p&gt;
&lt;p&gt;이런과정을 반복해나가다 보면, 나 한사람은 여러명의 생각과 의견을 가질 수 있게되고, 다른 사람들도 마찬가지일 것이다.
이것은 곧 팀의 성장을 의미한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-18 Today I Learn]]></title><description><![CDATA[회고 22011…]]></description><link>https://mitoconcrete.github.io/23_01_18/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_18/</guid><pubDate>Wed, 18 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220118 : 컨디션이 나에게 미치는 영향&lt;/h2&gt;
&lt;p&gt;몇일 째, 밤낮이 바뀌어 잠을 잘 자지못했다. 그 결과 내 몸에 일어난 변화들이 있는데, &apos;함께 일하고 싶은 사람&apos;이 되기엔 각성하고 고쳐야 할 점 들이 많이 보여서, 항상주의 하기위해 글을 작성한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;끊임 없이 쏟아지는 졸음
졸음이 쏟아지면, 머리가 점점 굳어가는 기분이 든다. 남은 업무들이 있지만 우선순위가 잘 매겨지지 않고, 로직의 우선순위가 잘 잡히지 않는다.&lt;/li&gt;
&lt;li&gt;말을 잘 못하게 된다.
평소에도 말을 잘하는 편은 아니지만, 더 못하게 된다. 원활한 협업을 위해서는 커뮤니케이션이 필요한데, 커뮤니케이션이 귀찮아지고 잘 못하게 된다. 내 의사 전달이 되지 않아 상대방의 답답해하는 표정을 자주 볼 수 있다.&lt;/li&gt;
&lt;li&gt;예민해진다.
작은 반응에도 예민해진다. 이 특성 때문에, 상대방의 호흡에 맞추는 것에도 에너지가 많이 쓰임을 깨달았다. 예민해지다보니, 내가 상대방의 속도를 따라가지 못하거나, 상대방이 내 속도를 쫒아오지 못하면, 조급하게 행동하는 모습을 보았다. 이 조급함이 나혼자만 느껴지면 상관이 없는데, 상대방에게도 느껴지는것이 보였다. 하지만, 체력이 떨어지니 상대방을 나의 속도에 맞추는 것을 계속 추구하게 되면서, 커뮤니케이션 미스가 발생했다.&lt;/li&gt;
&lt;li&gt;억지를 부린다.
물론 그 사이에 논리가 있지만, 논리를 상대방에게 이해시키는 과정을 건너뛰고 결과만 전달하게 된다. 그러다보니, 상대방 입장에서는 &apos;왜 저렇게 말하시는거지?&apos; 라는 반응을 많이 느끼게 된다. 논리를 설명하기 귀찮아지는 것 같다..&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;전체적으로 컨디션이 떨어지면, 체력이 떨어지고, 커뮤니케이션이 힘들어지면서 발생하는 이슈들이다. 그렇다면.. 어떻게 해야 컨디션이 떨어진 상태에서도 팀원들과 원활한 소통을 할 수 있을까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내 상태를 솔직하게 밝히고 충분한 휴식을 갖는것
컨디션이 저조하다는 사실을 밝히고, 시간마다 충분한 휴식시간을 갖는다. &apos;내가 예민한 것에 대해 이해해주세요&apos; 라는 스탠스가 아닌, &apos;제가 예민해질 것 같으니, 조금만 쉬게 해주시면 원래대로 돌아오겠습니다.&apos; 라는 스탠스로 접근하여, 상대방이 나의 컨디션이 저조한 상태를 보지 않고, 신경쓰지 않도록 하는 것이 목적이 된다.&lt;/li&gt;
&lt;li&gt;불필요한 커뮤니케이션 줄이기
상대방과 실시간으로 커뮤니케이션 하는 것은, 상대방의 입장도 생각하고 내 생각도 이해시켜야하기 때문에, 굉장히 많은 체력이 요구된다. 이를 인지하고, slack이나 github pr 같은 것을 이용해 요구사항을 상대방에게 텍스트로서 전달 할 수 있도록 한다. 혹은 정해진 미팅시간을 잡고, 의사소통을 한다.&lt;/li&gt;
&lt;li&gt;그래도 커뮤니케이션이 필요하다면?
최대한 말을 줄이도록 하고, 하나하나에 신경쓰지 않도록 스스로 마인드 컨트롤이 필요하다. 말을 줄이고 핵심을 뽑아서 그에 맞는 적절한 대답을 일목요연하게 정돈하는것에 에너지를 써야한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;아직 많이 부족하지만, 커뮤니케이션의 기본은 상대에 대한 존중이라는 것을 잊지말자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-17 Today I Learn]]></title><description><![CDATA[회고 220117 : RESTful 한 URL에 대해 팀원들과 고민해보기 한번에 많은 API를 만들다보니, URL이 Restful…]]></description><link>https://mitoconcrete.github.io/23_01_17/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_17/</guid><pubDate>Tue, 17 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220117 : RESTful 한 URL에 대해 팀원들과 고민해보기&lt;/h2&gt;
&lt;p&gt;한번에 많은 API를 만들다보니, URL이 Restful하게 작업되지 못한부분들이 있어, 팀원들과 머리를 맞대고 수정하는 과정을 거쳤다.
아래는 논의했던 사항들과 도출된 항목들이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;JWT를 통해 userId를 가져올 수 있는 상황에서, 굳이 &lt;code class=&quot;language-text&quot;&gt;/users/{userId}&lt;/code&gt;과 같이 해당 리소스의 계층을 표현을 굳이 해주어야할까?&lt;/em&gt;&lt;br&gt;
해당 API는 고객이 자신의 정보를 수정, 삭제하는 기능을 가졌었다. 나 자신만이 글수정을 할 수 있어야하기 때문에 JWT토큰을 통하여 인증을 해야했다.
인증이 이뤄졌기 때문에 controller에 해당요청이 도착한 시점엔, 이미 이 요청을 보낸 사람의 정보가 &lt;code class=&quot;language-text&quot;&gt;Authorization Context&lt;/code&gt;에 넣어진 상태일 것이다.
하지만, userId 를 &lt;code class=&quot;language-text&quot;&gt;@PathVariable&lt;/code&gt;로 전달하기 때문에, 우리는 JWT토큰으로 전달한 사람의 정보가 아닌 userId로 전달 된 리소스를 수정해야한다.&lt;/p&gt;
&lt;p&gt;따라서, JWT의 정보와 userId의 정보가 일치하는지 검증하는 과정이 필요한데, 그것을 굳이 매번넣어줘야하는지가 고민사항이었다.
그럴바에 차라리 &lt;code class=&quot;language-text&quot;&gt;/users&lt;/code&gt; + JWT Token으로 조합하여 사용하는것이 더 낫지 않을까 생각했다. 하지만, 이것은 전혀 Restful하지않기 때문에 팀원들과 많이 고민했던 것 같다.&lt;/p&gt;
&lt;p&gt;합의된 결과는 &lt;strong&gt;그냥 JWT의정보와 userId 의 정보가 일치하는지 검증을 하자&lt;/strong&gt;였다. 우리팀은 Restful을 선택한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;불분명한 워딩 수정하기&lt;/em&gt;&lt;br&gt;
우리 어플리케이션의 리소스 중엔 &lt;code class=&quot;language-text&quot;&gt;sellerRequestForm&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;customerRequestForm&lt;/code&gt; 이라는 대중적이지 않은 리소스들이 있다.
&lt;code class=&quot;language-text&quot;&gt;sellerRequestForm&lt;/code&gt;은 고객이 판매자 요청을 하기 위한 정보이고, &lt;code class=&quot;language-text&quot;&gt;customerRequestForm&lt;/code&gt; 은 고객이 상품구매를 요청하는 정보이다.
일단 요구사항의 표현을 그대로 따라가긴 했는데, 현실에 없는 단어이기 때문에, 이것을 URL에 적용을 하려니깐 내가 무슨 리소스를 요청하는지 혼란이 오는 상황이 벌어졌다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/sellers/{sellerId}/customerRequestForm&lt;/code&gt; 이 무슨 기능을 하는지 명확한가..? 우리팀은 그렇지 않다고 생각하고, 머리를 맞대어 보았다.&lt;br&gt;
request, buy, waitinglist, wanted 등등 다양한 후보군이 나왔는데 최종적으로 선택된 것은 &lt;code class=&quot;language-text&quot;&gt;quotation&lt;/code&gt;이었다.&lt;br&gt;
견적서라는 의미로, &lt;code class=&quot;language-text&quot;&gt;/sellers/{sellerId}/quotations&lt;/code&gt; 를 쓰게 되면, &lt;em&gt;&apos;어떤 판매자가 받은 견적서&apos;&lt;/em&gt;들 이라는 의미로 좀더 명확해지는 것이 있었다.
나에게는 생소한 단어라서 처음엔 의아했지만, 팀원들의 의견을 들어보니 생각보다 많이 사용되는 단어같았다. 따라서, 이를 수용했다.&lt;/p&gt;
&lt;p&gt;그렇다면, &lt;code class=&quot;language-text&quot;&gt;sellerRequestForm&lt;/code&gt; 는 어떻게 표현할 수 있을까?
waitinglist, authroization-list 등등 다양한 의견이 나왔지만, 최종적으로 선택된 것은 &lt;code class=&quot;language-text&quot;&gt;waitings&lt;/code&gt; 였다. 보통 현실에서도 대기자 목록을 웨이팅이라는 단어로 쓰기 때문에, 굳이 list라는 표현을 쓰지 않아도 된다고 판단했다. 다만, 이것이 권한요청을 하는 대기열에 추가를 하는 기능이기때문에, 리소스앞에 &lt;code class=&quot;language-text&quot;&gt;auth&lt;/code&gt;라는 단어를 덧붙혀 &lt;strong&gt;권한 대기열&lt;/strong&gt; 이라는 의미로 해당 리소스를 표현하기로 했다. &lt;code class=&quot;language-text&quot;&gt;/users/{userId}/auth/waitings&lt;/code&gt; 는 어떤 유저의 권한 대기를 의미한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;기능에 대한 요청 분리하기&lt;/em&gt;
login, logout, signup 과 같은 기능들은, 유저가 지닌 기능이라기보단, 서비스가 가진 인증기능이다.&lt;br&gt;
따라서, &lt;code class=&quot;language-text&quot;&gt;/users/login&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;/users/signup&lt;/code&gt; 과 같은 표현은 적절하지 않다고 판단했다.&lt;br&gt;
서비스의 기능은 리소스 뒤에 붙혀 표현하는 것은 지양하기로 했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 외에도 많은 대화가 오가면서, 모든 팀원들의 정성이 뭍어있는 API가 생성되었다.
사실, &lt;code class=&quot;language-text&quot;&gt;이 API들이 정말 RESTful한가?&lt;/code&gt; 라는 질문이 들어온다면 &lt;code class=&quot;language-text&quot;&gt;아니오&lt;/code&gt; 라고 답변 할 수 있을 것 같다. 내부에서 사용하고 있는 리소스와 별개의 것들도 있고, URL만으로 어떤 기능을 하는지 외부인들이 추측하기 아직은 애매한 사항들이 많다고 생각하기 때문이다.
하지만, 가장 좋다고 느꼈던 점은 팀원들끼리 API를 보고, 이 API는 무슨기능을 할 것 이라는 협의가 되었다는 것 이었다. 그리고, 나름 RESTful하게 작성하려고 노력했다는 것..?&lt;/p&gt;
&lt;p&gt;모든 팀원들이 머리에 싱크를 맞추는 일이 가장 어려운 것 같다. 실제로 별것아닌것처럼 보이는사항에 시간을 쏟은거였지만, 이후 팀원분들이 불필요하게 의사소통을 하는 일이 없어지는 것을 보면서, 우리가 했던 토론들이 불필요하지 않았다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;뜻깊은 시간이었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-16 Today I Learn]]></title><description><![CDATA[회고 220116 새로운 프로젝트가 시작되었다. 프로젝트는 다행히도 0부터 100을 만드는 업무라 모든 팀원들이 합심하여 프로젝트를 진행할 수 있었다.
오늘 병원을 갈 일이 있었는데, 선생님께서 수술로 인해 외래가 딜레이가 되면서 대기를…]]></description><link>https://mitoconcrete.github.io/23_01_16/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_16/</guid><pubDate>Mon, 16 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220116&lt;/h2&gt;
&lt;p&gt;새로운 프로젝트가 시작되었다. 프로젝트는 다행히도 0부터 100을 만드는 업무라 모든 팀원들이 합심하여 프로젝트를 진행할 수 있었다.
오늘 병원을 갈 일이 있었는데, 선생님께서 수술로 인해 외래가 딜레이가 되면서 대기를 2시간넘게 하게 되었다.
그럼에 따라, 가장 중요한 기획 회의에 많은 시간 불참하게 되었다. 업친데 덮친격으로 차량시동도 꺼져서 저녁시간 이후 회의에도 불참하게 되었다.
다사다난한 일이 있었는데, 팀원들을 서로 머리를 맞대고 기획을 잘 진행하고 계셨다.
API를 조금이나마 Restful하게 작성되도록 돕고, 프로젝트 셋팅을 도왔다.
이후에 Issue를 등록하여 프로젝트를 관리하는 방법을 채택하여, 프로젝트를 셋팅하였다. 비록 우당탕탕 흘러왔지만 계획된 시간 내에 모든문제들이 잘 해결되어 다행이라고 생각했다.
팀원분들 소통도 잘되고, 참여도 잘 해주셔서 느낌이 좋다. 나는 모든 분들이 하나라도 건져가실 수 있도록 신경써야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-3rd Weekly I Learn]]></title><description><![CDATA[FACT-O1. CS강의를 복습했다. FEELINGS 막상 하려고 하니, 해야하는 것을 알면서도 귀찮았다. 암기를 해야하는 과목이다보니, 거부감이 느껴졌다. 막상, 공부하니 재미있었다. 집중력이 많이 짧아진게 느껴져 1…]]></description><link>https://mitoconcrete.github.io/23_01_3rd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_3rd/</guid><pubDate>Sat, 14 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. CS강의를 복습했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;막상 하려고 하니, 해야하는 것을 알면서도 귀찮았다.&lt;/li&gt;
&lt;li&gt;암기를 해야하는 과목이다보니, 거부감이 느껴졌다.&lt;/li&gt;
&lt;li&gt;막상, 공부하니 재미있었다. 집중력이 많이 짧아진게 느껴져 10분간격으로 쉬고, 공부하고를 반복했는데 재미가 붙을 수록 점차 시간이 늘어났다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터 기초 공부가 어떻게 생각하면 암기지만, 나름의 역할과 순서가 있기때문에 그 역할을 잘 이해하면 머리에 잘 박혔다.&lt;/li&gt;
&lt;li&gt;무지성으로 머리에 구겨 넣으려고 하기보다는, 왜이렇게 동작하는지 이해하니깐 재미가 붙고 더 잘 와닿는게 느껴졌다.&lt;/li&gt;
&lt;li&gt;그동안 그렇게 와닿지 않던 OSI7계층이 재미를 붙히니, 금방 머리에 들어왔다.&lt;/li&gt;
&lt;li&gt;또한, 학습을 통해 다운로드를 인터넷이 끊겨도 계속받을 수 있는 이유나, 세계통신이 가능한 이유 등 일상에서 궁금했던 점들이 해소되었고, 상식이 올라감을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CS공부는 필수지만, 충분히 재미있게 공부 할 수 있다고 생각한다. 귀찮아하고 기피하기 보다는 내 상식을 하나 더 늘린다는 생각으로 꾸준히 학습할 것이다. 그리고 어떤 것을 공부 할 때 흥미가 생길만한 거리를 찾아서 공부하면 집중이 잘되기에, 이런 특성을 잘 살려서 공부에 빠르게 집중하는 방법을 개발해 봐야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. TDD를 작성해보았다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음엔 테스트를 왜 작성해야하느지 이해가 잘 가질 않았다.&lt;/li&gt;
&lt;li&gt;포스트맨같은 것으로 테스트하기 귀찮은 것들을 조금 프로그래밍적으로 쉽게 만들어 주는 것이라고 오해하고 있었다.&lt;/li&gt;
&lt;li&gt;테스트를 막상 작성해보니 목적이 이해가 되었고, 우리가 타입을 맞추는 것 처럼 테스트를 이용해 어떤 틀을 맞추는 것 처럼 테스트를 사용할 필요성이 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 주도 개발은 테스트를 먼저 작성해놓고, 그 테스트를 하나하나 통과시킴으로서 앱을 설계해 나가는 방식임을 깨달았다. 잘만들어진 앱을 테스트로서 검증하는 순서라고 오해하고 있었는데, 그게 아님을 깨달았다.&lt;/li&gt;
&lt;li&gt;테스트를 작성할때 미리 내부에서 어떤것이 동작할지 정의해야한다. 즉, 비슷한 코드를 테스트하는 코드내에 또 작성을 해야한다. 따라서, 테스트는 또 하나의 앱을 작성하는 것과 같다는 것을 깨달았고, 왜 스타트업들에서 TDD를 스킵하는지 이해했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한번 써본 사람은 헤어나오지 못한다는 TDD라고 한다. 작은 단위라도 테스트를 우선적으로 작성해보면서, 익숙해질 수 있도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-13 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : SQL에서 검색을 빠르게 만들어 주는 색인과 같은 역할을 한다. 인덱스를 건 컬럼을 조회할 시, 양쪽이 균등한 BTREE…]]></description><link>https://mitoconcrete.github.io/23_01_13/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_13/</guid><pubDate>Fri, 13 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;INDEX&lt;/code&gt; : SQL에서 검색을 빠르게 만들어 주는 색인과 같은 역할을 한다. 인덱스를 건 컬럼을 조회할 시, 양쪽이 균등한 BTREE가 생성되어 검색이 빨라진다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;자동 생성 인덱스&lt;/code&gt; : 삭제가 불가하며 속성셋팅에 따라 자동으로 생성되는 인덱스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;클러스터형 인덱스&lt;/code&gt; : primary key 로 선언한 column에 자동으로 생성되는 인덱스. 데이터를 자동으로 정렬함.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;보조 인덱스&lt;/code&gt; : unique 로 선언한 column에 자동으로 생성되는 인덱스. 데이터를 자동으로 정렬하지 않음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;사용자 생성 인덱스&lt;/code&gt; : 보조인덱스에 속하며, 삭제가 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;커스텀 인덱스 생성&lt;/code&gt; :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;UNIQUE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;INDEX&lt;/span&gt; 인덱스이름 &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; 테이블_이름 &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;열_이름&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;ASC&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;인덱스 확인&lt;/code&gt; :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;INDEX&lt;/span&gt; 테이블이름&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;인덱스 적용&lt;/code&gt; :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;ANALYZE&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;TABLE&lt;/span&gt; 테이블_이름&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;인덱스 삭제&lt;/code&gt; :&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;INDEX&lt;/span&gt; 인덱스_이름 &lt;span class=&quot;token keyword&quot;&gt;ON&lt;/span&gt; 테이블_이름&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;인덱스를 효과적으로 사용하는 방법&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WHERE 절에서 사용되는 열에 인덱스를 만들어야합니다. -&gt; 쓰지않으면 공간만 차지함. 속도에 이득이 없음.&lt;/li&gt;
&lt;li&gt;데이터 변경 작업보다 SELECT 문을 훨씬 자주 쓰는 열에 인덱스를 만들어야 합니다.&lt;/li&gt;
&lt;li&gt;데이터의 중복이 높은 열은 인덱스를 만들어도 별 효과가 없습니다. -&gt; 데이터 수가 많으면 상관없지만, 50:50/30:30:40 과같은 비율이라면 인덱스를 쓰는의미가 크게 없음&lt;/li&gt;
&lt;li&gt;사용하지 않는 인덱스는 제거합니다. -&gt; 공간을 계속 차지하기 때문.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-12 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : JPA에서 DB레벨의 CASCADE를 구현하기 위해 사용되는 옵션.  : 데이터의 무결성을 위해 사용.   : on delete cascade, on update cascade 무조건 자식(many…]]></description><link>https://mitoconcrete.github.io/23_01_12/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_12/</guid><pubDate>Thu, 12 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@OnDelete(action = OnDeleteAction.CASCADE)&lt;/code&gt; : JPA에서 DB레벨의 CASCADE를 구현하기 위해 사용되는 옵션.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;SQL 제약조건&lt;/code&gt; : 데이터의 무결성을 위해 사용.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;PK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;FK&lt;/code&gt; : on delete cascade, on update cascade 무조건 자식(many)에 적어준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;unique&lt;/code&gt; : 유일 값만 입력가능&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;check&lt;/code&gt; : 뒤에 오는 조건에 해당하는 값만 입력가능&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;default&lt;/code&gt; : 기본값을 설정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; : 빈값 허용여부 결정.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;WAN&lt;/code&gt; : LAN과 LAN사이를 이어서 만든 네트워크. 통신사 중계기와 각 집들을 연결(ISP)하거나, 국가와 국가를 연결(SDN)하기도 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;계층화&lt;/code&gt; : 통신기술의 확장이 가능하게 된 원인이다. 모든 계층을 다 가지고 있지 않아도, 네트워크 장비로서 역활을 할 수 있다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;OSI 7계층&lt;/code&gt; : 국제표준기구(ISO) 에서 제안한 네트워크 표준. 현실적인 문제로 인해 5단계를 가진 TCP/IP로 사용자 지원계층을 퉁쳐서 사용하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;사용자 지원계층(5,6,7)&lt;/code&gt; :&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;7계층(응용계층)&lt;/code&gt; : HTTP, FTP, 같은 프로토콜이 존재하는 영역이다. 이때의 데이터 단위는 &lt;code class=&quot;language-text&quot;&gt;데이터&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;6계층(표현계층)&lt;/code&gt; : 받아온 이진데이터의 디코딩혹은 전송할 데이터의 인코딩을 담당하며, 압축과 암호화도 이곳에서 진행한다. 데이터 단위는 &lt;code class=&quot;language-text&quot;&gt;데이터&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;5계층(세션계층)&lt;/code&gt; : 세션을 관리하는 계층. 세션을 열고닫음을 이곳에서 결정하고, 통신방식을 여기서 결정한다. 세션복구도 가능한데, 이 기능으로 인해 다운로드 중 인터넷이 끊겨돋 이어서 받을 수 있게된다. 데이터 단위는 &lt;code class=&quot;language-text&quot;&gt;데이터&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;전송 계층(4)&lt;/code&gt; :&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;4계층(전송계층)&lt;/code&gt; : TCP/UDP등 전송할 데이터의 프로토콜을 결정한다. 하위계층(3단계/2단계)으로 신뢰있는 데이터를 전송하는 것이 목적이다. 송신 시 데이터에 프로토콜과 포트를 추가하여 세그먼트를 만들어 하위계층으로 전달한다. 수신시에는 패킷을 데이터로 변환하여 세션계층의 알맞는 포트로 데이터를 전달한다. 데이터 단위는 앞서 말했지만, &lt;code class=&quot;language-text&quot;&gt;세그먼트&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;네트워크 지원계층(1,2,3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;3계층(네트워크계층)&lt;/code&gt; : 호스트의 IP 주소를 설정하고, 이 IP주소를 이용해 서로간 통신이 가능하도록 한다. 송신 시 도착지 IP를 설정하고, 최적의 경로를 계산한다. 수신 시에는 목적지 IP를 확인하고, 자신과 일치한다면 전송계층으로 데이터를 전달하여, 다음액션을 취할 수 있도록 한다. IP가 붙어있는 이 계층에서의 데이터 단위는 &lt;code class=&quot;language-text&quot;&gt;패킷&lt;/code&gt;이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;2계층(데이터링크계층)&lt;/code&gt;: MAC주소를 이용하여, 최종 IP와 일치하는 위치를 찾을 수 있게 돕는다. 출발 MAC주소와 도착 MAC주소가 지속적으로 업데이트 되면서, 3계층으로 넘겨 도착 IP와 일치하는지 확인하여 일치하지 않으면 현재 자신의 주소를 출발 MAC주소, 가장 가까운 중계기(라우터)의 MAC주소를 도착 MAC주소로 설정하여 데이터를 지속적으로 전달한다. ARP, RARP 를 이용하여 MAC주소를 변환하고, 이 때 MAC주소가 붙은 데이터의 단위를 &lt;code class=&quot;language-text&quot;&gt;프레임&lt;/code&gt;이라고 칭한다. &lt;code class=&quot;language-text&quot;&gt;프레임&lt;/code&gt;은 헤더와 테일이 있고, 그로인해 시퀀스가 발생한다. 따라서, 없는 데이터가 있다면 재요청을 하는 등 빠진 데이터를 복구하는 과정도 이곳에서 수행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;1계층(물리계층)&lt;/code&gt; : 전기신호 &amp;#x3C;-&gt; 비트(=데이터). 수신시 전기신호를 0,1의 비트데이터로 변환하고, 송신시 비트데이터를 전기신호로 변환하여 전달한다. 데이터 단위는 &lt;code class=&quot;language-text&quot;&gt;비트&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-11 Today I Learn]]></title><description><![CDATA[회고 22011…]]></description><link>https://mitoconcrete.github.io/23_01_11/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_11/</guid><pubDate>Wed, 11 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220111&lt;/h2&gt;
&lt;p&gt;테스트를 작성하다가 계속 혼란이 왔던 부분이 있었다. 잘 작성해놓은걸 테스트하는건 로그를 이용해서 하면되는데, 굳이 이렇게 어렵게 작성하는 이유가 있을까..? 하는 의문이었다.
테스트에서 사용되는 서비스나 컨트롤러가 이미 모두 완성되어있고, 그것에 대한 기능을 테스트하는 순서로 진행되었기 때문에 계속적으로 혼란이 왔던 것이었다.
TDD는 테스트를 먼저 작성하고, 테스트에 맞게 클래스나 메소드를 완성시키는 방식이다. 따라서, 지금처럼 이미 완성을 다 하고 난 뒤, 잘 동작하는지 테스트하는 것이 아니라 빈 클래스를 이렇게 사용할 것이다~ 하고 가정하고 그 틀을 먼저 마련 한 뒤, 점차 실제 클래스를 채워나가는 방식으로 진행하는 것이다.&lt;/p&gt;
&lt;p&gt;이것은 이해가 되었지만, 아직 when에서 서비스를 굳이 사용하는 이유나, Service를 검증하는 이유가 아직은 너무 애매모호하다. 하지만, 개발 전 어떤 틀을 잡아놓고, 그것을 채워나가는 방식은 확실히 안전성이 보장된다는 깨달음은 얻긴했다. 내일은, 빈 메소드에 대한 테스트를 작성해보고, 그것을 테스트에 맞게 채워나가는 식으로 진행해봐야겠다.&lt;/p&gt;
&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;BDD(Behavior Driven Development)&lt;/code&gt; : TDD에서 파생된 개념으로서, 단위테스트 보단 어떤 행동에 대한 테스트 즉, 시나리오를 이용한 테스트를 의미한다. given-&gt;when-&gt;then의 순서가 이 개념에서 나온다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;SSL Handshake과정&lt;/code&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;서비스에서 CA인증기관에 자신의 서비스에 대한 SSL인증서를 요청하여 발급받는다. SSL인증서 안에는 CA정보, 공개키 등이 있다. (서버 -&gt; CA)&lt;/li&gt;
&lt;li&gt;유저가 브라우저를 이용해 서비스에 접속한다. 이 때, 랜덤데이터와 사용가능한 인증방식을 서버로 전송한다. (유저 -&gt; 서버)&lt;/li&gt;
&lt;li&gt;서버는 유저가 보낸 인증방식에 해당되는 SSL인증서와 함께 랜덤데이터를 유저에게 전달한다.(서버 -&gt; 유저)&lt;/li&gt;
&lt;li&gt;유저의 브라우저는 CA리스트를 보고, SSL인증서가 인증된 CA에서 작성된 인증서인지 확인하고, 인증기관에서 미리발급되어 저장된 공개키로 인증서를 복호화한다. (유저 -&gt; CA)&lt;/li&gt;
&lt;li&gt;복호화된 인증서안에 있는 공개키와 서버로 부터받은 랜덤데이터를 이용하여 임시키를 생성하여 서버에 전달한다.(유저 -&gt; 서버)&lt;/li&gt;
&lt;li&gt;서버는 전달받은 임시키를 자신이 가지고 있는 비밀키로 복호화하여, 유저를 신뢰하여 대칭키를 만들어 유저에게 보낸다.&lt;/li&gt;
&lt;li&gt;유저는 전달받은 대칭키를 이용해 이후에 통신을 주고 받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-10 Today I Learn]]></title><description><![CDATA[회고 220110: TDD 시작해보기 sql을 학습하면서 시간이 많이 남게되어, 무엇을 할지 고민하던 중 TDD라는 여태까지 피해왔던 카드를 다시꺼내보게 되었다.
번거롭다는 단점때문에 TDD…]]></description><link>https://mitoconcrete.github.io/23_01_10/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_10/</guid><pubDate>Tue, 10 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 220110: TDD 시작해보기&lt;/h2&gt;
&lt;p&gt;sql을 학습하면서 시간이 많이 남게되어, 무엇을 할지 고민하던 중 TDD라는 여태까지 피해왔던 카드를 다시꺼내보게 되었다.
번거롭다는 단점때문에 TDD를 받아들이지 못하고 있다가, 내 어플리케이션이 항상 의도대로 동작하지 않는 것을 보고, 또 스웨거에서 점점 길어지는 검증로직들을 보며 TDD의 필요성을 느끼게 되었다. 클라이언트를 통해 검증을 할 수도 있겠지만, 점점 과정이 길어질수록 로그인하고, 토큰발급받고하다보면 여간 귀찮은게 아니기 때문이다.
개발자가 본인이 작성한 코드를 코드로서 검증하는 것이 가장 빠르고 정확하다라는 판단을 했고, 따라서 TDD를 작은것부터 시작해보기했다.&lt;/p&gt;
&lt;p&gt;처음엔 아예 감도 잘 오지 않았다. 그래서 이미 TDD를 잘 적용중이신 ㅁㅅ님께 가서 도움을 청했는데, 많은 정보를 얻을 수 있었다.
TDD는 통합보단 단위테스트를 많이하며, given -&gt; when -&gt; then의 순서에서 given이 가장 중요한 파트라는 것도 이해 할 수 있었다.&lt;/p&gt;
&lt;p&gt;테스트환경은 말그대로 목업 환경에서 이뤄지기때문에, 내 의도대로 동작하지 않는게 아직 많다..
오늘은 timestamped로 작성해놓은 값에 null이 계속 할당되어, 넘어가지 못하는 상황이 있었는데, 좀 찾아보니 테스트환경은 기존 어플리케이션과 다르게 돌아가므로 테스트환경에도 EnableAudit을 해줘야한다는 사실을 알았다. 이외에도 mockmmvc를 이용해 api를 검증할 수 있는데, 아직 적용해보지 못했다.&lt;/p&gt;
&lt;p&gt;아직 손에 잡히지 않는 부분이 많은데, 얼른 익숙해져서 자신있게 TDD에 대해서 말할 수 있게 되는 수준이 되었으면 좋겠다.&lt;/p&gt;
&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;given -&gt; when -&gt; then&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;given&lt;/code&gt; : 테스트 환경에서 어떤것을 셋팅 할 지, 결정 짓는 곳. TDD에서 가장 중요한 부분.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;when&lt;/code&gt; : 어디서 해당 테스트를 실행할건지 결정하는 부분&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;then&lt;/code&gt; : when 에서 수행한 값이 실제로 원하는 결과 값을 뱉고있는지, 검증하는 부분 aasert, verify등을 이용하여, 검증한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Mock&lt;/code&gt; : 실제 빈이 아닌, 실제 빈을 클론한 목업 객체를 테스트 환경에 넣어주는것.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@InjectMocks&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;@Mock&lt;/code&gt;으로 선언된 객체에, &lt;code class=&quot;language-text&quot;&gt;@InjectMocks&lt;/code&gt;으로 선언된 목업객체를 주입함으로서 테스트 환경이 구동되도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-09 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 개발자가 구현한 코드에서 발생한 오류  : 시스템에서 발생시킨 오류  : 반드시 체크하고 넘어가야할 예외로써, try-catch 로 잡고가야한다. Runtime Exception…]]></description><link>https://mitoconcrete.github.io/23_01_09/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_09/</guid><pubDate>Mon, 09 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Exception&lt;/code&gt; : 개발자가 구현한 코드에서 발생한 오류&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Error&lt;/code&gt; : 시스템에서 발생시킨 오류&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Checked Exception&lt;/code&gt; : 반드시 체크하고 넘어가야할 예외로써, try-catch 로 잡고가야한다. Runtime Exception 이외의 모든 예외가 이곳에 속하며, 예외발생시 트랜젝션이 롤백되지 않기 때문에 반드시 잡아줘야한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Uncheked Exception&lt;/code&gt; : 굳이 체크하고 넘어가지 않아도 될 예외로써, 개발자의 실수로 인해 발생하는 경우가 많다. 예외발생 시 트랜젝션이 롤백된다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;예외처리 방식 3가지&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;예외복구&lt;/code&gt; : 예외가 발생하여도, 어플리케이션이 정상적으로 진행되도록 만드는 예외상황을 말한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;예외회피&lt;/code&gt; : 어떤 함수를 실행 중 예외가 발생하면, 함수를 호출하는 곳으로 예외를 전가시키는 방법을 의미한다. &lt;code class=&quot;language-text&quot;&gt;throws&lt;/code&gt;를 붙혀서 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;예외전환&lt;/code&gt; : 좀더 예외를 명확하게 하기위해, 다른 예외로 전환하여 뱉는 상황을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;BasicErrorController의 동작방식&lt;/code&gt; : 어떤 어플리케이션에서 오류가 생기면, WAS까지 오류상황이 전달되고, WAS는 셋팅되어 있는 페이지로 오류를 전달하여 보여주게끔 한다. 이 때 요청이 ERROR이기 때문에 필터가 구동이 되지 않으며, 위 과정에 따라 내부적으로 컨트롤러 -&gt; WAS -&gt; (에러)컨트롤러의 과정으로 동작하여, 결과적으로 컨트롤러에 2번의 요청을 하는 현상을 만든다. BasicErrorController는 오류의 헤더타입에 따라 다른결과를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ResponseStatus&lt;/code&gt; : BasicErrorController의 결과코드를 변경하여 에러를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ResponseStatusException&lt;/code&gt; : BasicErrorController의 결과코드와 cause, reason등을 수정하여 에러를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ExceptionHandler&lt;/code&gt; : 에러를 좀더 자유롭게 처리 할 수 있도록 돕는다. BasicErrorController을 반환하는 것이 아니라 WAS단까지 오류를 내릴 일도, 컨트롤러를 2번호출 할 일도 없다. ExceptionHandler에 원하는 예외의 클래스를 넣어놓고, 매개변수로 해당클래스의 예외를 전달받아 원하는 형태로 반환 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ControllerAdvice&lt;/code&gt; : 전역적으로 에러를 핸들링 할 수 있도록 돕는다. 위와 똑같이 BasicErrorController을 반환하는 것이 아니라 WAS단까지 오류를 내릴 일도, 컨트롤러를 2번호출 할 일도 없다. 전역적으로 에러를 캐치하는 컨트롤타워를 둠으로서, try-catch없이 이곳에서 에러를 처리하면 된다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;예외처리 흐름순서&lt;/code&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;예외발생&lt;/li&gt;
&lt;li&gt;ExceptionHandlerResolver가 동작하여 &lt;code class=&quot;language-text&quot;&gt;@ExceptionHandler&lt;/code&gt;가 컨트롤러에 있는지 확인하고 있으면 처리하고, 없으면 &lt;code class=&quot;language-text&quot;&gt;@ControllerAdvice&lt;/code&gt;가 있는지 확인한다. 있다면 해당되는 예외처리기가 동작하여 에러를 뱉고, 없다면 다음단계로 넘어간다.&lt;/li&gt;
&lt;li&gt;ResponseExceptionHandlerResolver가 동작하여, &lt;code class=&quot;language-text&quot;&gt;@ResponseStatus&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;@ResponseStatusException&lt;/code&gt; 여부를 판단함. 있다면, ServletResponse의 sendError()를 실행하여 서블릿으로 해당 오류를 전달하고, 이는 BasicErrorController을 호출하여 에러를 뱉도록 시킴. 이에 해당되지 않으면 다음단계로 넘어간다.&lt;/li&gt;
&lt;li&gt;DefaultHandlerExceptionResolver가 동작하여, Spring의 내부 예외인지 검사하여 맞으면 에러를 처리하고 아니면 넘어감.&lt;/li&gt;
&lt;li&gt;최종적으로 아무런 해당사항이 없다면 예외가 서블릿까지 전달되고, 서블릿은 BasicErrorController를 호출하여 예외를 처리함.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue- HTTPS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-2nd Weekly I Learn]]></title><description><![CDATA[FACT-O1. 결과물과는 별개로 좋은 팀 분위기가 유지되었다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/23_01_2nd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_2nd/</guid><pubDate>Sat, 07 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 결과물과는 별개로 좋은 팀 분위기가 유지되었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음에 다들 자신감이 죽어있는 상태로 참여해서, 사실 좋은 분위기를 기대하지 못했다.&lt;/li&gt;
&lt;li&gt;프로젝트 내내 신경이 많이 쓰였고, 입원임에도 불구하고 기력이 회복될 때 마다 프로젝트를 챙기려고 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하고자 하는 의지가 있는 분들에게, 달성가능한 미션을 조금씩 나누어 할당함에 따라, 점점 팀의 사기가 오르는 모습을 볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀의 목표가 불분명하여 막막한 상태라면, 해결 할 수있는 작은문제부터 순차적으로 해결해나가는 것이 효과적이라는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 프로그래머스 Level 1 을 모두 끝냈다.&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제 푸는과정, 그리고 고민하는 과정이 재미있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;꾸준히 풀면서, 알고리즘 기본에 대해서 항상 리마인드 할 수 있는 것을 느낄 수 있었다.&lt;/li&gt;
&lt;li&gt;문제를 푸는 것 보다, 올바르게 해석하여 올바른 식을 세우는 것이 가장 중요하다는 것을 많은 문제를 풀면서 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lv2도 꾸준히 풀면서, 빠르게 Lv3에 도달하도록 노력하겠습니다.&lt;/li&gt;
&lt;li&gt;문제를 어떻게 풀지 확실시 되는 순간 문제풀이를 시작할 것 입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-06 Today I Learn]]></title><description><![CDATA[회고 230106 : 프로젝트 회고 이번 프로젝트는 개인적인 일정으로 인해 100% 참석이 불가한 프로젝트였다. 팀원들도 그렇고, 관리해주시는 분들도 나를 프로젝트 가용인원에서 제외시켰다.
그 결과, 프로젝트 직전 2개의 조가 합쳐졌고, 팀원…]]></description><link>https://mitoconcrete.github.io/23_01_06/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_06/</guid><pubDate>Fri, 06 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 230106 : 프로젝트 회고&lt;/h2&gt;
&lt;p&gt;이번 프로젝트는 개인적인 일정으로 인해 100% 참석이 불가한 프로젝트였다. 팀원들도 그렇고, 관리해주시는 분들도 나를 프로젝트 가용인원에서 제외시켰다.
그 결과, 프로젝트 직전 2개의 조가 합쳐졌고, 팀원 9명이 다함께 프로젝트를 끌어가야하는 사태가 벌어졌다. 프로젝트를 진행하면서 어떤 어려움을 겪었고, 그것을 어떻게 해결했는지 나열해보면서 간단히 회고해보려고 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;모두의 자존감이 너무 떨어져 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제원인 : 그동안 휘몰아친 많은 강의들을 못따라가시는 분들이 늘어났고, 그에따라 많은 피해자들이 발생했는데, 이번 프로젝트 조에서는 유독 그런 분들이 많았다. 추측컨데, 진도를 못따라가는 것에 대한 답답함, 문제를 계속 해결하지 못하는 것에 대한 무력감등에서 오는 자존감 하락이 많을 것이라고 판단했다.&lt;/li&gt;
&lt;li&gt;해결 : 기존 프로젝트의 목표를 성취하는 것 보다도, 개개인이 무언가를 만들 수 있는 자신감을 올려주는 것이 우선이라고 판단했다. 따라서, 이해도 및 진행도에 따라 세그룹으로 나누어, 성취목표를 다르게 선정하고, 업무를 잘게 쪼갬으로서, 작은 것을 해결했을때 하나의 무언가를 만들 수 있도록 유도했다.&lt;/li&gt;
&lt;li&gt;결과 : 비록 목표는 이루지 못하였지만, 팀원들 개개인이 느끼는 만족도가 올라가서 리텐션을 유지할 수 있었다. 분위기가 좋아진 것이 느껴졌고, 팀의 커뮤니케이션이나 프로젝트 참여도 등이 이에 영향을 많이 주어, 좋은 분위기에서 프로젝트를 마무리 할 수 있었다.&lt;/li&gt;
&lt;li&gt;느낀점 : 속도도 중요하지만, 팀의 분위기를 좋게 유지하는 것이 팀단위 프로젝트에서는 더 중요하다고 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;소통 소통 소통&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제원인 : 조원 중 유독 소통이 안되는 팀원들이 있었다. 초반에 이 분위기는 단 한명에서 시작되었으나, 뒤로가면 갈수록 번졌다.&lt;/li&gt;
&lt;li&gt;해결 : 해결하지 못했다. 소통이 안되는 팀원들은 끝까지 소통이 되지 않았다. 다만, 해당팀원들에게 내가 필요한 상황을 만드니 소통을 조금이라도 하려는 시도들이 보였고, 대화의 시작과 끝에 대한 주도권을 내가 가져갈 수 있었다.&lt;/li&gt;
&lt;li&gt;결과 : 좋을 수 있었던 팀 분위기가 소통이 없는 몇몇 분들로 인해 다운되면서 희안한 밸런스가 유지되었다. 좋지도 나쁘지도 않은 상황이 지속되었다.&lt;/li&gt;
&lt;li&gt;느낀점 : 부정적인 기운은 빠르게 퍼진다. 이것을 뒤늦게 잡는 것은 어렵기에, 초반에 잡는 것이 중요하다. 또한, 소통의 중요성을 이해하지 못하는 사람들은 내가 구태여 이해하지 않기로했다. 이 시장에서 알아서 배척된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드 자체를 작성하지 못하는 팀원이 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제원인 : 어떤 것 부터 손을 대야하는지 모르겠다고 말씀주셨다. 어떤게 중요한지 우선순위가 판단이 되질 않아보이셨다.&lt;/li&gt;
&lt;li&gt;해결 : 각각의 역할에 대해 설명하면서 코칭했다. 또한, 한번에 하나의 테스크를 주며, 왜 이것을 사용하는지 고민해보고 이것에 대해 토론하는 시간을 가졌다.&lt;/li&gt;
&lt;li&gt;결과 : 이분은 소통이 잘 되지 않는 팀원 중 한 분이셨다. 하지만, 역할에 대해 하나씩 이해하고 하나의 흐름을 만들어보면서, 결과적으로 스프링의 흐름에 대해 이해할 수 있어서 좋았다고 피드백주셨다.&lt;/li&gt;
&lt;li&gt;느낀점 : 어떤것을 모르는지 모르는 사람들에게는 우선순위을 세우고, 길을 하나씩 만들어 주는 것이 도움된다고 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;체력적으로나 심리적으로나 많은 부담이 되었던 프로젝트였다. 결국 잘 마무리되긴했지만, 스스로도 고쳐야할 점을 발견 할 수 있었다.
또한, 새로운 유형의 사람들을 마주하면서 그런 유형의 사람들에게 상처받지 않기위해서는 어떻게 행동해야할지 생각하는 계기가 되었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-05 Today I Learn]]></title><description><![CDATA[회고 230105 : 수술 후 3일의 기간동안 한 일들 철심제거 수술 후…]]></description><link>https://mitoconcrete.github.io/23_01_05/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_05/</guid><pubDate>Thu, 05 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 230105 : 수술 후 3일의 기간동안 한 일들&lt;/h2&gt;
&lt;p&gt;철심제거 수술 후 3일 간, 입원해있으면서도 팀 프로젝트를 원활하게 이끌어가기 위해서 드문드문 방문하여 진도를 체크하고 팀원들을 도와주었다.
기력이 너무 떨어져 매 시간 붙어있진 못했는데, 그래도 뭔가 프로젝트를 통해 얻고 싶은게 있는 의지를 보이는 팀원들 덕분에 힘을 낼 수 있었다.
매일 아침 10시마다 출석하여 팀원들이 어떤 어려움을 겪고있는지, 무슨일을 할 것인지 체크하였고, 응답이 없는 팀원들에게는 따로 연락하여 진도를 체크하였다.
그리고 기력이 회복 될 쯤 한번씩 들어와 잘 진행되고 있는지 체크하며, PR에 대해 리뷰를 드리곤 하였다.&lt;/p&gt;
&lt;p&gt;이번 프로젝트의 변수는 내 기력이었던 것 같다. 가벼운 수술로 치부하고, 100% 팔로업이 가능 할 것이라고 판단했는데 생각보다 기력이 많이 죽어버렸다.
거기에 팀 프로젝트를 잘 흘러가도록 고민하는 것이 에너지를 많이 잡아먹을 것이라고 생각하지 못했는데, 여기서 뺏기는 에너지가 상당했다.
오늘 복귀했음에도 계속 머리가 아프고, 기운이 빠져서 누워있다가 팀원분들이 헬프를 외칠때만 도움을 드리곤 하였다.&lt;/p&gt;
&lt;p&gt;하지만, 팀원들의 의지,흥미만 있다면, 나의 존재없이도 프로젝트가 어떻게든 흘러가는 모습도 보았다. 반면에, 의지,흥미가 없다면 프로젝트가 계속 정체되는 모습도 보았다.
코드를 작성하는 것 없이 온전히 팀이 어떻게 흘러가는지만 고민하고, 관찰하였는데 그 시간들에서 의미있는 결과들을 얻었다.&lt;/p&gt;
&lt;p&gt;유동적으로 흘러가는 팀을 만들기 위해선 의지, 목표가 뚜렷한 팀원들이 모여야한다. 큰 목표를 기반으로 계속 작은 미션을 주면 팀원들의 성취도, 흥미가 올라간다.
서로 돕는 시스템을 만들면 관리자에 의존하지 않는 형태가 되어, 팀이 느리게나마 독립성을 가지고 앞으로 나아가는 시스템이 구축된다.
나의 기력저하가 도움(?)이 되었던것 같기도 하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2023-01-1st Weekly I Learn]]></title><description><![CDATA[FACT-O1. 이해가지 않는 것들을 이해해냈다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/23_01_1st/</link><guid isPermaLink="false">https://mitoconcrete.github.io/23_01_1st/</guid><pubDate>Sun, 01 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 이해가지 않는 것들을 이해해냈다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스프링시큐리티의 흐름이 이해가 가지 않았다.&lt;/li&gt;
&lt;li&gt;카카오 인증 로그인의 플로우가 이해가 가지 않았다.&lt;/li&gt;
&lt;li&gt;카카오 인증 이후, 로그인 폼을 보지않아도 내 정보를 불러올 수 있는 이유가 도저히 이해가 가지 않았다.&lt;/li&gt;
&lt;li&gt;AOP의 표현이 이해가 가지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;블로그글은 생각보다 정확하지 못하다. 모두 자신이 공부한 것을 다시 리마인드 하는 식으로 작성하기에, 참고만 해야한다.&lt;/li&gt;
&lt;li&gt;내 생각에 갖혀있으면, 다른 지식을 습득하기 매우 힘들다는 점을 깨달았다.&lt;/li&gt;
&lt;li&gt;백문이불여일타. 직접 적어보면서 많은 것을 실험해보면서 이해하는 것도 효과적이라는 사실을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생소한 개념을 접했을 땐, 나혼자 &apos;이 기능은 이런것이니깐 이렇게 쓸거야&apos;라는 편견을 가지고 거기에 맞추지 말고, 공신력있는 블로그나, 공식문서를 참고하여 개념을 습득하자.&lt;/li&gt;
&lt;li&gt;머릿속으로 설계만 하지말고, 직접 적어보면서 어떤 차이가 발생하는지 눈으로 보는 버릇을 들이자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 팀이 병합되었고, 팀프로젝트가 시작되었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;갑작스럽게 팀원이 9명이 되어서 당황스러웠다.&lt;/li&gt;
&lt;li&gt;그 중에 5명만 실질적으로 참가할 수 있는 상황이라는 것을 공유받아서, 막막했다.&lt;/li&gt;
&lt;li&gt;가장 느린 사람에게 맞추면 된다고 생각했지만, 너무 격차가 커서 어떻게 프로젝트가 진행될 지 가늠이 되질 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모두들 프로젝트 진행에 대한 강력한 의지가 있음을 느꼈다. 하지만, 앞으로 나가질 못하고 있음에 대한 막막함,답답함으로 인한 자존감 상실이 느껴져 안타까웠다.&lt;/li&gt;
&lt;li&gt;프로젝트를 처음부터 끝까지 쭉 훌으며 흐름을 잡아주니, 몇몇분들이 희망을 얻는 모습을 보았다.&lt;/li&gt;
&lt;li&gt;내가 ㅅㅁ튜터님의 강의를 이해하고, 호텔프로젝트를 어떻게 작업해야 할 지 길을 찾고 자신감이 상승하고 설렛던 것처럼, 길을 잘 잡아주는 것만으로도 막막해하던 상대에게 자존감 회복을 시켜줄 수 있음을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원래 개발은 혼자하는 것이라고 생각했지만, 내 생각을 공유할 수 있는 사람과 끊임 없이 얘기함을 통해 얻을 수 있는 자신감 회복도 중요하다고 생각했다.&lt;/li&gt;
&lt;li&gt;어떤 일에 진행하다 위기에 봉착했을 때, 책이되었던 사람이 되었던 내가 현재 처한문제에 대해 길을 찾을 수 있는 모든 외부적인 요인들을 받아들이는 것도 막막함을 극복하는 좋은 원동력이 됨을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-30 Today I Learn]]></title><description><![CDATA[회고 221230 : @RequestBody 의 데이터를 AOP에서 불러오기 프로젝트의 요구조건 중, Request Body로 전달되는 username 과 password의 길이,포맷에 대한 필터링을 AOP로 분리해야한다는 조건이 있었다.
AOP…]]></description><link>https://mitoconcrete.github.io/22_12_30/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_30/</guid><pubDate>Fri, 30 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221230 : @RequestBody 의 데이터를 AOP에서 불러오기&lt;/h2&gt;
&lt;p&gt;프로젝트의 요구조건 중, Request Body로 전달되는 username 과 password의 길이,포맷에 대한 필터링을 AOP로 분리해야한다는 조건이 있었다.
AOP는 일반적인 메서드와 다르게, 메인 플로우의 흐름 밖에 위치하기 때문에, 매개변수에 곧바로 접근하여 가져오는 것이 일반적인 사용법과 다르다.&lt;/p&gt;
&lt;p&gt;AOP를 적용할 클래스, 패키지를 직접 지정한 뒤, JointPoint 라는 객체를 통해 실행 할 메서드들과 그곳에 전달되는 매개변수에 접근한다.
단, 이 때 매개변수는 hashCode 로 제공되기에, .get~~와 같이 내부에 정의된 메서드를 실행시켜 내부의 값에 접근하여 가져오기가 매우 어렵다.&lt;/p&gt;
&lt;p&gt;따라서, 나는 Reflection API를 적용하여, 해당 클래스를 가져와 클래스의 메소드를 invoke함으로서 username을 가져올 수 있게 하였다. 하지만, 이 때 Reflection API를 잘못사용해서 그런지 의도대로 동작하지 않았고, 곧바로 다른 방법을 찾아보게 되었다.
내가 집중한 것은 arg로 가져오는 것의 타입이 Object라는 것, 그리고 이것이 RequestDto 라는 hashCode로 정확히 그 역할을 가져온다는 것 이었다.
물론 모든 객체의 부모가 Object이긴 하지만, 확실하게 이 object가 RequesDto라는 것을 인지하고 있네? 그렇다면 RequesDto로 형변환을 시켜주면 어떻게 될까..? 하는 추측을 했다.&lt;/p&gt;
&lt;p&gt;결과는..&lt;/p&gt;
&lt;p&gt;잘동작한다!&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;       &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; joinPoint&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getArgs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; arg &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// SignUpRequestDto&apos;s hashcode&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SignUpRequestDto&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
               &lt;span class=&quot;token class-name&quot;&gt;SignUpRequestDto&lt;/span&gt; dto &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SignUpRequestDto&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; username &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; dto&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getUsername&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; password &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; dto&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getPassword&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;username &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; password&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// work!&lt;/span&gt;
                    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 과정을 거치면서, AOP에 대한 많은 실험을 거칠 수 있었고, 이에따라 AOP가 어떤 흐름으로 진행되는지 이해하게 되었다.
항상 어떤 시행착오를 거치고 성공하면, 그전에 했던 모든실수의 원인이 기억이 나고 스스로 민망해지는 순간들이 있다.
하지만, 백문이불여일타 라고 확실히 나는 뭔가를 손으로 일단 써봐야 그다음 이해를 하는 경향이 강한 것 같다. 공식문서와도 얼른 친해져야하는데.. 걱정이다.
또, 프로젝트를 지속적으로 진행함에따라 자바에 대한 기본기, 스프링에 대한 기본기와 철학을 계속 잊어버리게 되는데, 책으로서 보충하던지 시간을내어 복습을 하던지 기본기를 잃지않도록 스스로 인지해야할 것 같다는 성찰을 했다.&lt;/p&gt;
&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-29 Today I Learn]]></title><description><![CDATA[회고 221229 : 팀 프로젝트를 하루 남긴 현재 갑작스런 반변동으로 인해서, 한 반에…]]></description><link>https://mitoconcrete.github.io/22_12_29/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_29/</guid><pubDate>Thu, 29 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221229 : 팀 프로젝트를 하루 남긴 현재&lt;/h2&gt;
&lt;p&gt;갑작스런 반변동으로 인해서, 한 반에 9명의 팀원이 있는 조가 되어버렸다.
모든 조원의 이해도가 다르고, 개인 프로젝트 진행상황이 다르기 때문에 앞으로 어떤식으로 진행될지 도저히 감이오지 않았다.
나는 우선 구글 폼을 구성하여, 각자가 어떤 상태에 놓여있는지 파악하였다. 일단, 가시적으로 모두의 상태에 보이고 어떤 것을 원하는지 눈에 들어오니 좀더 명확해졌다.&lt;/p&gt;
&lt;p&gt;실제 회사에서도 팀이 프로젝트를 리딩을 할 때, 모든 개발자가 각기 다른 이해도와 지식을 가지고 있다.
그런 상황에서 PM은 어떤식으로 조율을 해야할까? 에 대한 포커스로 고민을 해봐야겠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀원 개개인이 자신이 프로젝트에 기여하고, 자신감을 회복해야한다.&lt;/li&gt;
&lt;li&gt;모든 팀원이 흐름을 이해 할 수 있어야한다.&lt;/li&gt;
&lt;li&gt;각기가 원하는 결과를 가져가도록 유도해야한다.&lt;/li&gt;
&lt;li&gt;유의미한 결과물이 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 4가지에 포커싱을 해서 끊임없이 고민하여, 프로젝트가 잘 흘러가는데 기여하고 싶다..
화이티이!!&lt;/p&gt;
&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-28 Today I Learn]]></title><description><![CDATA[회고 221228 : Swagger Page 권한 허용하기 스프링 시큐리티를 기존 프로젝트에 적용하는 과정에서, 스웨거 문서에 접속을 시도할 때 40…]]></description><link>https://mitoconcrete.github.io/22_12_28/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_28/</guid><pubDate>Wed, 28 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221228 : Swagger Page 권한 허용하기&lt;/h2&gt;
&lt;p&gt;스프링 시큐리티를 기존 프로젝트에 적용하는 과정에서, 스웨거 문서에 접속을 시도할 때 403에러가 발생하는 이슈가 발생했다.
해당 이슈를 해결하기 위해서 시큐리티 설정 측에서 스웨거 페이지에 대한 접근을 허가했다.
하지만.. 지속적으로 에러가 발생하여 로그를 보니, 토큰을 인가하는 로직이 잘못된 부분이 있었다.
그런데, 이상한 점이 나는 분명히 permitAll 처리를 해놓았는데, 왜 시큐리티 필터 체인로직을 거치는지 이해가 가지 않았다.&lt;/p&gt;
&lt;p&gt;authenticated() 를 붙힌로직만 시큐리티 필터 체인로직을 거친다고 생각했는데, 잘못된 접근이었다.
authenticated() 를 api 에 붙히는 것과 시큐리티 필터는 별개의 것이다.
시큐리티 필터는 설정시 무조건 거쳐야 했고, authenticated()를 붙힌 api역시 시큐리티 필터를 거치되, 토큰을 검증함으로서 로그인 여부를 결정하여 결과를 반환해주는 동작을 하게 된 것이었다.&lt;/p&gt;
&lt;p&gt;로그인이 되었다면 &lt;code class=&quot;language-text&quot;&gt;SecurityContext&lt;/code&gt; 내부에 Principle이 정상적으로 셋팅되었을 것이고, 그것에 따라 로그인 여부를 판단하는 것 같다.
참고로 스웨거는 다양한 주소를 통해 페이지를 렌더링하는데, 아래는 시큐리티 설정 시 허용해야 할 스웨거 주소들의 목록이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;PERMIT_URL_ARRAY&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;/* swagger v2 */&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/v2/api-docs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/swagger-resources&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/swagger-resources/**&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/configuration/ui&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/configuration/security&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/swagger-ui.html&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/webjars/**&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;/* swagger v3 */&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/v3/api-docs/**&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token string&quot;&gt;&quot;/swagger-ui/**&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 삽질을 통해서, 시큐리티 필터체인이 어떤시점에 동작하는지 이해 할 수 있었고, 설정들을 다양하게 조합하여 어떻게 실행되는지 직접 볼 수 있었다.&lt;/p&gt;
&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;UserDetails&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;SecurityContext&lt;/code&gt; 에 담기는 User 정보를 가져오는 공간이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;hasRole vs @Secured&lt;/code&gt; : config 를 통해 설정하는 방법과, annotation을 통해 설정하는 방식의 차이이다. 둘의 기능은 같지만, &lt;code class=&quot;language-text&quot;&gt;hasRole&lt;/code&gt;은 접근권한을 config에서 한번에 관리 할 수 있고, &lt;code class=&quot;language-text&quot;&gt;@Secured&lt;/code&gt;는 controller에 직접 명시하여 관리 할 수 있다는 차이점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-27 Today I Learn]]></title><description><![CDATA[회고 221227 : 카카오 로그인은 어떻게 동작하지..? 강의 중 OAuth…]]></description><link>https://mitoconcrete.github.io/22_12_27/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_27/</guid><pubDate>Tue, 27 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221227 : 카카오 로그인은 어떻게 동작하지..?&lt;/h2&gt;
&lt;p&gt;강의 중 OAuth 개념을 배우고 적용해 본 뒤 플로우를 따라가다보니, 이해가 되질 않는 부분이 생겼다. 초기로그인 이후 다시 로그인을 시도했을 때, 카카오톡 로그인 창을 보는것이 아니라 곧바로 메인화면으로 넘어가는 현상이었다. 즉, 처음에만 카카오에게 내 정보를 넘겼는데, 다음부턴 로그인 버튼만 눌러도 자동으로 카카오는 내가 &apos;김태훈&apos;이라는 것을 인지하는 현상이었다.
이 과정이 OAuth의 플로우 중에 어떤 과정에서 일어나는지 도저히 이해되지 않았다.&lt;/p&gt;
&lt;p&gt;카카오 OAuth 의 과정을 간단히 설명하면, 로그인 버튼을 클릭하면, 카카오에서 보내준 인가코드를 내가 설정해 놓은 리다이렉트 api로 전달한다. 나는 이 인가코드를 이용해서 access&lt;em&gt;code 를 받을 수 있고, 이 access&lt;/em&gt;code에서 로그인을 시도한 사람의 정보를 가져올 수 있다.&lt;/p&gt;
&lt;p&gt;근데 첫 로그인이야.. 내가 내 이메일과 패스워드를 직접 입력했다고 치고, 그 다음부턴 어떤 일이 일어나기에, 내가 직접입력을 하지 않아도 내 정보를 카카오에서 가져올 수 있는 것일까..?&lt;/p&gt;
&lt;p&gt;몇가지 의심을 해보았다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;컴퓨터 IP의 정보를 카카오에서 들고있다.
카카오 DB에서 내 IP의 정보를 들고 있고, 따라서 내가 요청을 했을 때 나인 것을 인지 할 수 있다는 가설이었다.
하지만, 같은 컴퓨터에서 아내의 계정으로 접속해서 로그인해보았고, 아내의 정보를 잘 불러오는 것을 보았을 땐 이 가설은 절대 성립 할 수 없음을 깨달았다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;인가코드를 통해 구분을 한다..?
access_code에서는 내 정보를 뽑아오기 때문에, 뭔가 리다이렉 api 에 전달되는 인가코드가 나를 인지하는 트리거가 되지 않을까? 하는 가설을 해보았다.
나는 처음에 인가코드가 카카오 개발자에서 보낸 REST API KEY에만 종속되어있다고 생각하여, 저 키가 변하지 않는 이상 계속 같은 코드가 오지 않을까? 생각했다.
하지만, 실험을 해보니, 로그인 마다 매번 다른 인가코드가 전달되어 오고 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221227_01.png&quot; alt=&quot;1차실험&quot;&gt;
&lt;img src=&quot;/image/221227_02.png&quot; alt=&quot;2차실험&quot;&gt;&lt;/p&gt;
&lt;p&gt;그렇다는 것은 현재 이 브라우저 어딘가에, 나를 인지 할 수 있는 어떤 값이 숨어있고 그것을 리다이렉트 요청 시에 같이 보내고 있다는 것인데.. 그것이 어디있는지 추적하다보니 요청헤더에 쿠키값이 포함되어 가는 것을 발견 할 수 있었다. 하지만, 브라우저 어디에서도 이 값들이 어디에 셋팅되어 있는지 찾을 수 없었다.
그러다, zep에서 쿠키문제로 고생했던 경험이 떠올랐고, 그 때도 브라우저 어플리케이션 탭의 쿠키에서 찾을 수 없던 것들을 볼 수 있었던 경험을 되살려 동일한 방법으로 쿠키를 찾아보았다.
그랬더니..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221227_03.png&quot; alt=&quot;카카오쿠키발견&quot;&gt;&lt;/p&gt;
&lt;p&gt;드디어 발견했다. 로그인 시, 이정보들을 보내주는 것 이었다. 하지만 새로고침 시 이 정보들은 모두 사라졌는데, 쿠키의 정보는 데스크탑에 저장되는 것을 알고 있어서 찾아보니, &lt;code class=&quot;language-text&quot;&gt;~/Library/Application Support/Google/Chrome/&lt;/code&gt; 의 경로에 각각 브라우저에 대한 &lt;code class=&quot;language-text&quot;&gt;Profile&lt;/code&gt; 이 있고, 그에 따른 쿠키들이 &lt;code class=&quot;language-text&quot;&gt;Cookies&lt;/code&gt;라는 이름으로 저장되어 있었다. hex code로 변환해서 까보니, kakao에 대한 쿠키를 발견 할 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이로서 알아낸 것은 초기 로그인 시, 카카오는 브라우저에 유저를 인증 할 수 있는 쿠키를 저장하고, 로그인 시도 시 쿠키값이 있다면 함께보내주어 리다이렉트 url에 해당유저에 대한 인가코드를 전달하여 1차적으로 이 유저에 대한 권한을 인가한다는 것 이었다.&lt;/p&gt;
&lt;p&gt;위의 경험을 트래킹하는 과정에서 OAuth의 플로우를 전반적으로 살펴 볼 수 있었고, 그에따라 이전에는 계속이해가 가지않았던 플로우에 대해서 조금더 이해 할 수 있는 시간이 되어서 좋았다.&lt;/p&gt;
&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;스프링 시큐리티의 세션&lt;/code&gt; : 스프링 시큐리티는 기본적으로 쿠키-세션 방식을 지향한다. 따라서, JWT를 사용하기 위해선 이 설정을 끄고 진행해주어야한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;블랙박스 테스팅&lt;/code&gt; : 내부의 동작을 모르는 다수의 인원이 기능을 테스트 하는 것이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;개발자 테스팅&lt;/code&gt; : 개발자가 자신이 작성한 코드를 테스트 하는 것이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;TDD&lt;/code&gt; : 테스트 주도 개발은 테스트를 먼저 작성하고 개발을 진행하는 방식이다. Given(준비) -&gt; When(실행) -&gt; Then(검즘) 방식이 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Mock vs @InjectMocks&lt;/code&gt; : 실제 Service, Controller, Entity 등을 사용하면, 실제서비스에 영향이 갈 수 있기 때문에 목업 컴포넌트들을 만들 수 있다. &lt;code class=&quot;language-text&quot;&gt;@Mock&lt;/code&gt;은 컴포넌트의 복사본이고, &lt;code class=&quot;language-text&quot;&gt;@InjectMocks&lt;/code&gt;는 동일한 복사복이지만, &lt;code class=&quot;language-text&quot;&gt;@Mock&lt;/code&gt; 들이 DI된 컴포넌트이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;AOP JointPoint&lt;/code&gt; : JointPoint 는 핵심로직을 의미한다. aop는 핵심로직의 전 후에서 실행되기 때문에, 이 시점을 관리하기 위해서 jointPoint 라는 매개변수를 넘겨받아 AOP의 실행시점을 정해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;PointCut Expression&lt;/code&gt; : AOP의 어드바이스가 어느 컴포넌트에서 실행되야 할지 위치를 지정해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@PointCut&lt;/code&gt; : Expression 의 재사용 및 조합이 가능해진다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Transactional&lt;/code&gt; : AOP이다. 트랜잭션이 플러시 되거나 롤백되는것은 유저의 핵심관심사가 아니다, 이것은 백업에서 해주어야 할 서브관심사로서, AOP단계에서 동작한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Primary &amp;amp; Replica&lt;/code&gt; : 트랜젝션의 ACID원칙을 지키기 위해 DB를 읽기전용, 쓰기전용으로 나눠쓰는 방식을 말한다. &lt;code class=&quot;language-text&quot;&gt;@Transactional(readOnly=true)&lt;/code&gt; 를 쓰게되면, 읽기전용 DB로 요청이 가게 된다. 따라서, DB를 한개만 사용할 땐 readOnly를 활성화하는 것은 큰 의미가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-26 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_26/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_26/</guid><pubDate>Mon, 26 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;FilterChain&lt;/code&gt; : 스프링이 클라이언트로부터 어떤 요청을 받아 서블릿으로 전달되어 처리되는 과정(&lt;code class=&quot;language-text&quot;&gt;init&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;doGet/doPost&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;destroy&lt;/code&gt;) 중, &lt;code class=&quot;language-text&quot;&gt;doFilter&lt;/code&gt; 을 사용하여 인증/인가, 로깅, 인코딩 등등 사전에 할 수 있는 작업을 처리하기 위해 존재하는 필터영역이 존재한다. 스프링에서는 &lt;code class=&quot;language-text&quot;&gt;FilterRegistrationBean&lt;/code&gt; 을 사용하여 필터를 등록하여 이어서 사용한다고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;SecurityFilterChain&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;FilterChain&lt;/code&gt;은 위임가능한 &lt;code class=&quot;language-text&quot;&gt;FilterProxy&lt;/code&gt; 가 존재하며, 스프링시큐리티는 이것을 위임받아 인증/인가를 위한 기능들을 수행하는 필터리스트를 만들어 차례대로 수행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;SecurityContextHolder&lt;/code&gt; : 스프링 시큐리티에서 인증한 유저정보의 저장소이다. Authentication 객체를 가지고있는 SecurityContext를 지니고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Authentication 객체&lt;/code&gt; : 현재 인증한 유저의 실제정보를 지니고 있다. principal, credential, authorities 가 있는데, principal은 사용자를 식별 할 수 있는 clamin과 같은 정보이다. credential 는 패스워드이다. authorities는 현재 인증한 유저의 권한정보이다. &lt;code class=&quot;language-text&quot;&gt;GrantedAuthority&lt;/code&gt;로 추상화하여 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;li&gt;서블릿&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-4th Weekly I Learn]]></title><description><![CDATA[FACT-O1. 계층간 의존관계에 대해 깊이 고민해보았다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/22_12_4th/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_4th/</guid><pubDate>Sat, 24 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 계층간 의존관계에 대해 깊이 고민해보았다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존관계에 대해 애매한 부분이 많았고, 계층간 분리를 짓는다는 것이 어려웠다.&lt;/li&gt;
&lt;li&gt;많은 글들이 저마다 다른 목적으로 해결책을 제시하다보니 어디부터 손을 대야할지 막막했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DTO의 역할이 확실해지는게 느껴졌다. 잘만든 상위패턴을 하위에서 가져다 쓰는것이니, 하위가 상위에게 맞춘다면 의존관계가 끊기는 것이 느껴졌다.&lt;/li&gt;
&lt;li&gt;매개변수 및 내부로직이 변경될 때, DTO를 기준으로 양측은 조금씩만 변경해주면 되서 의존이 많이 끊기는게 느껴졌다.&lt;/li&gt;
&lt;li&gt;의존관계가 분리됨으로서, 각자의 책임과 역활이 분명해지는 것이 보였다.&lt;/li&gt;
&lt;li&gt;생각이 확정되기 전까지 많은 분들과 이야기를 나누면서 생각이 정리가 된 것들이 많다. 혼자 아티클들을 찾고 고뇌하는 것 보단, 다른사람들의 생각을 듣고 내생각을 말하면서 정리하는게 가장 효과적임을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DTO의 과사용이 오히려 의존관계를 만드는 것이 아닌가 싶었는데, 이번 고민들을 통해 오히려 관심을 외부에 돌리는 것, 그리고 상위의 관심에 하위가 맞추는것이 의존관계를 끊는것임을 깨달았다. DTO를 역할별로 많이 쪼개서, 계층간 의존이 분리되게 신경써야겠다. 그 과정에서 효과적으로 모듈화하는 방법도 고민해보아야겠다.&lt;/li&gt;
&lt;li&gt;이런 애매한 사항들, 읽는 것 만으로 와닿지 않는 것들은 사람들과의 토론을 통해 익혀야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 코드 리팩토링을 마쳤다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;귀찮게 느껴졌다.&lt;/li&gt;
&lt;li&gt;하지만, 마치고 나니 후련했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고민과 생각은 겁나게 하지만, 막상적용하려고 하니 막막하게 느껴져 계속 뒤로 미루게 되는 모습을 보게되었다.&lt;/li&gt;
&lt;li&gt;각잡고 앉아서 시작하면 몰입하는 모습을 보았다. 하지만, 워낙 의존이 끈끈하게 맺어져 있어서 한군데를 고치면 여러군데를 고쳐야 했고, 이 양이 많아지다보니 금방 지쳐 멈추게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 프로젝트의 구조를 유연하게 설계해야겠다.&lt;/li&gt;
&lt;li&gt;머릿속에 무언가 있는데 막막하다면, 일단 한줄이라도 적는것이 프로젝트 혹은 업무를 진행하는데 도움이 되겠다고 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-23 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_23/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_23/</guid><pubDate>Fri, 23 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;디자인패턴의 종류&lt;/code&gt; : 객체지향의 디자인 패턴은 큰 구분으로 생성, 구조, 행위의 목적으로 나뉘어진다. 생성의 경우에는 어떤 객체를 잘 생성하기 위한 것이다. 구조는 객체들을 모아 어플리케이션의 구조를 효율적으로 구성하기 위한 것이다. 행위는 객체간 어떤 행위 즉, 알고리즘이나 책임분배등을 위해 사용한다. 각각의 구분 하에는 다양한 패턴들이 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Bean&lt;/code&gt; : 스프링의&lt;code class=&quot;language-text&quot;&gt;IoC(Inversion Of Control) 컨테이너&lt;/code&gt;에서 관리하는 클래스들이다. &lt;code class=&quot;language-text&quot;&gt;싱글톤 패턴&lt;/code&gt;으로 관리되기 때문에, 어디에서 사용하나 같은 객체를 참조한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Component&lt;/code&gt; : 커스텀 빈을 선언 할 때, 사용하는 어노테이션이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Bean&lt;/code&gt; : 이것을 통해 선언한 것은 빈으로 관리되며, &lt;code class=&quot;language-text&quot;&gt;@Component&lt;/code&gt; 를 포함하고 있다. 주로 외부라이브러리들을 가져와 &lt;code class=&quot;language-text&quot;&gt;IOC컨테이너&lt;/code&gt; 에 등록할 때 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ 의 의미&lt;/code&gt; : 컴파일러에게 일을 시키는 주석이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;어노테이션의 종류&lt;/code&gt; : 자바에 내장된 내장(Built-in)어노테이션, 사용자 정의하여 사용하는 커스텀 어노테이션, 커스텀어노테이션을 만들기위해 사용하는 메타 어노테이션이 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Target&lt;/code&gt; : 메타어노테이션이며, 해당 어노테이션이 어디에 쓰일지 정의해준다. (필드, 파라미터, 클래스, 컨스트럭터 등등..)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Retention&lt;/code&gt; : 메타어노테이션이며, 해당 어노세이션이 어느시점에 쓰일지 정의해준다. 소스코드시점, 클래스시점, 런타임시점으로 나뉜다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Reflection API&lt;/code&gt; : 컴파일 시, static 영역에 있는 클래스 정보를 이용하여, 런타임 때 사용가능하게 만들어준다. 평상시에는 잘쓰지않지만, 라이브러리를 개발하거나, 라이브러리를 사용할 때 사용한다고한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221223 : 리팩토링4 (회고)&lt;/h2&gt;
&lt;p&gt;강의 전에 하려고 했던, 리팩토링을 오늘중으로 모두 마무리했다. 근 2주간 각각의 계층이 의존도를 낮추면서 어떻게 잘 일하게 할 수 있을까를 고민을 했고, 튜터님들의 세션, 조언들 그리고 팀원들과의 토론을 통해 도출된 결과를 오늘 한번에 반영했다. 아직 아쉬운 점은 많지만, 나름 서비스와 컨트롤러 사이의 의존도를 많이 낮춘 것 같아서 좋았다. 그리고 프로젝트를 4단계에 걸쳐 리팩토링하면서 얻은 꺠달음은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service에 맞게 DTO를 작성하는 것이 의존도를 낮추는 방법이다.
컨트롤러에서는 서비스의 필요에 맞게 DTO를 구성하여 타겟서비스에 전달한다. 그럼 앞단 컨트롤러가 변해도, 받는곳의 인자는 그대로 유지되기 때문에 의존도가 낮아진다.&lt;/li&gt;
&lt;li&gt;서비스는 자기가 맡은 역할만 충실하면 된다.
인증/인가와 같은 서브 로직이 들어가면 안된다. 예를들어, &apos;게시글을 수정한다&apos; 라는 로직은 게시글을 수정하는 목적만 수행해야한다. 게시글 수정이 실제로 일어나는 시점, 즉 핵심비즈니스 로직이 실행되는 시점에는 모든 서브로직들을 거치고 완전한 데이터를 받는 상황을 가정한다.&lt;/li&gt;
&lt;li&gt;연관관계는 보수적으로 만든다.
정말 필요한 곳에만 만든다. 연관관계가 있다는 것은, 조회시 여러 테이블을 살펴봐야한다는 것이다. 물론 모두가 연결되면 좋지만, 긴 쿼리수행시간으로 인한 서비스속도의 저하나, 순환참조같은 변수를 줄이기 위해선 정말 필요한 곳에만 연관을 맺어줘야한다. 마찬가지로 양방향보단 단방향으로 관계를 맺어주고, 필요한 곳에만 양방향으로 관계를 맺어줘야한다.&lt;/li&gt;
&lt;li&gt;역전의 제어를 기억한다.
역전의 제어는 이미 잘만들어진 상위 객체를 가져다 쓰는 것이다. 레파지토리는 이미 잘만들어져있기 때문에, 서비스를 잘만들어주는 것이 스프링 프로젝트를 잘 구성하는 방법중에 하나이다. 컨트롤러는 단지 잘 만들어진 서비스를 가져다쓰는 친구이다.&lt;/li&gt;
&lt;li&gt;역할과 책임에 충실해야한다.
도메인 부터 시작해서 서비스, 레파지토리, 컨트롤러는 각자의 역할이 있다. 그 역할을 벗어나는 일을 맡아선 안된다. 또한 무언가를 뱉는 것은 다음사람에게 똥을 투척하는것이나 같기 때문에 최대한 void형태로 책임을 자기 안에서 마무리 할 수 있도록하자. 만일 무언가를 뱉어야하는 상황이 된다면, 정말 필요한 것만 뱉자.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이외에 더 많은 경험들을 했지만 생각나는것은 이정도이다. 슬슬 자바의 핵심개념들이 다시 등장하고 있는데, 항상 스프링은 자바위에서 돌아가고 있음을 또한 자바는 컴퓨터위에서 돌아가고 있음을 상기해야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-22 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_22/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_22/</guid><pubDate>Thu, 22 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;맨하탄 거리법&lt;/code&gt; : 두 점사이의 거리를 구하는 방식은 루트를 사용하는 방법인 &lt;code class=&quot;language-text&quot;&gt;유클리드 방식&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;맨하탄 방식&lt;/code&gt; 이 있다. 맨하탄 방식은 주로 상하좌우로 움직이는 제한이 있을 때 사용하는데 공식은 다음과 같다. &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;∣&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;∣&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;∣&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;∣&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;| x2 - x1 | + | y2 - y1 |&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;REST(REpresentaional State Transfer)&lt;/code&gt; : 자원을 표현(Representation)에 의한 상태(State)에 맞게 전달(Transfer)하는것.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;멱등성&lt;/code&gt; : 같은 요청을 보내도 같은 결과를 반환하는 성질&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;HATEOAS(헤이티오스)&lt;/code&gt; : 자원에 호출가능한 api들까지 응답에 넣어서 보내주는 형태로서, REST api 를 구현하는 가상 상위 단계이다. 이런 표현으로 인해 클라이언트는 서버에서 받은 API주소로 다음단계에 대한 호출을 실시하면된다. 따라서, 클라이언트와 서버의 완전한 분리가 가능하게 된다. 하지만, 아직도 논란이 많은 형식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221222 : 다시 앞으로 전진하기&lt;/h2&gt;
&lt;p&gt;시간이 빨리가기 시작했다. 적응했다는 말이다. 나는 지난주 수,목요일 정도에 과제를 모두 마치고, 리팩토링을 진행했다. 즉, 프로젝트에 관해서 할일이 없어졌다는 말이다.
과제가 마무리되니, 엉덩이가 가벼워져 집중력이 많이 낮아졌다. 팀원분들께서 물어보러 오는 상황도 없어서 심심했고, 그런 상태로 그대로 지냈다. DTO와 서비스의 의존관계에 대해서 고민했고, 결론을 얻어내는 수확을 얻었지만, 그건 나혼자 고민하고 자료를 알아보면서 알아낸 것이고, 내가 부족한 CS나 독서들로 그 시간을 채우지 못했음에 너무 죄책감이 들었다.&lt;/p&gt;
&lt;p&gt;나는 굉장히 수동적인 사람이라는 것을 느꼈다. 하지만, 앞으로 나아갈 길이 먼만큼.. 좋은곳에 취직하기 위해선, 능동적으로 내가 필요한 것들을 찾아공부하는 자세가 필요한 것 같다. 심화파트도 시작되었고, 다시 억지로 앞으로 나가야하지만, 주어진 것이 마무리되면 나는 여태까지의 관성으로 인해 멈추려고 발악할 것 이다.&lt;/p&gt;
&lt;p&gt;하지만, 난 이제 다신 같은 실수를 반복하지 않겠다. 빈 시간에는 어제보다 나은 내 모습을 위해 발전하는 일을 하면서 다시금 야금야금 앞으로 전진해야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-21 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_21/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_21/</guid><pubDate>Wed, 21 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@NoArgsConstructor&lt;/code&gt; : 매개변수가 없는 생성자를 자동으로 생성해주는 어노테이션.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@RequiredArgsConstructor&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;final&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;@Notnull&lt;/code&gt; 이 붙은 멤버변수를 초기화해주는 생성자를 자동으로 생성해주는 어노테이션.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@AllArgsConstructor&lt;/code&gt; : 모든 멤버변수를 초기화해주는 생성자를 자동으로 생성해주는 어노테이션.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;final이 있을때 생성자의 초기화&lt;/code&gt; : 상수로 선언된 멤버변수는 생성자/초기화블록/직접선언 등으로 인스턴스 선언 시 반드시 초기화를 해주어야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221221 : 리팩토링4&lt;/h2&gt;
&lt;p&gt;어제 DTO가 다른 곳에서의 의존도를 낮추기 위해서, 서비스의 매개변수 수는 DTO의 멤버변수보다 같거나 작아야하고, 서비스는 그런 DTO안에 뭐가 들어있는지 신경쓰지 않고 꺼내기만 하면 되기에 의존도가 낮다고 표현했었다.
하지만, 오늘 우아한 형제들에서 아티클을 읽고 생각이 바뀌었고, 확고해졌다.&lt;/p&gt;
&lt;p&gt;서비스 DTO는 그것을 넘겨받는 서비스에서 필요한 만큼의 매개변수 만을 보내야하고, 컨트롤러는 서비스에 맞게 DTO를 구성해서 서비스에게 전달해야한다. 스프링에서 쓰는 방식이 IoC(Inversion Of Control) 즉 제어의 역전 방식이고, 이것은 잘만든 서비스를 컨트롤러에서 가져다 쓰는 것이기 때문에, 서비스는 컨트롤러가 어떤건지 신경쓰지 않아도 된다. 그렇기 위해선, 해당 서비스에서 사용하는 DTO를 미리정의해두고, 컨트롤러에서 정의된 DTO에 데이터들을 모두 넣어서 보내주면, 서비스는 컨트롤러가 어떻게 바뀌던 신경쓰지 않아도된다.&lt;/p&gt;
&lt;p&gt;따라서, 서비스 DTO는 필요인자만으로 구성되어야 외부의존도가 낮아진다 라는 결론이 섰다.&lt;/p&gt;
&lt;p&gt;또한, 튜터님의 라이브코드리뷰를 보면서, 서비스가 자신의 역할만 할 수 있게 하는 방법에 대한 팁을 얻었다. 인증/인가에 대한것은 앞단 레이어에서 마치고, 서비스는 인증인가가 되었다는 가정하에, CRUD에 대한 비즈니스 로직만을 신경써야한다. 또한 엔티티간에 관계를 맺을 때, 굳이 양방향관계를 맺지않아도 되고, 무조건 관계를 맺지 않아도 됨을 상기시킬 수 있었다.&lt;/p&gt;
&lt;p&gt;스프링에 대해서 알면 알 수록 그 철학들이 너무 신비롭고 흥미롭다. 철학들을 적용했을 때, 깔끔해지고 명확해지는 코드를 보면서 쾌감을 느끼는 것이 너무 재미있게 느껴졌다. 내일부터는 숙련단계를 거쳐 시큐리티와 AOP같은 고급개념들이 등장하는 심화단계가 진행되는데, 얼마나 더 스프링과 친해 질 수 있을지 기대된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-20 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 영속성 컨텍스트를 벗어난 객체의 변화가 감지되면, flush 시 변화를 자동으로 업데이트 해주는 것. 주로  어노테이션을 붙혀서 실행시킨다. DirtyChecking…]]></description><link>https://mitoconcrete.github.io/22_12_20/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_20/</guid><pubDate>Tue, 20 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DirtyChecking&lt;/code&gt; : 영속성 컨텍스트를 벗어난 객체의 변화가 감지되면, flush 시 변화를 자동으로 업데이트 해주는 것. 주로 &lt;code class=&quot;language-text&quot;&gt;@Transactional&lt;/code&gt; 어노테이션을 붙혀서 실행시킨다. DirtyChecking으로 업데이트 되는 필드는 같은 내용이 있더라도, 전체 필드를 업데이트를 한다. 이것을 막기위해선 &lt;code class=&quot;language-text&quot;&gt;@DynamicUpdate&lt;/code&gt; 어노테이션을 붙히면 DirtyChecking이라도 업데이트대상 필드만 업데이트된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;프록시 패턴&lt;/code&gt; vs &lt;code class=&quot;language-text&quot;&gt;파사드 패턴&lt;/code&gt; : 프록시 패턴은 핵심로직을 갖고 있는 어플리케이션을 프록시를 통해 숨기고, 핵심로직을 수행하기 전에 다양한 레이어들을 가변적으로 추가할 수 있다. 반면에 파사드는 어떤 한동작을 하기위해 그안에 있는 다양한 동작들을 보이지 않게 하기위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221220 : 리팩토링3 (DTO)&lt;/h2&gt;
&lt;p&gt;DTO의 범위 대해 이전조의 팀원분과 토론을 한바탕 나눴다. DTO에는 메소드에서 필요한 정보들과 불필요한 정보들이 한번에 전달될텐데, 그것을 실행하고자 하는 함수에 맞추는 것이 의존도를 높히는 것일까 낮추는 것일까에 대한 토론을 했다.&lt;/p&gt;
&lt;p&gt;난 서비스를 정의할 때 DTO를 그대로 넘기기보단, 필요한 것들만 넘기는 것을 선호했다. 이유는, 서비스가 DTO에 의존하기 않기를 바랬기 때문이다. DTO에 들어오는 값은 항상 필요한 값들만 들어오는 것이 아니라, 여러가지 항목들이 추가되어 들어오기도 한다. 이 때, &apos;의존&apos;한다는 것에 대한 의미가 헷갈리기 시작했는데, 서비스 입장에서 항상 어떤 것이 들어온다는 보장이 있다면, 외부를 의식하지 않고 개발이 가능하기 때문에, 내가 기존에 하던 방식이 의존도가 낮다고 생각했다. 하지만, 팀원분이 제시한 의견은 달랐다. 오히려 DTO에 미리 정의된 값들이 들어있기 때문에, DTO하나만 넘기면 서비스는 밖에서 어떤게 넘어오던지 상관하지 않고 DTO하나만으로 개발이 가능해진다. 이것이 오히려 상호 의존도가 낮아지는 것이 아닌가 하는 의견을 주셨다. 나는 충분히 납득이 갔고, 쉼표를 이용해 여러개로 받아오던 인자를 DTO를 받아오는것으로 변경하였다.&lt;/p&gt;
&lt;p&gt;다만, DTO 내부의 값 중에서 상황에 따라 노출되는 값들을 innerclass 로 차등을 두었다. 이렇게 되니, 서비스끼리만 주고받는 DTO와 Request시 주고받는 DTO와, Response 시 보여지는 DTO의 형식이 모두 달라지게 설정 할 수 있었다. 다만, DTO내부에 설정들이 많이 늘어나게 되었는데, 이것이 과연 맞는 것이지는 계속적으로 고민중이긴하다.&lt;/p&gt;
&lt;p&gt;튜터님께서는 현업에서는 DTO를 세부적으로 쪼개는 것을 선호하신다고 했다. 그게 훨씬 비용적으로 나은게, 내 방식을 유지한다면 지금 하는 프로젝트의 규모가 작기에 망정이지 조금이라도 커지거나 서비스가 늘어날 때 계속 같은 클래스안에 innerclass가 추가되어야 할 것이다., DTO내부에 추가되는 코드가 매우 많아질 것이다. 이것은 좋지않은 패턴같다고 생각했다. 하지만, 이미 많은 부분을 innerclass를 이용해 작업을 해서, 이부분을 먼저 작업한 뒤, dto를 쪼개는 방식을 적용해보려고 한다.&lt;/p&gt;
&lt;p&gt;하지만, 오늘 토론을 통해 각자의 역할이 확실한 DTO를 생성해주는 것이 의존도를 낮추는데 도움을 준다는 것이 확실시 되서 기분이 좋았다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-19 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드 NextKeyworks Study Queue HTTPS SOLID loop label CSV 파일입출력 UML UTC epoch time / Instant time MVC URL ClassLoader…]]></description><link>https://mitoconcrete.github.io/22_12_19/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_19/</guid><pubDate>Mon, 19 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221219 : 리팩토링2 (서로가 서로의 존재를 모르게 하는 것)&lt;/h2&gt;
&lt;p&gt;리팩토링을 하다 어느순간 손이 멈췄다.
각 계층이 서로에게 의존하지 않고, 또 흐름에 따라 DTO가 지속적으로 변화하지 않아야하며, DTO는 단순히 데이터를 옮겨주는 꾸러미의 역할만 했어야했다.
또한, 각 서비스들은 각자의 역할에 충실해야만 했다. 하지만, 계속 손이 멈췄던 이유는 연관관계를 갖는 엔티티들 간에 DTO를 주고받을 때, 어쩔 수 없이 DTO에 엔티티를 넣어줘야하는 상황이 발생했기 때문이었다.&lt;/p&gt;
&lt;p&gt;ㅅㅁ튜터님은 영속상태의 엔티티는 절대 컨트롤러까지 내려와선 안된다고 당부하셨다. 주말부터 꿈에서 계속 이 프로젝트를 리팩토링하는 꿈을 꿨는데, 꿈에서도 원활하게 안되서 잠도 편히 잘 수 없었다. 오늘 내내 많은 레퍼런스들을 보았다. 하지만, 명확한 해답이 없는 문제라 더욱더 고민이 많아지고 스트레스를 받는 것 같다.&lt;/p&gt;
&lt;p&gt;확실해진 것은, 일단 영속적인 엔티티를 컨트롤러에서는 알 수 없어야하고, 다룰 수 없어야 한다는 것.
DTO끼리 매개변수로 넘기는 것은 최대한 지양해야한다는것(DTO에 종속적이게 됨)
DTO를 엔티티로 바꾸고 다루는 계층은 서비스계층이어야 한다는 것이다.&lt;/p&gt;
&lt;p&gt;아직 충돌되는 것도 많고, 혼란스러운 점도 많다. 따라서, 이럴때 일수록 나 스스로 납득이 되고, 팀원들도 쉽게 이해시킬 수 있는 역할 정의가 필요하다.&lt;br&gt;
프로젝트까지 남은 기간이 얼마남지 않았는데, 그 전까지 나름의 기준을 세워 지난 프로젝트처럼 모든 팀원들이 같은 그림을 그리고 프로젝트에 돌입하게 하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-3rd Weekly I Learn]]></title><description><![CDATA[FACT-O1. 과제구현을 기한내에 마무리 지었다. FEELINGS 설계단계가 매우 귀찮게 느껴졌다. '이 많은 것들을 언제 다 구현 할 수 있을까' 라는 기분이 들어, 막막했다. 설계와 구현사항을 그대로 구현하니 금방 할 수 있었다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/22_12_3rd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_3rd/</guid><pubDate>Sun, 18 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 과제구현을 기한내에 마무리 지었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;설계단계가 매우 귀찮게 느껴졌다.&lt;/li&gt;
&lt;li&gt;&apos;이 많은 것들을 언제 다 구현 할 수 있을까&apos; 라는 기분이 들어, 막막했다.&lt;/li&gt;
&lt;li&gt;설계와 구현사항을 그대로 구현하니 금방 할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;집중력을 올리는데 굉장한 시간이 소요됨을 느꼈다.&lt;/li&gt;
&lt;li&gt;머릿속으로는 설계에 따라 구현을 다 마친 상태지만.. 현실에서는 계속 뒤로 미루는 내 모습을 발견 할 수 있었다. 하지만, 한번 흐름을 타니 금방 완성하는 내 모습을 볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나 스스로가 머릿속에 뭔가 답이 내려지면, 그 답을 도출하기 위한 행위를 직접 행동으로 옮기는게 굉장히 오래걸리는 타입이라는 것을 느꼈다. 설계던 개발이던 한번 행동하면 금방 몰입하니 귀찮다고 느껴지면, 한줄이라도 뭔가 행동하여 빠르게 집중력을 올리는 게 능률향상에 도움이 된다고 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 못풀것이라고 생각했던 알고리즘 문제를 풀어냈다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 가지고 있는 풀이로는 절대 문제를 풀 수 없을거란 생각이 들었다.&lt;/li&gt;
&lt;li&gt;반복의 끝이 명확하지 않아서, 로직을 생각하는데 있어서 계속 막히는 부분이 있었다.&lt;/li&gt;
&lt;li&gt;결국은 풀어내었고, 한 단계 성장함이 느껴져서 굉장히 기분 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제가 이해되었고, 어떻게 풀지 전략이 확실하며, 로직을 반복하는데 있어서 종료시점이 명확하면 그대로 알고리즘을 풀었을 때 타율이 낮지 않은것을 발견 할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;집념만 있다면, 못푸는 문제는 없다고 생각한다. 반복문을 많이써야하는 내 로직이 틀렸다고만 생각하지 말고, 일단 풀이법이 정리가 되었다면, 그것의 효율여부와 관계없이 일단 작성하고 그다음에 성능을 신경써서 리팩토링하면된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O3. 프로젝트 반복 로직 해결을 위해 리팩토링을 해내었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내 상황에 딱 맞는 솔루션이 없어서 답답했다.&lt;/li&gt;
&lt;li&gt;이 문제를 해결하기 위해 다른 것들을 알아보는 과정이 재미있었다.&lt;/li&gt;
&lt;li&gt;결국 비슷한 사례를 검색 할 수 있었고, 재사용성이 높게 코드를 리팩토링 할 수 있어서 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내 상황과 비슷한 사람이 또 있겠지라고 생각하고 항상 문제가 닥치면 검색하려고 했는데, 그렇지 않는 사례도 있다는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;리팩토링을 하는 과정에서 전체적으로 더 잘 공부되는 것이 있어서 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링을 그동안은 귀찮아서 잘 하지 못했는데, 프로젝트나 기술을 한번 더 곱씹을 수 있는 좋은기회라는 것임을 깨달았다. 또한, 항상 검색으로 문제를 해결하기 보다는, 내가 좋은 코드를 많이 보면서 다양한 문제를 스스로 해결 할 수 있는 힘을 길러야 겠다는 판단을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-16 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 기민하다. 라는 뜻으로 애자일 방법론은 워터폴방식과 다르게, 짧은단위를 나누어 기능을 개발하고 요구사항 및 피드백을 통해 빠른 개선 및 개발을 진행하는 것. NextKeyworks Study Queue…]]></description><link>https://mitoconcrete.github.io/22_12_16/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_16/</guid><pubDate>Fri, 16 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;애자일&lt;/code&gt; : 기민하다. 라는 뜻으로 애자일 방법론은 워터폴방식과 다르게, 짧은단위를 나누어 기능을 개발하고 요구사항 및 피드백을 통해 빠른 개선 및 개발을 진행하는 것.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221216 : 리팩토링&lt;/h2&gt;
&lt;p&gt;오늘은 과제에서 가장 신경쓰였던 반복로직의 분리를 해결하기 위해 시간을 보냈다. 먼저 파사드 패턴에 대해서 스터디를 했을때, 파사드 패턴은 주로 하위 단계가 있는 과정에서 그것을 연속적으로 사용하는 경우에 쓰기위한 방법이다. 따라서, 특정로직을 주요로직들을 실행시키기 전에 실행한다라는 내 목적과는 맞지 않는 부분이 있어서 적용을 포기했다. 전략패턴, 어댑터 패턴등등 다양한 디자인 패턴들에 대해 조사해보았지만 나와 같은 문제에서 사용하기 적합한 로직을 발견 할 수 없었다.&lt;/p&gt;
&lt;p&gt;그러던 중 &lt;code class=&quot;language-text&quot;&gt;Service 분리&lt;/code&gt; 라는 키워드를 검색해보았고, &lt;a href=&quot;https://velog.io/@boo105/Service-Layer-%EC%B1%85%EC%9E%84&quot;&gt;이 글&lt;/a&gt;을 발견 할 수 있었다. 이 분은 서비스코드가 복잡해지는 것에 대한 고민을 하셨고, 그에 따라 관심사를 서비스단에서 컨트롤러단으로 옮기셨다고 한다. 글을 읽다보니 &apos;어 그러고 보니, 인증/인가가 추가되면서 생성,수정,삭제에서 너무 많은 책임을 지고 있잖아..?&apos; 라는 판단이 들었다. 생각해보니, 로그인의 요청을 받은 곳은 컨트롤러이니 요청받은 것을 해결하기 위한 책임은 컨트롤러에서 져야하지 않나..? 그럼 위 글 처럼 서비스를 분리시켜놓고, 그것을 필요한 것만 가져다쓰면 되지 않을까 라는 생각이 떠올랐다.&lt;/p&gt;
&lt;p&gt;곧바로 리팩토링에 착수하였다. 서비스에 많은 책임을 가지고 있는 로직을 v1, 컨트롤러에서 많은 책임을 가지고 있는 로직을 v2로 정의하고, 컨트롤러와 서비스만을 리팩토링하였다.
기존 로직을 보면서 서비스 인터페이스를 작성하였는데, 처음에는 굉장히 쉽지 않았다. 하지만, 몇시간동안 헤매면서 작성하다보니 공통적인 패턴이 보였고 서비스 인터페이스를 모두 작성 할 수 있었다. 생각해보니, 이전서비스에서 이렇게 쪼개어 작성했고, 컨트롤러단에서 서비스들을 갖다가 썼었었다. 하지만, 서비스는 곧 비즈니스로직이라는 생각을 갖추게 되면서 의도적으로 모든 책임이 서비스로 몰리게 되면서 서비스에서 많은 반복과 복잡도를 지니게 만든것 같았다.&lt;/p&gt;
&lt;p&gt;컨트롤러에서 잘 만들어진 서비스들을 과정에 맞게 잘 가져다쓰니, 큰 비용없이 눈에 보기쉬운 로직을 완성 할 수 있었다. 전체적으로 로직이 반복되기 때문에 그냥 필요한 순서에 맞는 것을 잘 가져다 쓰면 되었다. 또한 이렇게 되니, 서비스의 각 메소드는 자신의 역할에 맞는 비즈니스로직만 실행하면 된게 가장 큰 장점이었다. 즉, 서비스에서 외부의 로직을 신경쓰지 않아도 되었다. 리팩토링이라는 것을 항상 미뤄왔는데, 리팩토링을 통해 더욱 만족스러운 로직이 작성되는 것을 보면서 뿌듯함을 느꼈다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-15 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 공통관심사를 주로 처리한다. aop…]]></description><link>https://mitoconcrete.github.io/22_12_15/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_15/</guid><pubDate>Thu, 15 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;AOP(Aspect Oriented Programming)&lt;/code&gt; : 공통관심사를 주로 처리한다. aop의 공통 관심사는, 로직내에서 반복되는 로직이라기 보단, 로깅과 같이 메소드의 흐름을 전체적으로 봐야하는 로직을 의미하는 것 같다. 비즈니스에서 핵심로직은 공통관심사가 아닌, 해당 로직에서의 주요관심사이기에, 분리 될 수 없다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;IllegalArgumentException&lt;/code&gt; : 메소드가 적합하지않은 인자를 넘겨받았을 때 발생시키는 오류이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Claim 기반토큰&lt;/code&gt; : 사용자 데이터를 가지고 있는 토큰&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Spring controller return 타입&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;@ResponseBody&lt;/code&gt;의 형태에 따라, 자동으로 response header 의 contents-type이 셋팅된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Access Token&lt;/code&gt; : 로그인 이후, 해당 유저를 인증하기 위한 토큰이다. 해당 토큰을 헤더에 넣어보내면 재인증할 필요없이 정보를 이용하거나 생성할 수 있게한다. 다만, 도난 시에 다른 상대도 로그인 된 것처럼 사용할 수 있기에, 보안에 대한 이슈가 있다. 따라서, 이 토큰의 만료시간은 보통 1시간에서 2시간으로 짧게 둔다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Refresh Token&lt;/code&gt; : Access Token 이 만료되거나, 도난되었을 때 새로운 Access Token을 발급받기 위한 토큰이다. 즉, 토큰을 위한 토큰이다. 해당 토큰의 만료기간은 1~2개월 정도 가지며, 서버에 저장하고 이용하는 방식과, 클라이언트에 저장하고 이용하는 방식 2가지로 설계가 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Builder&lt;/code&gt; : 해당 어노테이션을 사용하면 모든 세터가 생기고, 그걸 빌더라는 메소드를 통해 한번에 가져오는게 가능한, 빌더패턴이 생성된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221215 : 인증과 인가&lt;/h2&gt;
&lt;p&gt;오늘은 2차과제를 마무리하고, 추가 구현사항인 Refresh Token과 Access Token을 구현하는데 집중했다. JWT라는 것이 많은 정보를 집약해서 만드는 것이기 때문에 사용이 번거로워 계속 피해다녔는데, 이번에 프로젝트 속도를 낼 수 있게 되면서 직접 구현부터 시작해서 JWT를 이용하여 Refresh Token과 Access Token 까지 건들여보았다. 처음엔 개념이 잘 와닿지 않았지만, JWT라는게 내 정보를 들고다니는 것인데, 그걸을 남한테 강탈당할 경우를 생각을 못했다. 따라서, access token의 만료시간을 1시간에서 2시간정도로 짧게 설정해주고, Refresh Token이라는 것을 두어 이것이 있다면, 지속적으로 로그인을 유지하는 것이 가능하도록 설계한 것이다. 처음엔, 이 모든 토큰을 클라이언트에 저장하여 검증하려고 했는데, 로컬/세션스토리지는 까볼 수 있기 때문에, 강탈의 위험이 있다고 판단했다. 따라서, 거의 세션-쿠키방식으로 DB를 하나 더 생성하여, Refresh Token만 DB를 통해 검증하도록 로직을 만들었다. 우아한 형제들에서 작성한 테코블이라는 블로그에도 비슷한 고민을 한 흔적이 있었고, 그것을 참고했을 때 DB에 저장하는 것이 안정적이라는 판단이 들어 RefreshToken을 저장하는 테이블을 만들고, 이곳에서 검증하도록 했다.&lt;/p&gt;
&lt;p&gt;다만, 토큰의 검증을 위해서 어떤 로직이 실행될 때마다, RefreshToken을 저장하는 테이블을 읽는 것이 문제가 될 여지가 있다..
그렇다면, 어떻게 오버헤드를 줄일 수 있을까? 로직의 분리 혹은 검증을 단순화하는 방안을 고민해보아야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-14 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_14/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_14/</guid><pubDate>Wed, 14 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;AOP(Aspect Oriented Programming)&lt;/code&gt; : 관점지향프로그래밍이라는 뜻으로, 객체지향프로그래밍 방식을 보완하는 프로그래밍방식이다. 로직 중 공통된 로직이나 반복되는 부분을 관점이라는 개념으로 분리하는 것이다. 코드의 모듈화가 아닌 분리이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221214 : 알고리즘 성장(?)과 스프링구현 고민..&lt;/h2&gt;
&lt;p&gt;어제 아침에 풀려다가 포기한, 옹알이(2)문제를 다시 풀었다. 내가푸는 방식에 대해 계속 의심하면서 풀다보니 계속 막히는 부분이 있었다.
이건 기존에도 문제 풀 때 계속 느끼던 느낌이었는데, 보통은 이런 느낌이 들면 거의 문제를 포기했었다. 반복문에 대한 종료시점이 명확하지 않고, 피벗을 굉장히 많이 사용해서 이게 맞나 하는 의심이 들었다. 지속적으로 고민하다보니, 알고리즘 반복문 종료시점이 명확해졌고, 많은 피벗을 차례대로 컨트롤하니 문제가 풀렸다! 넘지못할것같은 기분을 이겨내고, 시간안에 문제를 풀어내니 자신감이 상승했고, 뿌듯했다. 어제보다 한단계 성장한 것 같아서 좋았다.&lt;/p&gt;
&lt;p&gt;이후에는 숙련 2차 과제를 구현하는데, 많은 시간을 소요했다. 역할이 명확이 분리되어있기때문에, 1차적으로 구현하는 것은 어렵지 않았다. 하지만, 같은 로직이 반복되는 것을 효과적으로 분리시키기 위한 방법을 리서치하느라 오후시간을 낭비했다.. 보통 AOP를 사용해서 관점을 분리시킨다던데, aop는 로깅이나 인증같은 방식을 선호하는 것 같았다. 즉, 뭔가를 return 해서 사용하는 방식은 AOP에서 선호되지 않는 것 같았다. 객체지향 디자인패턴도 찾아보았는데, 내 상황에 맞는 적절한 케이스를 찾지못했다.&lt;/p&gt;
&lt;p&gt;공통로직을 떼어내지 못하니 유지보수하는데 시간이 많이 소요되었다. 한곳만 고치면 되는 것을 여러로직을 모두 변경해주어야했다. 아직 예외처리 및 README.md 가 미흡한 곳이 있고, api 문서도 보완해야하는 부분이 있어 내일은 미흡한 부분을 우선적으로 보충하는데 집중하려고 한다. 로직분리는 지속적으로 고민하고 보완해야하는 부분이기 때문에, 더 나은방안을 고민해보다 적당한 방법이 생각나면 적용하려고한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-13 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 개발 할 때 인스톨한 라이브러리들에 의존해야 개발 및 실행이 가능하다. 따라서, 라이브러리 리스트를 의존성이라고 한다.  : 의존성을 가져오는 곳의 위치를 나타낸다. 같은 개념.  :…]]></description><link>https://mitoconcrete.github.io/22_12_13/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_13/</guid><pubDate>Tue, 13 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;의존성&lt;/code&gt; : 개발 할 때 인스톨한 라이브러리들에 의존해야 개발 및 실행이 가능하다. 따라서, 라이브러리 리스트를 의존성이라고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;build.gradle의 repository&lt;/code&gt; : 의존성을 가져오는 곳의 위치를 나타낸다. &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;같은 개념.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;base64&lt;/code&gt; : _ , - 가 없다고 한다. 이외 다른 기호를 사용해야한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;spring 의 user table 사용불가&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;MYSQL&lt;/code&gt; 예약어 중 &lt;code class=&quot;language-text&quot;&gt;user&lt;/code&gt;이 있기때문에, table명으로 사용이 불가하다. 따라서 @Table 을 이용하여, name을 다르게 설정해주어야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;AOP&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221213 : 생각하며 개발하기&lt;/h2&gt;
&lt;p&gt;오늘은 개인프로젝트 1차과제를 마무리했다. 계속 JWT를 셋팅하는 것이 귀찮아서 꾸물대다가 오후 늦게 시작했는데, 속도가 붙으니깐 금방 완성 할 수 있었다.
진행하다보니, 역할과 책임에 대해 고민되는 순간이 많았다.&lt;/p&gt;
&lt;p&gt;먼저, 패스워드와 이메일을 검사하는 로직을 어디에 넣을지 고민했다. 해당 메서드를 저장하는 곳은 유저이기 때문에, 유저에서 static으로 선언하여, 곧바로 접근 할 수 있는 validation을 만들어 검증하려고했다. 그 전에, &lt;code class=&quot;language-text&quot;&gt;spring entity validation&lt;/code&gt;이라는 키워드로 검색해보니, 내가 현재사용하고 있는 JPA Wrapper인 Hibernate에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;@Valid&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;@Validate&lt;/code&gt; 라는 2가지 내장 validation을 찾을 수 있었다. controller 에서 검증하는 것을 기본으로 여기고 있었고, 다른 곳에서 이 검증을 사용하기 위해선 &lt;code class=&quot;language-text&quot;&gt;@Validate&lt;/code&gt;를 사용한다고했다. 보통 기본으로 셋팅되어있는 것이 보통은 해당 라이브러리의 철학이 반영되어있는 것이기 때문에, &lt;code class=&quot;language-text&quot;&gt;@Valid&lt;/code&gt;를 사용하여, 애초에 데이터를 받을 때 controller에서 검증 할 수 있도록했다. 하지만, 이전 django는 이런 validation을 entity에서 직접해주었고, 내가 배운이론은 validation은 entity에 선언하여 service에서 직접하는 것이 맞다라고 배웠기때문에.. 아직도 혼란스럽긴하다. 하지만, 기본 철학을 일단 따르려고한다.&lt;/p&gt;
&lt;p&gt;두번째로 JWT Token을 검증하고, 검증된 User 인스턴스를 가져오는 로직이 모든 곳에서 반복되기에, 이것을 메소드로 모듈화 시켰다. 하지만, 이 로직을 분리하는게 맞을지, 아니면 일일히 써주는 것이 맞을지, 분리한다면 다른 클래스로 선언해야하는 건지에 대한 고민이 들었다. 일단, 검증은 서비스의 역할이기에 타 클래스로 선언하는 것은 배제했다. 검증은 각 메소드에서 해주어야 하는 책임이기 때문에, 검증만 한다면 분리하는덴 어려움은 없겠지만, 검증하고 그에맞는 유저를 가져오기도 해야해서, 역할이 2개가 되어버리는 상황이 생겼다. 엄청 고민을 하다 차라리 네이밍이라도 자세히하는게 나을 것 같아. &lt;em&gt;요청을 받아 인증받은 유저를 반환한다.&lt;/em&gt; 라는 의미의 메소드명을 짓고, 그것을 지속적으로 사용했다.&lt;/p&gt;
&lt;p&gt;등등 매순간마다, 이걸 사용했을 때, 어떤 의존성이 있을지.. 의존성은 어디에서 발생하는지..내가 SOLID는 잘지키고 있는 것인지 고민하며 진행하니 굉장히 천천히 프로젝트가 진행되었다. 또한, 인터페이스를 사용하다보니, 확실히 이걸 왜쓰냐.. 라는 생각은 들었지만, 명세서를 보고 설계를 하는 것이 한층 수훨하다는 느낌을 받았다. 하지만, 프로젝트의 깊이가 깊질않아서, 굳이 사용 할 필요는 못느꼈다.&lt;/p&gt;
&lt;p&gt;어쨋던, 이렇게 생각하며 프로젝트를 진행하다보니, &apos;이유없는코드&apos;들이 없어서 좋았다. 마치, 글씨를 꾹꾹눌러쓴 일기처럼 기억에 남았다.&lt;/p&gt;
&lt;p&gt;하지만, 자바의 기본기를 계속 조금씩 잊어가고 있는데.. 얼른 프로젝트 마무리하고 다잡아야겠다..&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-12 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 지연로딩방식은 프록시객체를 상속받아서 사용한다. 하지만, final로 선언한 값은 상속이 안되기 때문에, 만일 Entity가 final class 이거나, final…]]></description><link>https://mitoconcrete.github.io/22_12_12/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_12/</guid><pubDate>Mon, 12 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;entitiy에서 final 사용불가&lt;/code&gt; : 지연로딩방식은 프록시객체를 상속받아서 사용한다. 하지만, final로 선언한 값은 상속이 안되기 때문에, 만일 Entity가 final class 이거나, final 멤버변수가 있다면, 그것을 상속받을 수 없기 때문에 지연로딩이 불가하게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DI&lt;/code&gt; : 주로 인터페이스를 주입한다. 클래스를 주입하게 되면, 주입 된 클래스의 모든기능에 의존하게 된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Controller vs @RestController&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;@RestController&lt;/code&gt;는 Response body가 추가되어, 클라이언트에 상태코드 이외의 것을 전달 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@RequestBody와 setter&lt;/code&gt; : @RequestBody 내부적으로 Jackson2HttpMessageConverter 라이브러리를 사용하여 Body를 읽어오는데, 이때 사용되는 ObjectMapper 가 readWithView 라는 기능을 이용하여, setter 없이도 body를 읽을 수 있게 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@RestControllerAdvice&lt;/code&gt; : 전역의 에러를 감지한다. &lt;code class=&quot;language-text&quot;&gt;@ExceptionHandler&lt;/code&gt; 를 이용하여, 감지할 예외를 설정할 수 있고, 이것을 이용하여 try-catch 없는 코드를 작성 할 수 있다. 패키지 단위로도 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;파사드 패턴&lt;/code&gt; : 하위 시스템을 쉽게 사용하게 만드는 상위 시스템을 만들어 관리를 간편하게 만드는 패턴. 어댑터 패턴과 비슷하지만, 어댑터는 원래코드를 다른코드와 함께 작돌시킬수 있는 래퍼를 만드는 것이고, 파사드는 기존코드를 더 쉽게 사용하게 만들어주는 패턴이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;비즈니스 로직이란?&lt;/code&gt; : DB에서 뭔가를 가져와서, 그것을 가공하여 controller에 전달하는 행위. 이때 각자의 역할과 책임을 무시해선 안된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드(hashCode)&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;AOP&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-2nd Weekly I Learn]]></title><description><![CDATA[FACT-O1. Spring 공부를 시작했고, 심화단계까지 강의를 마무리했다. FEELINGS 굉장히 간편했다. FINDINGS 인텔리제이 에디터가 gradle, database, tomcat…]]></description><link>https://mitoconcrete.github.io/22_12_2nd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_2nd/</guid><pubDate>Sun, 11 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. Spring 공부를 시작했고, 심화단계까지 강의를 마무리했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;굉장히 간편했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인텔리제이 에디터가 gradle, database, tomcat과 같은 많은 설정을 손쉽게 해주고 있었다.&lt;/li&gt;
&lt;li&gt;왜 스프링에 익숙해지면 자바의 기본문법을 잊어버린다는지 이해했다. 스프링이 정말 많은 것들을 자동으로 해주고, 그것을 보조하는 라이브러리들이 굉장히 잘되어 있었다.&lt;/li&gt;
&lt;li&gt;또한 오래된 프레임워크인 만큼 트렌드도 많이 변했고, 굉장히 많은 패턴과 철학들이 녹여져 있는 프레임워크라는 것을 느낄 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인텔리제이없이 개발을 못하는 개발자가 되지 않도록, 최대한 에디터에 종속되지 않도록 경계해야겠다.&lt;/li&gt;
&lt;li&gt;어차피 근본은 자바이다. 중요한 개념이나 오류들은 모두 자바의 근본적인 것에서 발생하는 것을 발견할 수 있었다. 자바를 지속적으로 학습해야겠다.&lt;/li&gt;
&lt;li&gt;프레임워크에 종속되어 암기해서 사용하기 보다는, 왜 이런 철학과 패턴이 생겼는지 이해하고 사용 할 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. 처음으로 기분좋은 코드리뷰를 당해보았다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;과거에는 감정을 건드는 코드리뷰만 당해보아서, 처음에 내 코드리뷰한다는 사실을 접했을 땐 두려웠다.&lt;/li&gt;
&lt;li&gt;리뷰가 끝나고 나서는 개발에 대한 의지가 충만해졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드리뷰도 어쨋던 개인의 생각과 생각의 충돌이기 때문에, 여태까지의 코드리뷰는 납득이 안되는 리뷰들이 많았고, 그것은 감정충돌로 이어졌다. 하지만, 생각이 다름에 대한 존중을 베이스에 깔고, 더 나은 방안을 납득할만한 이유와 함께 설명해주는 리뷰는 기분이 좋고, 상대로하여금 공부를 할 의지를 줄 수 있다는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;나도 과거에 내 방식을 밀어부쳤던 때가 있었는데, 나름대로 친절했다고는 생각했지만, 상대방으로 하여금 기분이 좋지않았겠다는 깨달음을 얻었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나도 다음부터 누군가에게 리뷰를 드릴때는 상대의 생각에 대한 존중을 기반으로 리뷰를 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;또한, 상대방이 납득할만한 이유가 있을 때 더 나은 방안과 함께 리뷰를 드리는게 그것을 설명하기 위해 공부하는 내입장에서도, 상대입장에서도 윈윈 할 수 있겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-03. 팀원들과 팀에 대한 토론을 나누었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음에는 고민을 혼자만 가지고 있는게 답답했지만, 이런 감정을 내비치는게 오히려 팀에 독이 될 것 같아서 숨기느라 힘들었다.&lt;/li&gt;
&lt;li&gt;다같이 좋은 결과에 이르기위해 토론하는 과정이 좋았고, 팀원들의 솔직한 생각을 느낄 수 있었고 위로받을 수 있어서 좋았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀이 앞으로 나가는데 도움이되는 고민이라면, 속으로 앓는 것 보단 표출하는 것이 팀을 더 건강하게 만들 수 있는 것이라는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;아무리 팀워크가 좋더라도 팀의 의지와 다른 한명의 존재가 얼마나 나머지 팀원들의 에너지를 뺏고 리소스를 뺏게 만드는지 여실하게 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;책에서 본 글귀인데, 가장좋은 팀원은 &apos;리더가 가장적은 신경과 시간을 쓰는 팀원&apos;이라고 한다. 내가 함께 일하고 싶은 개발자가 되기위해선, 우선적으로 다른 팀원의 신경이나 시간을 뺏는 문제아가 되지 않는게 우선이기에 그런 팀원이 되지 않아야겠다.&lt;/li&gt;
&lt;li&gt;대신 팀을 건강하게 만들고, 앞으로 나가는데 도움이 되는 의견은 서슴치 않고 뱉어내고 털어놔야겠다는 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-09 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 요구사항 수집/분석 -> 설계(개념적 -> 논리적 -> 물리적) -> DB 구현  : Entity간의 Relationship. 이 관계를 다이어그램으로 그린다. Entity의 Attribute…]]></description><link>https://mitoconcrete.github.io/22_12_09/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_09/</guid><pubDate>Fri, 09 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DB 설계순서&lt;/code&gt; : 요구사항 수집/분석 -&gt; 설계(개념적 -&gt; 논리적 -&gt; 물리적) -&gt; DB 구현&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ER모델&lt;/code&gt; : Entity간의 Relationship. 이 관계를 다이어그램으로 그린다. Entity의 Attribute들도 이때 정의해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;정규화&lt;/code&gt; : 중복데이터를 없애서 관계를 단순화 하는 과정.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;1차정규화&lt;/code&gt; : 원자성. 복수를 단수화 시켜 쪼갠다. 테이블의 데이터가 하나의 값을 갖도록 한다. ex) 추신수는 축구와 야구를 한다. -&gt; 추신수는 축구를 한다. 추신수는 야구를 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;2차정규화&lt;/code&gt; : 완전함수적종속(부분종속제거). PK를 2개 이상을 엮어서 만드는 경우, 테이블에서 어떤 데이터가 PK 2개중 1개에만 의존이 되어 있다면, 그것은 따로 분리하여 뗴어낸다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;3차정규화&lt;/code&gt; : 2차 정규화가 이뤄진 테이블에 대해 이행적 종속제거(A-&gt;B, B-&gt;C, A-&gt;C의 경우)를 한다. 이걸 그냥 두면, B를 바꿨을때 C까지 일일히 찾아서 변경해주어야한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;단방향관계&lt;/code&gt; : 두 엔티티가 관계를 맺을 때, 한쪽의 엔티티만 참조하고 있는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;양방향관계&lt;/code&gt; : 구 엔티티가 관계를 맺을 때, 양쪽이 서로를 참조하고 있는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;연관관계의 주인&lt;/code&gt; : 외래키를 저장하는 쪽이 주인이 된다. 외래키를 저장하는 쪽만이 CRUD할 수 있고, slave는 read만 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;return의 사용&lt;/code&gt; : return 을 사용시, 그 함수를 사용하는 곳에서는 해당 메서드에 대한 의존이 생긴다. 따라서, 특별한 상황이 없으면 void부터 시작하여, 필요 시 return 을 해주는 형식으로 리팩토링해주는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;li&gt;비즈니스 로직이란?&lt;/li&gt;
&lt;li&gt;파사드패턴&lt;/li&gt;
&lt;li&gt;AOP&lt;/li&gt;
&lt;li&gt;@RestCOntrollerAdvice&lt;/li&gt;
&lt;li&gt;HttpMessageConverter&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221209 : 더닝크루거 효과 (우매함의 봉우리를 넘어서)&lt;/h2&gt;
&lt;p&gt;더닝크루거 효과는 인지편향 중 하나로서, 능력없는 사람이 자신의 능력을 과대평가하고, 능력있는 사람이 자신의 능력을 과소평가하는 현상이다.
이 이론을 처음알게된 계기는 &lt;strong&gt;Peak of &quot;Mr. Stupid&quot;&lt;/strong&gt; 라는 개념이 인터넷에 밈처럼 돌아다니는 것을 보게 된 이후였다.&lt;/p&gt;
&lt;p&gt;어떤 지식을 학습하고 이해하는 속도가 나쁜편이 아니라고 생각했던시절이 있었다. 따라서, 개발지식을 처음 습득하고 적용 할 때, 내가 아는 것이 전부인 것처럼 행동했던 기억이 있다.
사실 기억보단, 처음 웹개발 기술을 습득했을 때, 자신감이 거의 하늘을 뚫고 나갈 기세였던 기억이 있다. 취직도 곧바로 되었으니.. 그냥 내가 평균이상은 한다고 자만했던 것 같다. 지나고보니.. 이 때가 우매함의 봉우리의 정점에 있던 순간인 것 같다.&lt;/p&gt;
&lt;p&gt;하지만, 이 생각은 여러 직장을 경험하면서 바뀌었다. 세상에 정말 많은 대단한 개발자들이 있다는 것을 깨닫고, 또 나와 같이 시작했거나 늦게 시작했지만, 나보다 더 많이 알고 개발에 대한 욕망이 많은 분들이 계시단 사실이 피부로 와닿게 되면서, 많이많이 겸손해진 것 같다. 지금은 거의 바닥에 깔려있는 수준이다..ㅋㅋ
우매함의 봉우리에 깃발을 꽂은 시절엔, &apos;내가 생각한게 맞아! 너의 생각을 틀렸어!&apos; 라는 태도로 다른 사람들이 다른의견을 주거나, 무슨 말을 했을 때 무조건 부정적으로 들렸다. 돌이켜보면, 시야가 정말정말정말 좁았다. 하지만, 겸손모드에 들어가면서 &apos;내 생각도 맞지만.. 네 의견도 맞아..&apos; 라는 태도로 변해서 이전보다는 많이 수용적이 된 것 같다.&lt;/p&gt;
&lt;p&gt;어제와 같은 맥락이지만, 블로그에 썼던 지식이 모두 내 지식인 것 처럼 행동하기 시작하면.. 우매함의 봉우리에 쉽게 도달한다. 개발이라는 영역은 정말많은 정보가 쏟아지고, 주워담을 것들이 굉장히 많은 영역이기 때문에, 손쉽게 우매함의 봉우리에 도달하기 쉬운 환경을 지니고 있다. 따라서, 항상 우매해지는 것, 자만하는 자세를 경계해야겠다. 또한, 경계하고 있는 만큼 제대로 된 정보들을 제대로 습득하여, 제대로된 정보를 온전히 습득한 것에 대한 자신감이 충만한 개발자가 되고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-08 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_08/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_08/</guid><pubDate>Thu, 08 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;무상태성&lt;/code&gt; : 서버와 클라이언트는 서로의 상태를 저장하지 않는다. 따라서, 동일한 유저가 요청을 해도 같은 사람인지 모른다. 이 때문에 동일인물임을 &lt;code class=&quot;language-text&quot;&gt;인증&lt;/code&gt;하고 &lt;code class=&quot;language-text&quot;&gt;인가&lt;/code&gt;하는 절차를 밟는 것이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;쿠키&lt;/code&gt; : 클라이언트에 저장되는 인증을 위한 간단한 정보. 주로 쿠키스토리지에 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;세션&lt;/code&gt; : 서버에서 클라이언트 식별을 위해 발급하는 ID. 주로 세션스토리지를 따로 두거나, DB에 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JWT(Json Web Token)&lt;/code&gt; : Json 형식의 데이터를 암호화하여 만든 인증/인가를 위한 토큰값이다. 서버에 비밀키를 저장해놓고, 그것을 이용하여 JWT를 생성하고, 디코딩한다. DB를 거치는 과정을 없애고 서버단에서 인증을 처리하는 것이기에, 네트워크 부하를 줄일 수 있다는 장점이 있다. 단, 비밀키가 유출되었을 때, 해킹의 위험성이 있고, 비밀키가 바뀐상황에서 바뀌기 이전에 발급된 토큰을 만료시킬 수 없다. 또한, 토큰에 담는 내용이 많아질수록 네트워크 비용이 증가한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@PostConstruct&lt;/code&gt; : DI이후 초기화를 수행하는 메서드를 따로 정의할 때 사용하는 애너테이션이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ModelAttribute&lt;/code&gt; : application/x-www-form-urlencoded 형식(key=value&amp;#x26;key=value)으로 보내진 데이터를 Spring 서버에서 Dto에 담아 받을 때 사용한다. 반드시 Setter를 설정해주어야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;li&gt;쿠키/세션/로컬 스토리지&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221208 : 보여주기 위한 공부는 하지않는 것보다 못하다(심미주의에서 효율주의로)&lt;/h2&gt;
&lt;p&gt;키워드 공부를 선택하게 된 계기는, 내가 공부했던 자료를 다시 읽기위해 선택하게 되었다. 과거에는 기술블로그를 남들이 보기좋은 형식으로, 사진과 그럴듯한 문장을 구사하며 썼었다.
처음에는 결과물을 보면 굉장히 뿌듯하여 지속해나갔지만, 프로젝트가 시작되면서 블로그는 또 하나의 과업처럼 되었다.&lt;/p&gt;
&lt;p&gt;문제는 그렇게 힘들게 적은 글을 다시 읽지 않는데서 발생하였다. 그렇게 적은글들은 잘못된 곳들이 많았지만, 수정을 하기 위해선 또 다른 자료수집을 해야했고, 그것을 이쁘게 포장하기 위한 사진을 수집해야했으며, 보이지 않는 구독자(?)들을 위해 알아듣기 쉽게 가공하여 적어야 하다보니, 과업이 또다른 과업을 낳는 악의 굴레가 지속되었다.&lt;/p&gt;
&lt;p&gt;많은 면접을 보면서 깨달았던것은, 면접관분들은 내 기술블로그에 어떤 기술이 이쁘고, 자세하고, 알아듣기쉽게 적혀있는가보단, 이 기술을 제대로 알고있는지, 어떤 경험을 했는지를 더 궁금해하셨다는 것이다. 당연한 사실인데, 그것을 깨닫기까지는 너무 오랜시간이 걸렸다. 기술블로그를 읽는 대상을 나로 정하고, 내가 몰랐었지만 알게된 것들만을 적기 시작했고, 그러다보니 블로그를 적는 것에 대한 부담이 많이 줄었다.&lt;/p&gt;
&lt;p&gt;그리고 길게 쓴 글들은 매번 보고 수정한다면 가치가 있겠지만, 주니어 레벨에서 공부하고 작성한 글은 그 깊이가 한정되어있다. 즉, 자주 들여다보고 자주 변경해주어야한다. 이런 측면에서는 구구절절 남들이 보기쉽게 적는것이 큰 메리트는 없을것이고, 신뢰도도 낮을 것 같다는 생각을 했다. 또, 이 개념을 면접에서 물어본다고 가정했을때 블로그에 적은 것 처럼 말할 자신은 더더욱 없었다.&lt;/p&gt;
&lt;p&gt;따라서, 키워드만 적게되면서 적는것에 대한 부담이 줄었고, 내가 공부한 것을 빠르게 리마인드 하는게 가능해졌다. 많은 사람들이 각자만의 기준이 있겠지만.. 나에게는 이 방법이 맞는 것 같다. 더이상 난 공부되지 않은 것을 공부되었다고 스스로 만족하기 싫어졌고, 그런 측면에서 블로그를 더이상 휘황찬란하게 적을 생각은 더더욱 없어졌다.&lt;/p&gt;
&lt;p&gt;하지만, 나중에 내가 정말 잘하는 시니어가 된다면, 네카라쿠배의 기술블로그들 처럼 이쁘고 잘꾸며졌지만, 신뢰높은정보를 전달하는 블로그를 작성해 볼 의향은 있다. 얼른 성장하자 햇병아리 주니어!!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-07 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_07/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_07/</guid><pubDate>Wed, 07 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;IOC(Inversion Of Control)&lt;/code&gt; : 의도적으로 프로그램의 흐름을 반대로 바꾸는 것. 보통은 작은것에서 큰것으로 올라가지만, 이 흐름을 반대로 바꾸면 상호 간 의존도가 낮아진다. 이미 잘 만들어진 객체를 가져와 사용할 수 있게 만드는 것이 대표적인 IOC패턴이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Bean&lt;/code&gt; : 스프링이 관리하는 객체. 스프링은 IOC Container를 두고, 스프링이 초기에 로딩 될 때 Bean들을 인스턴스화 하여 저장한다. Bean화 되는 대상은 특정어노테이션이 마킹된 모든 컴포넌트들이며, &lt;code class=&quot;language-text&quot;&gt;@ComponentScan&lt;/code&gt; 에 셋팅된 패키지 하위의 모든 마킹된 컴포넌트들이 Bean화가 된다. 스프링은 Bean 의 변수명 제일 앞자리를 소문자로 바꾸어준다. &lt;code class=&quot;language-text&quot;&gt;final&lt;/code&gt;로 선언해준 변수 중 일치하는 변수명이 있다면 스프링이 자동으로 DI를 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;IOC Container&lt;/code&gt; : Bean으로 선언된 인스턴스들이 모이는 공간.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Component&lt;/code&gt; : 클래스를 Bean으로 등록함.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@Bean&lt;/code&gt; : 객체를 직접 Bean으로 등록함. &lt;code class=&quot;language-text&quot;&gt;@Configuration&lt;/code&gt; 으로 마킹된 클래스의 내부에 위치한 Bean을 등록한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@AutoWeird&lt;/code&gt; : DI 주입 할 곳을 명시적으로 정의해주어, 이 애너테이션이 사용 된 곳은 IOC Container 에서 Bean을 꺼내 적절한 객체를 주입해준다. 스프링 4.3부터는 의무적으로 적어줄 필요가 없다. 하지만, 생성자가 오버로딩 된 경우에는 반드시 선언해주어야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@RequiredArgsContructor&lt;/code&gt; : final로 선언된 변수를 가져와 자동으로 DI해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ApplicationContext&lt;/code&gt; : Bean 을 수동으로 꺼내어 사용가능하게 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JpaRepository&lt;/code&gt; : 이것을 인터페이스에 사용해줌으로서, Spring Data JPA가 @Repository를 붙혀서, 기본적인 CRUD는 물론 DB연결 및 닫기까지 알아서 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;스프링 프레임워크&lt;/code&gt; : 정해진 형식과 틀이 있다. 따라서, 데이터의 신뢰성, 서버유지에 대한 안정성, 대량의 데이터를 똑같은 기준으로 관리가 가능해진다. 이는 대규모데이터를 다루기 유용하게 만들어주었다. 스프링은 기업용 어플리케이션을 만드는게 적합하며, 많은 반복로직으로 인해 실수가 잦은 컨트롤러, 레파지토리를 쉽게 작성해주고, 비즈니스로에 집중할 수 있게 돕는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;스프링 시큐리티&lt;/code&gt; : 스프링에서 인증과 인가를 처리해주는 툴&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;인증(Authentication)&lt;/code&gt; : 실제 유저가 맞는지 검증하는 절차. 쿠키-세션방식 JWT Token 방식이 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;인가(Authorization)&lt;/code&gt; : 유저가 접근 권한이 있는지 확인하는 절차.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;비연결성&lt;/code&gt; : 클라이언트-서버는 연결되어 있지 않다. 서버는 클라이언트의 요청으로 동작한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;무상태성&lt;/code&gt; : 서버는 클라이언트의 상태를 저장하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;li&gt;jpa - mybatis 의 차이&lt;/li&gt;
&lt;li&gt;orm - mapper 의 차이&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221207 : 앞으로 나아가는 방법&lt;/h2&gt;
&lt;p&gt;공부/업무를 하다보면 도무지 앞으로 진도가 나가지 않는 순간이 온다.
개발이 디깅(Digging)을 하기 딱 좋은 영역이다보니, 자주 하얗게 불태우는 순간을 마주하곤한다. 하지만, 계속 파고들다보면 디깅을 시작한 원인도 망각하고 아까운 시간만을 태우고 있는 나 자신을 보곤한다.&lt;/p&gt;
&lt;p&gt;나혼자 공부 할 땐.. 그냥 그렇게 해도 무관했지만, 어떤 마감기한이 정해져 있거나 같이하는 업무를 진행 할 땐, 이 버릇이 정말 좋지않다. 야근의 원인이 되는 가장 좋은 습관이다. 또한, 이는 회사에서 팀원들을 나로인해 지체하게 만드는 원인 중에 하나였다.&lt;/p&gt;
&lt;p&gt;처음엔 &apos;내가 일을 못하는 건가&apos; 싶었는데, 일을 하다보니 &apos;시간을 잘 쓰는 방법&apos;을 몰라서 이런 상황들이 벌어졌다. 정말 별거 없지만.. 조금이라도 시간을 지체하는 것에 대해서 헤어나오기 위해서 내가 선택한 방법은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;디깅을 하기 시작하면, 디깅을 한 목적을 명확히해라 : 목적이 명확해지면, 지금 나에게 필요한 정보와 필요하지 않은 정보를 구분 할 수 있게되어 손쉽게 빠져나올 수 있다.&lt;/li&gt;
&lt;li&gt;중요도 정하기 : 지금 내가 하고 있는 일이 시간만 때우고, 크게 중요한 일이 아니라면 간단한 일이라도 우선순위가 높은 업무부터 해치우는 것이 낫다.&lt;/li&gt;
&lt;li&gt;미련없이 버리기 : 중요도와 목표가 정해졌다면, 앞으로 나가기만 하면된다. 목표에 부합하지 않는 것은 ?가 생기더라도 미련없이 스킵하고 지나간다.&lt;/li&gt;
&lt;li&gt;버린것은 기억하기 : 버린것은 그냥 지나치기보다, 따로 기록해놓았다가 시간이 날 때나, 지장이 없는 시점에 리서치한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러다보니 T자로 디깅하는 스킬이 많이 줄었긴했지만.. 이제부터 디깅하는 스킬을 키우면 된다고 생각하고 있다. 앞으로 나가는 방법에 익숙해졌으니, 이제 효율적으로 디깅하는 기준을 만들어 봐야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-06 Today I Learn]]></title><description><![CDATA[TodayKeywords…]]></description><link>https://mitoconcrete.github.io/22_12_06/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_06/</guid><pubDate>Tue, 06 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DI(Dependency Injection)&lt;/code&gt; : 인스턴스 내에서 인스턴스를 선언하는 것은, 의존관계를 가지도록 만든다. 인터페이스 혹은 타입으로 정의해두고, 그걸 생성자를 통해 받아와서 사용하여, 의존관계를 줄이는 것을 의존성 주입이라고 한다. 즉, 의존성을 외부에서 받아와 주입하는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JPA&lt;/code&gt; : JPA내부에 JDBC API가 포함되어 있음. 따라서, 둘을 모두 인스톨하지 않아도 된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Spring Data JPA&lt;/code&gt; : JPA를 Wrapping 하여 방언에 맞게 사용하도록 한 것.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;영속성 컨텍스트&lt;/code&gt; : 엔티티를 영구저장하는 환경. DB에서 꺼내온 객체를 저장하며, 엔티티 매니저마다 이 공간을 개별적으로 가진다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DirtyChecking&lt;/code&gt; : 엔티티 조회시점의 데이터를 스냅샷으로 저장하여, 새로이 수정된 엔티티와 비교하여, 변경된 부분에 대해 필요한 쿼리만 DB에 요청하도록 하는 방법.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;엔티티 주의사항&lt;/code&gt; : final 불가, interface, enum 은 일단제외. final은 저장이 안된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;엔티티간의 일대다관계&lt;/code&gt; : mapped 를 통해 명시하며, 연관관계의 주인에 의해 외래키(FK) 가 관리된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;엔티티 지연로딩&lt;/code&gt;: 엔티티간에 종속된 모든 데이터를 불러오게 되면, 불필요한 데이터들 까지 불러오게 된다. 지연로딩을 통해 모든쿼리가 종료될 때 까지, 데이터베이스 접근을 금지한다. 이 때, Proxy 객체를 통해 가상의 엔티티를 사용할 수 있게 만든다. 프록시는 getReference를 이용하여 가져온다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;엔티티 즉시로딩 :&lt;/code&gt; 1대 1 연결이 되거나, 단일 정보를 연결한 엔티티는 즉시로딩하여도 무관하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;영속성 전이&lt;/code&gt; : 한 객체가 영속성 컨텐스트 안에 들어갔을 경우, 해당 객체에 연결된 다른 객체들도 영속성 컨텐스트에 올라갈 수 있도록 하는 것이 가능하다. 이것을 CASCADE 로서 컨트롤 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;IOC&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;li&gt;준 영속성&lt;/li&gt;
&lt;li&gt;지연로딩&lt;/li&gt;
&lt;li&gt;프록시객체&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221206 : 벼는 익을 수록 고개를 숙인다. 프론트맨이 되려고 하지말자.&lt;/h2&gt;
&lt;p&gt;속도가 빠른 것 보단, 제대로 아는 것이 중요하다. 속도가 빠른 것과 제대로 아는 것은 다른 것이다.
내가 남들보다 조금 더 안다고해서 스스로 뿌듯함을 가질 필요는 없다. 언젠가 모두가 알 수 있는 정보를 가지고 있는 것은, 큰 메리트가 되지 못한다.
단, 제대로 아는것은 큰 메리트가 된다. 또한 영구적으로 기억에 남는것은 제대로 공부한 것 들이다.
다른 사람이 손을 뻗기 전까지, 먼저 다가가는 것은 상대방으로 하여금 불쾌감을 줄 수 있다. 도움을 청할 때, 도움을 청한 것에만 집중하여 대답하자.
제발 하고싶은 모든 말을 뱉는 행위를 멈추자. 제발 필요한 말만 하여, 듣는 사람으로 하여금 불안함, 지루함을 느끼지 않도록 신경쓰자.&lt;/p&gt;
&lt;p&gt;듣기싫은 말을 듣는 상대는 그 말이 가치있는 말이라도 듣지 않는다. 겸손하지 않은 상대는 천재가 아닌이상 쓸모가 없어지는 순간이 오며, 그 순간에 오는 외로움은 나의 몫이다. 벼는 익을 수록 고개를 숙인다. 모닥불 개발자는 나를 뽐내기 위해 쓸모없는 재료까지 끌어모아 몸집을 불리는 행위를 하지 않는다. 조용히 그리고 묵묵히 자신의 길을 나아간다. 나의 지식을 자랑하기 위한 목적이 아닌, 듣는상대의 공감을 얻어내고 진심으로 대화 할 수 있는 사람이 되자. 나의 목표는 같이 일하고 싶은 사람이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-05 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 양간의 경계면/접점  : HTTP의 접점에 있는 계층. 요청 처리 및 렌더링을 담당.  : 유효성 검사 및 계산을 담당.  : DAO 계층  : DB…]]></description><link>https://mitoconcrete.github.io/22_12_05/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_05/</guid><pubDate>Mon, 05 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Interface&lt;/code&gt; : 양간의 경계면/접점&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Controllor&lt;/code&gt; : HTTP의 접점에 있는 계층. 요청 처리 및 렌더링을 담당.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Service(Domain)&lt;/code&gt; : 유효성 검사 및 계산을 담당.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Repository&lt;/code&gt; : DAO 계층&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DAO(Data Access Object)&lt;/code&gt; : DB에 접근가능 한 객체&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DTO(Data Transfer Object)&lt;/code&gt; : 계층 간 데이터를 교환하기 위한 객체, 순수하게 get, set만 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Spring&lt;/code&gt; : 계층 간 분리를 통해 조금더 개발자가 Service(Domain) 단의 개발에 집중 할 수 있도록 함.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DBMS(DataBase Management System)&lt;/code&gt; : DB를 관리하고 운영하는 소프트웨어&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DDL(Data Definition Language)&lt;/code&gt; : 데이터를 정의하는 언어. CREATE, ALTER, DROP, TRUNCATE&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DCL(Data Contorl Language)&lt;/code&gt; : 접근권한을 정의하는 언어. REVOKE, GRANT&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DML(Data Manipulation Language)&lt;/code&gt;: 데이터의 CRUD에 대한 것. CREATE, SELECT, UPDATE, DELETE&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JDBC(Java DataBase Connectivity)&lt;/code&gt; : Java로 데이터베이스 연결을 가능하도록 만들어주는 API&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JPA(Java Persistence API)&lt;/code&gt; : Java ORM 기술에 대한 표준명세&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;영속성 컨텍스트&lt;/code&gt; : JPA를 사용하게 되면, 어플리케이션과 DB사이에 영속성을 관리하기 위한 엔티티임시저장소가 생긴다. 이를 영속성 컨텐스트라고 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;엔티티의 생명주기&lt;/code&gt; : 비영속상태/ 영속상태/ 준영속상태/ 삭제상태&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@PathVariable&lt;/code&gt; : { } 내에 전달되는 매개변수를 전달받기 위한 어노테이션. 생략불가&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@RequestParam&lt;/code&gt; : request params 형식으로 주소를 통해 전달되는 인자를 받아오기 위한 어노테이션으로. 생략가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@ModelAttribute&lt;/code&gt; : request body 를 통해 전달된 값을 곧바로 클래스로 받아서 사용가능하도록 만드는 어노테이션. 생략가능하며, 전달받는 클래스에는 세터가 있어야한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;@RequestBody&lt;/code&gt; : request body 를 통해 전달되는 json 값이 mapping된다. 생략불가하며, 전달받는 클래스에는 세터가 있어야한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JPA Auditing&lt;/code&gt; : @EnableJpaAuditing 어노테이션으로 구현가능하며, &lt;code class=&quot;language-text&quot;&gt;감시하다&lt;/code&gt;의 의미를 지닌다. Entity의 생성수정시 그 시간을 자동으로 기록하고 저장해준다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JPA 방언(Dialect)&lt;/code&gt; : JPA가 어떤 DBMS의 SQL를 사용하고 있는지 인식하도록 셋팅하는 것이다. 셋팅되면, 그에 맞는 Dialect 추상클래스를 가져와 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;li&gt;DI&lt;/li&gt;
&lt;li&gt;IOC&lt;/li&gt;
&lt;li&gt;스프링 설계철학&lt;/li&gt;
&lt;li&gt;RESTful&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221205 : 선택과 집중을 잘해야하는 시기&lt;/h2&gt;
&lt;p&gt;새로운 프레임워크를 학습하기 시작했다. 스프링은 생각보다 잘 갖춰진 프레임워크 같았다. 마치 장고처럼!&lt;br&gt;
과거의 경험을 토대로 생각해보면, 이런 프레임워크는 정해진 틀을 벗어나려고 하다보면 그 때부터 러닝커브가 시작된다. 또한, 스프링을 자주쓰다보면 자바를 잊어버리는 이상한 상황이 발생하는데, 그 점을 항상 경계해야겠다.&lt;/p&gt;
&lt;p&gt;스프링하면서 신경써야할 것들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바를 잃지 않기 : 어차피 JVM에서 돌아가는것이고, 근본은 자바이다. 따라서, 자바언어를 잊어버리면 근본적인 문제를 해결 할 수 없다.&lt;/li&gt;
&lt;li&gt;스프링, JPA, JDBC, Lombok 간의 관계를 정확히 파악하기 : 스프링은 프레임워크인데 그 안에 JPA, JDBC, Lombok를 이용한 것인지, 스프링 그자체로 할 수 있는 것은 어디까지인지 정확히 파악해야한다.&lt;/li&gt;
&lt;li&gt;특정 에디터에 종속되는 것을 경계하기 : 인텔리제이는 좋은 에디터이고, 자동완성이 정말 잘되있다. 또한 톰캣도 알아서 띄워준다. 하지만, 언제나 유료버전을 사용 할 순 없다. 인테리제이없이도 스프링을 돌릴 수 있도록 하자. (아마 build.gradle을 작성하는 능력일 듯)&lt;/li&gt;
&lt;li&gt;왜 이렇게 사용하는지 의심하기 : 그냥 아무런 생각없이 사용만 하면, 툴키디가 된다. 왜 굳이 이런선택을 해야했는지 의심하고 리서치해보며 개발하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;나는 취업준비/면접준비를 병행하며 학습을 하는 만큼 그에 맞게 학습을 해야한다. 따라서, 위를 꼭 기억하며 스프링을 학습하려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-1th Weekly I Learn]]></title><description><![CDATA[FACT-O1. 다른 조 팀원분들이 우리조의 코드를 참고했다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/22_12_1st/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_1st/</guid><pubDate>Sat, 03 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. 다른 조 팀원분들이 우리조의 코드를 참고했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;뿌듯했다. 설계토론의 결실을 다른 분들이 알아주시는 것 같아서 기분이 좋았다.&lt;/li&gt;
&lt;li&gt;어떤 태도로 반응을 해야지, 나와 팀, 듣는 상대방 모두 기분좋게 만들 수 있을지 몰라서 겸손한 자세를 유지했는데, 뭔가 찝찝했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커뮤니케이션 스킬이 부족하다는 생각을 했다. 뭔가 모두가 기분좋게 될 수 있는 대답을 충분히 할 수 있을 것 같은데 나와 팀 그리고 상대방모두 뭔가 찝찝하게 대화가 마무리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 일을 잘 마무리하고, 칭찬을 들었을 때 어떻게 응답을 해야 모두가 존중받는 기분을 받을 수 있을지, 고민해봐야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O2. Java의 심화개념에 대해 학습하고, 디깅했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디깅의 깊이가 정해져있지 않고, 계속 쌓이기만 하니 감당이 되지 않았다.&lt;/li&gt;
&lt;li&gt;진도가 팍팍나가지 않아 공부가 지루하게 느껴지는 순간이 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디깅은 나와 맞지 않는 학습법이라는 것을 깨달았다.&lt;/li&gt;
&lt;li&gt;하지만, 어떤 새로운 키워드를 마주했을 때 설레는 감정을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;키워드와 그에해당되는 짧은 한줄만을 기록하는 방식으로 변경했다. 디깅한 지식은 내머릿속에 담아 놓던가 하고, 지속적으로 리마인드 하는 방식으로 변경해보기로 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-O3. 내가 무엇을 모르는지 모르는 상태를 경험했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;갑갑했다.&lt;/li&gt;
&lt;li&gt;뭔가 아는것들은 있는데, 다음 학습을 나가려고하니 찝찝한게 계속 있어서 의미없이 책만 읽었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 개념들을 잇는 선수지식을 모를 때 이런 상황이 발생함을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동일 상황 발생 시, 어떤 개념에 대해서 알고, 어떤 개념에 대해서 모르는지 구분하고, 마냥 막막한 상태로 책만 파는 것보다, 각각의 개념을 잇기 위해서 가장 필요한 개념이 무엇인지 고민하고, 그것을 공부하는 방식으로 바꿔야겠다고 생각했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-02 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드  : 하나의 코어가 수행하는 명령어 단위. 1개의 코어는…]]></description><link>https://mitoconcrete.github.io/22_12_02/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_02/</guid><pubDate>Fri, 02 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;하드웨어적 스레드&lt;/code&gt; : 하나의 코어가 수행하는 명령어 단위. 1개의 코어는 1개의 명령어를 수행할 수 있다. 내부에 명령어 레지스터가 여러개 존재하면, 여러개의 명령어를 수행 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;소프트웨어적 스레드&lt;/code&gt; : 하나의 프로그램을 실행하는 중에 생기는 실행단위&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;프로세스&lt;/code&gt; : CPU로 부터 자원을 할당받아 메모리에 프로그램을 올리는 것. 커널단에 PCB를 만들고, Code, Data, Heap, Stack 영역을 만들어 사용자 영역 메모리에 올린다. Heap과 Stack 영역은 프로세스에 따라 가변적으로 설정된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;멀티프로세스&lt;/code&gt; : 1개의 프로그램을 여러개의 프로세스로 관리하는 것. 각각의 PID가 생겨 독립적으로 동작한다. 각각의 영역을 공유하지 않기 때문에, 전환 시 Context Switching이 발생하고 이는 리소스를 잡아먹는다. 다만, 1개의 프로세스가 손상이 되도 전체 프로세스에 큰 영향을 미치지않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;스레드&lt;/code&gt; : 1개의 프로세스 내에 최소 1개이상 생기는 실행단위.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;멀티스레드&lt;/code&gt; : Code, Data, Heap 영역을 공유하고, 스레드별로 자신의 Stack을 가진다. 한 프로세스 내에 있기 때문에, Context Switching에 대해 안전하다. 하지만, 1개의 스레드에서 문제가 생길경우, 프로세스에 모두 문제가 발생한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;스레드 경합&lt;/code&gt; : Code, Data, Heap 영역을 공유하기에, 같은 타이밍에 같은 데이터의 수정을 할 경우, 데이터의 무결성이 손상될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;무결성&lt;/code&gt; : 데이터가 항상 일관적이고 정확한 상태를 유지하는 것.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;동시성&lt;/code&gt; : 한개의 코어가 여러가지일을 처리하기 위해, 시분할로 스케쥴링을 하여 동시에 동작하는 것 처럼 보이게 하는것.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;병렬성&lt;/code&gt; : 여러개의 코어가 여러가지일을 처리하기 위해, 일을 나누어 실제로 동시에 여러일을 처리하는 것.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;li&gt;OSI 7 계층&lt;/li&gt;
&lt;li&gt;PCB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[221203] 회고 : 내가 뭘모르는지를 모를때&lt;/h2&gt;
&lt;p&gt;컴퓨터란 분야는 파고들기 참 좋은 분야이다. A라는 개념은 B에서 파생되고, B라는 개념은 C에서 파생되고, 이렇게 꼬리에 꼬리를 물며 들어가는 것이 가능한 영역이다. 따라서, 면접질문도 이렇게 나온다.&lt;/p&gt;
&lt;p&gt;하지만, 독립적으로 학습도 가능하다. A -&gt; B -&gt; C 순으로 공부를 해야한다고 생각했을 때, B를 굳이 알지 못하더라도 A,C는 독립적인 개념이기 때문에 학습은 가능하다. 중간개념을 모르기에 찝찝한것이 생긴다. 그래서 기존에 알고있는 A와 C를 깊게판다. 하지만, 이것은 A를 깊게파거나 C를 깊게판다고 해결되는 문제가 아니다. B를 학습해야한다.&lt;/p&gt;
&lt;p&gt;하지만, 그 B가 뭔지를 모를경우엔 A, C 만 깊이 들어가게 된다. 얻는것은 아무것도 없다.&lt;/p&gt;
&lt;p&gt;오늘 자바의 멀티스레드를 이용하는 기술을 학습했다. 그리고 나는 멀티코어도 학습했다. 자바를 이용해 돌아가는 프로세스는 멀티스레드를 이용해서 운용하는게 가능하다. 나는 문득 궁금해졌다. 그럼 내가 자바프로그램을 실행하고, 크롬을 틀고, 메모장을 열어서 동시에 이용하는것은 멀티스레드로 인해 가능한 건가..? 멀티프로세스로 인해 가능한 것인가..?&lt;/p&gt;
&lt;p&gt;일단, 잘못된 접근이었다. 위에서 배운 멀티스레드나 멀티프로세스는 한 프로그램을 실행 할 때에 대한 이론이고 내가 궁금한건 os의 스케쥴링과 더 관계있는 것이다.
또한, 코어에서 연산을 하는 것은 하나의 프로그램이라는 고정관념이 있는데, 하나의 명령어를 실행할 수 있는 것이지, 그게 꼭 하나의 프로그램에 국한되는 것은 아니다. OS의 스케쥴링에 따라 서로다른 프로그램에 대한 연산이 수행 될 수도 있는것이다. 이처럼 멀티코어 / 멀티스레드+프로세스에 대한 각각의 지식은 있지만, 그 사이의 지식에 인과 관계가 맺어지지 않다보니, 납득이 안되는 상황이 발생했다.&lt;/p&gt;
&lt;p&gt;이런 경우를 난 &lt;em&gt;&apos;뭔가를 모르는데, 뭘 모르는지를 모를때&apos;&lt;/em&gt; 의 상태라고 정의하기로 했다. 오늘 거의 내가 뭘 모르는 건지 납득하기 위해 많은 시간을 보냈다.&lt;/p&gt;
&lt;p&gt;이런 상태가 되면 각 개념에 대해서 깊이 들어가는 것보단, 인과관계에 대해서 찾아보는 것이 가장 문제를 해결에 가까워 질 수 있는 방법인 것 같다.
그래도 코어와 실행단위를 구분지어서 이 사이에 내가모르는 무언가가 있다는 것을 인지하고 나니, &lt;em&gt;내가 무언가를 모르는지 아는 상태&lt;/em&gt;가 된 것 같다.&lt;/p&gt;
&lt;p&gt;넣어야하는 지식이 많은 분야인 만큼 효율적으로 공부하여 빠르게 지식을 쌓고, 중간중간의 비어있는 영역을 빠르게 인지하고, 빠르게 채워나가야겠다는 생각을 했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-12-01 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드 call by value : 인자로 넘어온 값을 복사하여, 새로운 주소를 가진 지역변수로 사용하는것. 데이터 원본에 영향을 주지않음. call by reference…]]></description><link>https://mitoconcrete.github.io/22_12_01/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_12_01/</guid><pubDate>Thu, 01 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;call by value : 인자로 넘어온 값을 복사하여, 새로운 주소를 가진 지역변수로 사용하는것. 데이터 원본에 영향을 주지않음.&lt;/li&gt;
&lt;li&gt;call by reference : 인자로 넘어온 주소값을 참조하여, 기존의 값에 영향을 주는 것. 데이터 원본에 영향을 준다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;default method support : 자바 8부터 유지보수를 위해 인터페이스에도 몸통이 있는 기본메서드를 추가할 수 있게됨.&lt;/li&gt;
&lt;li&gt;같은 이름을 가진 메소드가 있다면, 상속받는 클래스는 오버라이딩을 강제한다.&lt;/li&gt;
&lt;li&gt;public static final : 인터페이스 내에 선언되는 멤버변수에 암묵적으로 붙는다.&lt;/li&gt;
&lt;li&gt;public : 인터페이스 내에 선언되는 메서드에 암묵적으로 붙는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;has-a : 포함관계로 인터페이스는 이런 관계일 때 사용하면 된다.&lt;/li&gt;
&lt;li&gt;is-a : 상속관계로서 추상클래스는 이런 관계일 때 사용하면 된다.&lt;/li&gt;
&lt;li&gt;상속되는 것이나 구현되는 클래스나 인스턴스는 그것을 상속받는 클래스에 &lt;strong&gt;의해&lt;/strong&gt; 구현되는 것이다. 따라서, 상위개념이다.&lt;/li&gt;
&lt;li&gt;Casting : 명시적 형변환&lt;/li&gt;
&lt;li&gt;Promotion : 묵시적 형변환&lt;/li&gt;
&lt;li&gt;Dynamic dispatch : 참조변수형을 부모로 선언하고, 자식을 인스턴스로 선언했을 경우, 선언한 인스턴스의 오버라이딩된 메서드를 런타임에 동적으로 찾아가는 것.&lt;/li&gt;
&lt;li&gt;Functional interface : 인터페이스에 하나의 메서드만 사용된 형태. 2개이상 바로 에러발생함. &lt;code class=&quot;language-text&quot;&gt;@FunctionalInterface&lt;/code&gt; 키워드 사용&lt;/li&gt;
&lt;li&gt;람다 : 익명객체, Functional instance를 이용하여 구현가능함.&lt;/li&gt;
&lt;li&gt;스트림 : 배열에서 흐름을 만들어내어 처리하는 것. 여러개의 중개연산과 1개의 종료연산으로 구성되며, 원본데이터를 변환시키지 않는다. 1개의 스트림은 종료되면, 더이상 생성되지 않는다. 스트림을 너무 많이 연결하면, 중간에 NPE가 발생할 경우 발생위치를 찾기 어려워진다. 따라서, 사용에 주의해야한다.&lt;/li&gt;
&lt;li&gt;Null Point Exception : null 내부에 메서드가 없는데, 그것을 사용하려고 할 때 발생시키는 오류. null은 의미하는바가 매우 모호하기 때문에, 다양한 파생에러를 발생시킬 수 있으며, 따라서 null을 return 하지않는다.&lt;/li&gt;
&lt;li&gt;Optional : Java 8 부터 적용된 null을 제어 할 수 있는 객체. 인자로 들어온 값이 null 일 때 다른 값을 리턴하거나, exception 을 동작시키는 등의 처리가 가능하다. 주로, 메소드 리턴타입으로 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeyworks] Study Queue&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;HOF&lt;/li&gt;
&lt;li&gt;자바 해시코드&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221201 : 경청하는 연습. 필요한것만 말하는 연습&lt;/h2&gt;
&lt;p&gt;뱉고나서 후회하는 경우가 많다. 도움이 필요하지 않은 상대에게 원치않는 도움을 주려고 하는것은, 나에게는 선의겠지만 다른사람에겐 부담일 수 있다.&lt;/p&gt;
&lt;p&gt;말은 중요하다. 뱉으면 주워담기 힘들다. 따라서, 도움을 줄 때, 많은 것을 생각하고 도움을 줘야한다. 또, 내가 상대를 존중하지 않는 언어를 사용했는지, 기분을 상하게 하진 않았는지, 내 말이 나에게 도움이 되는것인지 상대방에게 진정으로 도움을 주는 것인지 생각하고 뱉어야한다.&lt;/p&gt;
&lt;p&gt;상대방이 나에게 도움을 요청하지 않았다고 서운해 할 필요는 없다. 그것은 그 상대가 성장하고 있는 증거이다. 또한, 나는 누군가에게 도움을 줄 만한 정도가 아니란것을 스스로 자각하며, 항상 겸손하게 생각해야한다.&lt;/p&gt;
&lt;p&gt;필요한 것만 말하고, 상대방이 필요한 것이 무엇인지 정확히 알기위해, 말을 끊지 않고 경청하는 습관을 들여야한다.&lt;/p&gt;
&lt;p&gt;함께 일하고 싶은 사람이 되자!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-30 Today I Learn]]></title><description><![CDATA[TodayKeywords 오늘 공부한 키워드 WORA : Write Once Run Anywhere Dynamic Class Loading : 컴파일 시점이 아닌 런타임시점에 클래스를 로딩하는 것. JVM Class loader System…]]></description><link>https://mitoconcrete.github.io/22_11_30/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_30/</guid><pubDate>Wed, 30 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[TodayKeywords] 오늘 공부한 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;WORA : Write Once Run Anywhere&lt;/li&gt;
&lt;li&gt;Dynamic Class Loading : 컴파일 시점이 아닌 런타임시점에 클래스를 로딩하는 것.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JVM&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Class loader System : 아직 메소드 영역에 로드되지 않은 &lt;code class=&quot;language-text&quot;&gt;.class&lt;/code&gt; 파일을 &lt;code class=&quot;language-text&quot;&gt;Method Area&lt;/code&gt; 에 load시키기 위한 시스템.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Loading : JVM 메소드 영역에 로드&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BootStrap ClassLoader : 모든 ClassLoader의 부모이며, 하위 2개의 ClassLoader에서 탑재되지 않은 Class들을 로딩한다.&lt;/li&gt;
&lt;li&gt;Extension ClassLoader : &lt;code class=&quot;language-text&quot;&gt;jre/lib&lt;/code&gt; 내에 위치한 클래스들을 로딩한다.&lt;/li&gt;
&lt;li&gt;Application ClassLoader : 개발자가 작성한 코드에서 사용된 클래스를 로딩한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linking : 주소 연결&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verification : &lt;code class=&quot;language-text&quot;&gt;.class&lt;/code&gt; 파일의 유효성을 검증한다.&lt;/li&gt;
&lt;li&gt;Preparation : 클래스 내의 메서드와 멤버변수들을 각 타입의 초기값으로 초기화 한다. 아직, 올리진 않는다.&lt;/li&gt;
&lt;li&gt;Resolution : Symbolic reference 를 direct referect로 변경하여 실제 참조주소의 클래스를 사용할 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;Symbolic reference : 클래스의 참조주소를 실제 메모리주소가 아니라, 어떤 심볼텍스트로 정의한것.&lt;/li&gt;
&lt;li&gt;direct reference : 클래스를 메소드 영역에 올리고, 해당 실제주소를 할당하는 것.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Initialization : 클래스에 개발자가 static의 초기값으로 정의한 값들이 실제로 초기화 되는 영역. 이 영역이 끝나면, 클래스는 초기화할 준비를 마침. 이 영역에서 static초기화 블럭이 실행됨.&lt;/li&gt;
&lt;li&gt;RunTime Data Area : 검증을 마친 &lt;code class=&quot;language-text&quot;&gt;.class&lt;/code&gt;파일이 실제 메모리에 올라가 구동되는 영역.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 영역 : Runtime Data Area 내의 모든 스레드에서 접근이 가능한 영역&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Method Area : 클래스들의 정보가 저장되는 곳. runtime constant pool(런타임 상수 풀), file data(필드 데이터), method data(메서드 데이터), constructor(생성자) 가 저장됨.&lt;/li&gt;
&lt;li&gt;Constant Pool : 실제 메모리주소를 찾을 때 사용하는 테이블. 초기에는 symbolic reference들이 대부분이지만, 코드가 진행되면서 Linking을 통해 대부분 direct reference로 변경됨.&lt;/li&gt;
&lt;li&gt;Byte-code : 개발자가 작성한 코드의 진행을 어셈블리 언어로 표현해 둔 것. 명령어와 Constant pool 주소로 구성된다.&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;li&gt;new 키워드를 통해 인스턴스화 된 객체가 들어가는 공간, static을 제외한 나머지 멤버변수, 메서드들이 사용되는 상태가 된다.&lt;/li&gt;
&lt;li&gt;GC가 이곳에서 동작하면서, 불필요한 인스턴스를 제거하면서 메모리를 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;분리 영역&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stack : 메소드가 차례대로 실행될 수 있게 만들어줌.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack frame : 메소드 단위로 생성되는 레이어&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operand stack : Contant pool 에서 정의한 명령어에 따라 실행되는 명령어들이 쌓이는 곳. 들어갔다 나올때 실행된다.&lt;/li&gt;
&lt;li&gt;Constant pool reference : Contant pool 에서 정의한 명령어&lt;/li&gt;
&lt;li&gt;Local variable Array : 지역변수로 선언한 것들이 배열형태로 저장됨. 0번째는 무조건 this나 super.&lt;/li&gt;
&lt;li&gt;PC register : 스레드 별로 어떤 동작을 했는지 순서를 저장하는 공간&lt;/li&gt;
&lt;li&gt;Native method stack : C, C++로 작성된 메서드가 저장되는 공간.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execution area : &lt;code class=&quot;language-text&quot;&gt;.class&lt;/code&gt;를 실제로 실행하는 영역&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interpreter : 바이트 코드를 런타임시 한줄한줄 곧바로 바이너리 코드로 번역하여, OS에게 명령을 내림&lt;/li&gt;
&lt;li&gt;JIT Compiler : 바이트 코드를 분석하여, 중복되는 영역을 미리 바이너리 코드로 번역해놓고 캐싱하여 재사용 시 소모되는 리소스를 줄이기 위해 사용하는 컴파일러이다.&lt;/li&gt;
&lt;li&gt;Garbage Collector : Heap 영역에 메모리가 찰 경우, 자동으로 비워주어 메모리 영역을 관리해주는 기능을 한다. 최근에는 Constanct pool 에도 GC가 적용된다고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JNI(Java Native Interface)&lt;/li&gt;
&lt;li&gt;C, C++, 어셈블리로 작성된 함수를 사용할 수 있는 방법 제공.&lt;/li&gt;
&lt;li&gt;자바에서 기본으로 제공되는 메서드에 &lt;strong&gt;native&lt;/strong&gt; 키워드를 가 붙은 친구.&lt;/li&gt;
&lt;li&gt;네이티브 메소드 라이브러리.&lt;/li&gt;
&lt;li&gt;C, C++로 작성된 라이브러리.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;psvm : Public static void main(String args[]) : String args[] 를 인자로 받는 main 메서드 만을 Entry point로 삼을 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[NextKeywords] 공부할 키워드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NPL&lt;/li&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;Optional&lt;/li&gt;
&lt;li&gt;loop label&lt;/li&gt;
&lt;li&gt;call by referrence&lt;/li&gt;
&lt;li&gt;call by value&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;파일입출력&lt;/li&gt;
&lt;li&gt;UML&lt;/li&gt;
&lt;li&gt;다이나믹 디스패치&lt;/li&gt;
&lt;li&gt;UTC&lt;/li&gt;
&lt;li&gt;epoch time / Instant time&lt;/li&gt;
&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;URL ClassLoader&lt;/li&gt;
&lt;li&gt;Secure ClassLoader&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221130 : 새로운 것을 받아들이는 걸 거부하지 않기.(키워드 학습의 시작)&lt;/h2&gt;
&lt;p&gt;오늘은 JVM에 대해 학습했다. 역시나 메모리로 들어가니, 어질어질하고 배워야할 것들이 쏟아졌다. 또한, 배우는 개념들은 결국 컴퓨터 구조와 연관된 것이기 때문에, 공부를 하다보면 파고들게 되었다. 하나하나의 과정을 이해하는 과정이 오래걸리고 힘겹다보니, 다음 개념으로 진행할 때 부담감이 엄청났다. 또한, 다음개념으로 넘어가도 되는것인지에 대한 확실함이 부족하고, 내가 정말로 이 개념을 이해하고 있는지에 대한 확신도 없었기에 계속 같은 개념을 파다보니, 다음 개념으로 넘어가는데 굉장히 많은 시간이 소요되었다.&lt;/p&gt;
&lt;p&gt;나는 그동안 내가 좋아하는 것, 재미있는 것만 하고 살아왔기 때문에 한 개념을 진득하게 파고 들어가는 것이 즐겁지가 않았다. 그래서 지금처럼 개발언어를 다뤄보면 잘하는데, 각 언어의 동작원리라던지, 딥한 기술질문이라던지에 대한 질문이 들어오면 확실하게 답변하지 못했다. 나의 기술면접 패착요인이 이것이라고 판단하고 있어 가장 경계해야하는 태도임을 인지하고 있음에도 불구하고, 지속적으로 몸과 마음이 거부하는 것을 느끼고 너무 힘들었다.&lt;/p&gt;
&lt;p&gt;하지만, 생각을 다시 해보았다. 나는 지식노동자인데, 남들이 다 아는것을 모르는 건 정말 무책임한 일이라는 것을 깨달았다. 그것도 재미있는것만 골라서 하는 지식노동자를 고용자와 동료들 입장에서 얼마나 신뢰할까 걱정했다. 내가 개발의 모든 영역을 좋아하는게 아니란 것을 깨달았기 때문에, 오히려 좋아하지 않는 것을 좋아하게 만들면 나의 단점이 커버되지 않을까 생각되었다.&lt;/p&gt;
&lt;p&gt;나의 특성을 잠깐 돌아봤을 때, 진득하게 하나에 몰입하는 것을 잘하지 못한다. 단, 여러가지 주제를 번갈아보고, 그것을 기억하는 것을 잘한다.
언어의 핵심을 공부하긴 꺼려하지만, 그때 그때 필요한 것들을 잘 찾아서 흐름을 빠르게 파악하여 핵심을 잘 이해한다.&lt;/p&gt;
&lt;p&gt;그렇다면, 얉고 넓게 같은 개념들을 지속반복해서 학습하다보면 어느순간 많은 것들을 한번에 높은레벨까지 끌어올릴 수 있지 않을까? 싶었다.
그래서 오늘부터 시도해보려고 하는 방법이 &lt;strong&gt;키워드 학습&lt;/strong&gt;이다. 지금 현재 우리반을 맡고계신 튜터님도 키워드를 잡으라고 말씀하시는데, 난 그 키워드들을 볼때마다 설레는 마음이 생긴다. 하지만, 하나를 잡고 파고들기 시작하면 지친다..&lt;/p&gt;
&lt;p&gt;따라서, 적절히 깊이를 잘 설정하여, 키워드만을 기억하되 한번 공부한 개념은 평생 기억 할 수 있을 정도로 꼼꼼히 학습할 예정이다. 또한, 그렇게 학습한 것들은 한 줄 내외로 간략하게 작성해볼 예정이다. 많은 새로운 것들을 나에게 효과적으로 받아들이게 만들고 싶은데 이게 적절한 방법인진 모르겠지만.. 한번 해보려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-29 Today I Learn]]></title><description><![CDATA[회고 221128 : 말할 수 있는 것이 진정으로 아는것 드디어 2차 프로젝트가 마무리되고, 발표도 마무리했다. 자진해서 PM을 맞아 프로젝트를 관리한 프로젝트라 그런지, 하얗게 불태웠다는 느낌이 뭔지 느껴졌다.
프로젝트 직전 같이…]]></description><link>https://mitoconcrete.github.io/22_11_29/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_29/</guid><pubDate>Tue, 29 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221128 : 말할 수 있는 것이 진정으로 아는것&lt;/h2&gt;
&lt;p&gt;드디어 2차 프로젝트가 마무리되고, 발표도 마무리했다. 자진해서 PM을 맞아 프로젝트를 관리한 프로젝트라 그런지, 하얗게 불태웠다는 느낌이 뭔지 느껴졌다.
프로젝트 직전 같이 2주가량 스터디를 함께한 팀원들과 함께해서 더욱더 끈끈하게 프로젝트를 진행 할 수 있었고, 내가 목표로 삼고자는 것이 버겁더라도 끈기있게 다들 노력해주셔서 잘 마무리 된 것 같았다.&lt;/p&gt;
&lt;p&gt;다른 조가 어떻게 진행되고 있는지 들어보았을 때, 실력있는 한사람이 프로젝트를 모두 다 작업하는 식으로 진행한 곳이 많다고 들었다. 개인적으로 팀프로젝트는 모두가 같은 속도로 나아가는 것이 중요하다고 생각하기에, 위 방식처럼 프로젝트를 끌고가지 않으려고 신경을 많이 썻다. 기획부터 시작하여 스토리라인짜고, 설계까지 모두 함께 진행했다. 업무분배도 인당 4~5개는 수행 할 수 있도록 하였고, MVC를 한번씩은 모두 작업하실 수 있도록 업무를 쪼갰다.&lt;/p&gt;
&lt;p&gt;우리조는 유독 다른조보단 같이 남아주는 문화가 있었는데, 하루에 해치울 수 있는 업무의 갯수와, 그리고 업무를 미리 선점을 하도록 했고, 이에따라 먼저 일을 마친 팀원이 다른 팀원이 할 일을 뺏을 수 없게되어, 도와주는 문화가 자연스럽게 형성된 것이 의도치않은 좋은 포인트 중 하나였다.
또한, 서로 질문을 주고받는 것에 거리낌이 없고, 그것을 해결하기 위해 우르르 몰려 토론을 하는 문화도 형성이 되었는데, 그것이 프로젝트를 하면서 모두가 빠르게 성장 할 수 있는 원동력이 되지 않았나 생각되었다. 프로젝트를 진행하면서 커뮤니케이션이 성장에 크게 영향을 줄 수 있다는 것을 느꼈다. 보통 알고있는 것을 말할 수 있을 때, 그것이 온전히 내것이라는 말이 있는데, 확실히 다른 팀원들을 도와드리면서 자바의 정석에서 배웠던 개념들을 이해시키기 위해 많은 예시를 들어 설명드리면서, 나도 어떤 개념에 대해 확실히 이해 할 수 있는 상태가 되는 것이 너무 좋았다. 개개인의 개발능력은 다르지만, 위에서 말했듯이 서로 돕는 문화가 형성되면서, 도움을 받는 사람은 도움을 받는대로 성장하고, 도움을 주는 사람은 도움을 주는 사람나름대로 계속 뭔가를 말하면서 윈윈하는 관계가 되는 것이 좋았다.&lt;/p&gt;
&lt;p&gt;프로젝트의 특성상 굉장히 빠르게 진행되고, 공부해야 할 키워드들이 우르르 쏟아지고 있다. 이것을 시간에 쫒겨 주워담기만 하기 보단, 제대로 정확하게 알고 내 호주머니에 넣을 수 있도록 공부해야겠다. 내일 무엇을 공부 할 수 있다는 것이 설레지고 있는데, 이 관성을 유지해서 성장에 박차를 가하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-28 Today I Learn]]></title><description><![CDATA[회고 221128 : 팀프로젝트의 막바지 오늘 오전중으로 모든 작업을 마치고, 팀원들과 작업한 코드를 합쳐구동시키게 만들었다.
정말 천천히 진행하려고 했다. 그동안 팀원들이 작업한 내용들이 합쳐지는 순간이기도 하였고, API…]]></description><link>https://mitoconcrete.github.io/22_11_28/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_28/</guid><pubDate>Mon, 28 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221128 : 팀프로젝트의 막바지&lt;/h2&gt;
&lt;p&gt;오늘 오전중으로 모든 작업을 마치고, 팀원들과 작업한 코드를 합쳐구동시키게 만들었다.
정말 천천히 진행하려고 했다. 그동안 팀원들이 작업한 내용들이 합쳐지는 순간이기도 하였고, API 연결되는 짜릿함을 느낄 수 있는 순간이기 때문이다.
또한, 프로젝트의 흐름을 살펴볼 수 있는 거의 마지막 기회이기 때문에, 프로젝트 흐름을 따라오지 못했던 팀원들에겐 프로젝트를 전반적으로 살펴볼 수 있도록 배려했다.&lt;/p&gt;
&lt;p&gt;다행히도, 작업한 사항 중 버그는 발생하지 않았다. 하지만, 문제는 main함수가 너무 길어졌고, 모듈화가 필요해졌다.
또한, 이번 프로젝트는 3-Tier 구조를 충실히 구현하여, 각각의 역할을 독립시키는데 의의를 두었지 객체지향에서 주로 사용되는 개념인 SOLID원칙이나 Interface에 대한 내용들은 의도적으로 배제시켰다.&lt;/p&gt;
&lt;p&gt;아무래도 많은 팀원분들이 자바 그 자체를 다루는 것을 어려워하고 있는데, 거기에 개념적인 것들을 짬뽕시키면 더 헷갈려지실 것 같아 의도적으로 배제시키려고 했다. 또한, 배웠더라도 의미없는곳에 추상메서드와 인터페이스를 적용하는 짓은 하지않고 싶었다. 일단, 나조차도 둘의 차이에 대해 구분하지 못할 뿐더러 그 용도가 확실해졌을 때 잘 사용하고 싶다는 욕심이 있었다. 또한, 그것을 의미없이 남발하다보면, 안그래도 멘붕인 팀원분들이 더욱더 멘붕이 올 것은 당연한 일이라고 생각했다. 하지만, 개인적으로 주말동안 SOLID에 대해서 끊임없이 고민을 했기 때문에, 꼭 이번프로젝트를 SOLID원칙을 지켜 리팩토링해보고 싶다는 생각을 했다.&lt;/p&gt;
&lt;p&gt;추가적으로 다른 팀분들이 우리가 프로젝트에 대해 어떻게 진행했는지 많이 물어보셨다. 이게 좋으면서도 부담스러웠던게, 개인의 해석에 따른 구조정의가 A반전체에 영향을 끼칠 수도 있겠다는 생각이 들었기 때문이다. 하지만, 생각보다 프로젝트 진행자체에 난항을 겪는 분들이 계시기도 했고, 이미 내 코드가 레퍼런스로 돌고있다는 소식을 전달받았기에, 도움이 필요한 분들께 내가 생각한 3-Tier 아키텍쳐에 대해 설명드리되, 꼭 &apos;이건 제 생각이다&apos;라는 말을 꼭 붙혔다.설명드리는 과정에서 3 Tier 에서 각 역할에 대한 구분이 더욱 더 명확해지는 신기한 경험을 했다. 하지만, 이게 정답이 아니기 때문에 확실시하는 태도는 경계해야 할 필요가 있다. 따라서, 나도 끊임없이 고민하며, 더 나은 방법이 어떤것인지 고민해보려고 한다.&lt;/p&gt;
&lt;p&gt;내일은 그동안 고생한 작품을 선보이는 시간이다. 아무리 준비를 열심히 했어도.. 남들에게 잘 자랑하지 못하는 만큼, 우리조의 고생이 의미없어지는 방법은 없는 것 같다. 따라서, 발표까지 잘 준비하여 유종의 미를 거둘 수 있도록 신경써야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-4th Weekly I Learn]]></title><description><![CDATA[FACT-O1. SOLID 원칙을 학습했다. FEELINGS SOLID 각 단어만 보았을 땐 이게 무슨말인가 싶었다.(리스코프..가 누구여..?) FINDINGS SOLID…]]></description><link>https://mitoconcrete.github.io/22_11_4th/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_4th/</guid><pubDate>Sun, 27 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-O1. SOLID 원칙을 학습했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOLID 각 단어만 보았을 땐 이게 무슨말인가 싶었다.(리스코프..가 누구여..?)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOLID 원칙에 대해서 고민하고, 그에 맞게 작업하다보면 디자인 패턴에 맞게 설계가 된다는 것을 알게되었다.&lt;/li&gt;
&lt;li&gt;즉, 디자인 패턴은 SOLID원칙에 의거하여 클래스를 더 잘 사용하기위해 만들어진 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOLID 원칙을 항상 상기하면서, 객체를 설계하려고 노력해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;단일 책임원칙이 가장 간단한 것이라, 현재 프로젝트에는 이를 적용하고 있는데.. 나머지는 다 못지키고 있는 것 같다.. 팀원분들께 한번 SOLID원칙을 지키는 방식으로 리팩토링하자고 제안드려봐야겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-02. 자바의 정석 객체지향 파트를 3회독하였다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;워낙 어려운 개념이라 이해가 잘 되지 않다가, 반복해서 보니 이해가 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바의 정석 객체지향파트에는 비단 문법뿐만아니라, 자바의 메모리구조를 학습하면서 자바의 근간에 접근하는 개념들을 다루는 것을 발견했다.&lt;/li&gt;
&lt;li&gt;자바자체가 객체를 지향하는 언어이기 때문에, 어떤 방식으로 객체를 지향할 수 있는지 알려주기 위해 이렇게 딥하게 들어가고 있다는 것을 알게되었다.&lt;/li&gt;
&lt;li&gt;회독을 늘려갈수록, 자바에 대한 이해도가 높아지는 것을 느낄 수 있었고, 접근연산자나 static같은 것들을 이전보다는 더 신중하게 사용 할 수 있게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;회독을 계속 반복하면서, 내 것으로 만들기 위해 노력해야겠다는 생각을 했다. 반복하면 반복할수록 자바의 기반을 이해하는 것 이기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-03. 3-Tier구조를 이해하기 위해 노력했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVC모델과 비슷하다고 생각했지만, 실제로 클래스를 이용해서 구조를 만들려다보니 쉽지가 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음 튜터님의 강의를 들으면서 재클론 하면서 어떤구조인지 이해하면서, 아 이렇게 클래스를 이용해서 만들 수 있겠구나 하는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;이후에 진행된 프로젝트를 모두 3 Tier방식으로 진행하면서, 자바로 이렇게 3 Tier를 만들수있구나 하는 깨달음을 얻었다.&lt;/li&gt;
&lt;li&gt;3 Tier원칙을 지키는 것은 단일책임을 정말 잘지키는 것임을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앞으로 진행된는 프로젝트는 최대한 3 Tier 구조를 지키면서, 설계를 할 것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-04. PM을 주도적으로 맡아 프로젝트를 진행했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀장님이 따로 계셨기때문에 망설였지만, 맡고나서 다른 팀원분들이 의지해주는 것을 느끼고 기분이 좋았다.&lt;/li&gt;
&lt;li&gt;여러사람의 의견을 듣고 프로젝트를 끌어나가는 것, 그리고 이해도가 다른 사람들에게 같은 그림을 심고 프로젝트를 리딩하는 것이 쉽지않다는 것을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 프로젝트의 흐름을 잘 이해하는 상태고, 사용해야하는 기술에 대해 이해하고 있는 상태라면 프로젝트를 리딩을 나쁘지 않게 한다는 것을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추후 같은 기분을 느끼는 상태라면, 회사에 취직해서 내가 주도적으로 프로젝트를 만들고 리딩하는 것을 해봐도 좋겠다는 생각을 했다. 많은 커뮤니케이션을 통해 앞으로 나아가는 과정에서 소프트적으로도, 기술적으로도 성장하는 것이 느껴졌기 때문이다.&lt;/li&gt;
&lt;li&gt;커뮤니케이션 스킬은 의식해서 고쳐나가야겠다는 생각을 했고, 기분에 좌지우지되지 않도록 노력해야겠다는 깨달음을 얻었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-25 Today I Learn]]></title><description><![CDATA[CS HTTP 1. 회선통신 이후 등장한 패킷통신 2. TCP/IP 3. HTTP의 특성 4. HTTP Method 회고 22111…]]></description><link>https://mitoconcrete.github.io/22_11_25/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_25/</guid><pubDate>Fri, 25 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[CS] HTTP&lt;/h2&gt;
&lt;h3&gt;1. 회선통신 이후 등장한 패킷통신&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 회신통신 : 패킷통신이전에 사용한 통신방식으로서, 회선의 트래픽이나 이동효율을 고려하지 않고 데이터를 이동시킨다.
- 패킷통신 : 데이터를 패킷이라는 작은단위로 쪼개어 보내고, 순서를 보장하지 않고 목적지까지 전달하여 도착지에서 데이터를 합치는 방식이다. 각 패킷들은 가장 효율적인 경로를 선택하여 이동한다. 패킷을 나누게 되면서, 데이터의 크기가 커서 대역폭을 차지하면서 병목현상이 발생하는 현상이 사라지게 되었다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. TCP/IP&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- IP는 패킷을 안전하게 보내기 위한 프로토콜이다. 패킷전달여부와 전달순서를 보장하지 않는다. 따라서, 신뢰도 높은 패킷을 전달하기 위해 TCP라는 방식이 사용된다.
- TCP는 패킷의 전달순서가 보장되고, 3-way handshake, 4-way handshake와 같이 세션을 생성하여 연결된 상태를 유지한다. TCP를 기반으로 한 HTTP, FTP, SMTP등이 IP위에서 동작하기 때에 이러한 프로토콜을 TCP/IP기반의 프로토콜이라고 한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. HTTP의 특성&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 비연결성 : 클라이언트의 요청과 서버의 응답이 완료되면 연결을 곧바로 중단한다.
- 단방향성 : 서버는 클라이언트의 요청이 있어야 응답을 보낼 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. HTTP Method&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- GET, POST, PUT, PATCH, DELETE&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[회고] 221115 : 프로젝트는 순항중(?)&lt;/h2&gt;
&lt;p&gt;프로젝트는 나름 순항중이다. 인터페이스도 사용하지 않고 작업중이지만, 이 프로젝트가 분배가 된다고(!?) 하는 느낌으로 몇몇분들은 우리조로 찾아와서 슥 구경하고 가셨다.
기분이 좋기도 했지만, 진도를 따라가는데 어려움을 겪으시는 팀원분들이 조금씩 속출해서 내심 고민이 많았다. 처음 3Tier 구조를 잡을 때 한 분, 그리고 프로젝트를 진행함에 따라 한분이 더 생겼는데, 뭔가 내가 프로젝트의 난이도를 잘못설정하고 있는게 아닌가 하는 생각이 많이 들었다.&lt;/p&gt;
&lt;p&gt;추가로, 팀원들이 눈에보이는 순서도나 와이어프레임이 없고, 메소드의 구현체가 없이 문서만 보고 진행해야하다보니 개발이 익숙하지 않으신 팀원분들은 왜 이렇게 작성하는지 이유를 파악하는데 시간을 많이 소요하셨다.&lt;/p&gt;
&lt;p&gt;또한, 나름 체계적으로 잘 짰다고 생각했지만, 찾아보니 결국 수정할 것 들이나 애매한 것들이 계속 늘어났다. 팀원들끼리 이게 왜 필요한지, 왜 써야하는지를 토론해가면서, 점차 메소드 리턴타입이나, 변수명 등등을 계속 수정해나갔다. 하지만, 토론시간이 늘어날수록 작업시간에 할당된 시간이 줄어들면서, 어쩔수없이 야근을 해야하는 상황으로 까지 번지게 되었다.&lt;/p&gt;
&lt;p&gt;그래도 모두들 몰입하시고, 테스크를 재미있게 진행하고 계시는게 보여 뿌듯함을 느꼈다. 하지만, 개인적으로 프로젝트하면서 느낀점 고칠점들이 느껴졌는데 다음과 같았다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 프로젝트 측면
1. 추가적인 커뮤니케이션 리소스를 줄이기
    - API설계는 최대한 확실하고 꼼꼼하게
    - 메서드명은 최대한 디테일하게
    - 흐름도를 그려, 시각적인 순서를 팀원들이 공유하도록 하기.

2. 상호협의한 로직은 항상 상기하기
    - 초기의도를 잊지않기

3. 소통채널을 일원화하기
    - 헬프데스크 같은 창구를 따로만들어서, 문제해결만을 따로 분리하기
    - 하나를 정해놓고, 거기서만 소통하기(파편화금지)

4. 인터페이스를 미리정의하기
    - 팀원들이 문서외에 사용해야할 메서드에 대한 정의가 없다보니, 지속적으로 혼란스러워함. 따라서, 기능단위로 인터페이스를 미리정의해두고, 그걸 상속받아서 사용할 수 있게 만드는게 낫겠다는 생각을 함.

- 개인측면
1. 말 줄이기
    - 쓸데없는 말을 해서, 팀원들에게 혼동주지않기
    - 필요한 말만 하기
2. 목소리 톤 낮추기
    - 상대방이 불쾌감을 느낄수 있다고 생각함
3. 말하면서 흥분하지 않기(말천천히하기)
    - 말 속도가 점점빨라지면서, 상대방이 치고들어올 타이밍을 못잡게만드는 것 같음.
3. 상대방의 말을 끊지 않기
    - 충분히 경청하기&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것들은 꼭 염두하며, 다음주부터라도 의식적으로 고쳐나가려고 노력해야겠다.&lt;/p&gt;
&lt;p&gt;아직 완성까지는 많은 단계가 남았지만, 남은기간 힘내서 좋은결과로 이어졌음 좋겠다!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-24 Today I Learn]]></title><description><![CDATA[회고 221124 : 작은 프로젝트에 이렇게 진심이라고? 난 뿌듯했음. 그 이유는... 미니 프로젝트가 무사히 마감되고, 본 프로젝트가 시작되었다. 프로젝트 시작 전 팀장이신 ㅈㅎ님께 조심스럽게 PM…]]></description><link>https://mitoconcrete.github.io/22_11_24/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_24/</guid><pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221124 : 작은 프로젝트에 이렇게 진심이라고? 난 뿌듯했음. 그 이유는...&lt;/h2&gt;
&lt;p&gt;미니 프로젝트가 무사히 마감되고, 본 프로젝트가 시작되었다. 프로젝트 시작 전 팀장이신 ㅈㅎ님께 조심스럽게 PM을 맡고싶다고 요청했다.
&quot;이미 하고 계시다&quot; 라는 유쾌한 말씀과 함께, 다른 팀원 분들도 동의해주셔서 프로젝트를 매니징 할 수 있는 권한을 가지게 되었다.&lt;/p&gt;
&lt;p&gt;PM권한을 요청하게 된 이유는, 그래도 3 Tier라는 구조에 대해서 감을 잡았고, 그것을 이번프로젝트를 통해 다른 팀원 분들께 더욱더 이해시키고 싶었기 때문이다.
그러기 위해선 다른팀원분들이 Presentation-Service-Repository를 모두 경험하셔야 했는데, 그래도 구조에 대해서 설명하고 설득 할 수 있는 정도는 되었다고 생각했기에, 스스로 약간의 여유가 있다고 판단했다. 따라서, 그 여유를 이용해 다른 팀원들에게 업무를 할당하고, 프로젝트를 원활하게 흘러가는데 시간을 투자하는 게 낫겠다는 생각에서 PM을 요청하게 되었다.&lt;/p&gt;
&lt;p&gt;일단 무엇부터 체크해야하는지 체크리스트를 정리했다. 처음에는 엔티티를 짜고, 분배하고, 프로젝트 빨리 들어가야지하고 가볍게 생각했는데, 팀원들과 토론을 하다보니 더 디테일하게 챙겨야 할 것들이 생겼다. 결국 3 Tier layout에 대한 고민을 모두 하게 되버렸다.&lt;/p&gt;
&lt;p&gt;이왕 이렇게 된거 정말 제대로 해보자는 생각에서, 메소드 명 부터 변수명까지 모두 맞추기 시작했다. 그러다보니, 장기간 토론이 되었고, 가장 시간이 많이 소요되었던 이유는 모두의 머리에 같은 그림이 그려지도록 하기위한 커뮤니케이션이었다. 아무래도 모두의 속도가 다르다보니, 그 속도에 대해서 맞추고 갈 필요가 있었고, 왜 변수명은 이렇게 써야하고, 왜 이렇게 매개변수를 넘겨야하고, 리턴이 이렇게 되어야하는지 팀원들과 하나하나 상의하고 이해시키다보니 회의가 점점 길어졌다.
그 결과는 개인적으로 만족스러웠다. 어제까지만해도 혼란스러워하는 팀원들이 각 Tier의 역할에 따라 어떻게 작업할 지 고민하고, 토론하는 상황이 발생한 것이다. 그래도 모든 팀원이 같은 그림을 머리에 가지고, 같은 속도로 맞춰 나가고 있는게 보이기 때문에 너무 기분이 좋았다.&lt;/p&gt;
&lt;p&gt;또한, PM을 맡던 순간까지도 고민되었던게 &lt;em&gt;업무분배&lt;/em&gt; 였는데, 팀원들과 커뮤니케이션을 하다보니, 우리가 바라는 형태로 구현하기 위해 필요한 사항들이 정말 많아졌고, 그것을 구분짓다보니 22개의 Task가 생성되게 되었다. 그리고 갯수가 파악이 되는 Task들이 생성되니, 분업이 가능해졌다! 오늘계속 회의를 하면서 끙끙앓던 고민이 22개로 구분된 업무로 구분지어진것을 보면서 너무 기분이 좋았다.
따라서, 업무를 테이블에 몰아넣고, 각자 맡고싶은 업무를 가져가서 할 수 있도록 했다. 다행히도(?) 아직까진 잘 진행되고 있다. 업무가 분배되니, PM인 내 입장에서 일정관리 하기도 편하고, 나도 내가 하고싶은 업무를 중간중간 가져가서 할 수 있는 것이 좋았다.(시간을 효율적으로 쓸 수 있게되었다.)&lt;/p&gt;
&lt;p&gt;하지만, 후회되고 고쳐야 할 점은 팀프로젝트를 진행함에 따라 매번 발생하는 것 같다. 너무 프로젝트를 &apos;우리&apos;가 합의한 방향으로 밀고 나가야하는데, 전적으로 PM인 내가 바라는 방식으로 메서드를 구현하라고 제한하고 있는 것 이다. 팀원들 간에 토론을 통해서, 합의 보고 말맞춰서 진행하는게 맞는방향이지만, 현재는 나에 대한 의존도가 매우 높은 상황이라서 남은 2일간은 주의하면서 진행해보려고 한다.&lt;/p&gt;
&lt;p&gt;팀원들은 모두 같은 방향을 바라보아야한다. 그것을 Leading하는 사람의 방향으로만 보도록 강요하는게 좋은것은 아닌 것 같다. 어떤 팀원이 다른쪽을 바라보자고 제안했을 때, 바라봐보고 그게 더 좋은 방법이라면, 다른 팀원을 모두 새로운방향을 바라볼 수 있도록 설득하는 것이 좋은 팀이고 유연한 팀인 것 같다.
다음엔 조금더 열린마음으로 내 마음의 답을 지워버리려고 노력해야함을 느꼈다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;프로젝트 체크 리스트
&lt;img src=&quot;/image/221124_01.png&quot; alt=&quot;프로젝트 체크리스트&quot;&gt;&lt;/li&gt;
&lt;li&gt;맥북 메모장으로 시작된 프로젝트 초기기획
&lt;img src=&quot;/image/221124_02.png&quot; alt=&quot;프로젝트 초기 기획&quot;&gt;&lt;/li&gt;
&lt;li&gt;토론을 통해 꽉차게 된, 프로젝트 보드
&lt;img src=&quot;/image/221124_03.png&quot; alt=&quot;프로젝트 보드&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-23 Today I Learn]]></title><description><![CDATA[CS 클럭 클럭은 컴퓨터의 심장박동 같은 것이다. 클럭이 빠를수록, 다른 부품들과 CPU…]]></description><link>https://mitoconcrete.github.io/22_11_23/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_23/</guid><pubDate>Wed, 23 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[CS] 클럭&lt;/h2&gt;
&lt;p&gt;클럭은 컴퓨터의 심장박동 같은 것이다. 클럭이 빠를수록, 다른 부품들과 CPU의 커뮤니케이션하는 속도가 빨라진다. 하지만, 클럭의 속도는 발열과 관계가 있어, 올리는데에는 한계가 있다. 즉, 클럭속도(오버클럭)로 성능을 향상시키는 것은 한계가 있다는 것 이다.&lt;/p&gt;
&lt;h2&gt;[회고] 221123 : 백문이불여일타!&lt;/h2&gt;
&lt;p&gt;설렘반 두려움반으로 프로젝트를 맞이했다. 지난밤 객체지향 수업을 예복습을 꾸준히 했던게 도움이 된건지, 프로젝트 구조가 눈에 확 들어왔다. 하지만, 초안을 작성해보니, 서로 의존하는 것이 많아지고 각 Tier 간 단일 역할을 보장하지 못하는 것 같았다. 모두 지우고, 어제 프로젝트와 비교하면서 엔티티부터 차근차근 요구사항에 맞추어 작성해나갔다. 그러다보니, 더욱더 프로젝트의 구조가 눈에 들어왔고, 이제야 &lt;em&gt;&apos;이 프로젝트는 이렇게하는거구나&apos;&lt;/em&gt; 라는 확신이 들었다. 역시 백문이불여일타 라는 밈이 이래서 생겼나보다 싶었다.&lt;/p&gt;
&lt;p&gt;2시간 정도안에 작성한 모든 프로그램코드를 팀원들에게 공유드리며, 내일 그리고 다음을 위해서라도 이 구조가 모두의 머릿속에 있는게 좋을 것 같다고 팀원들을 설득했다. 처음에는 이 구조를 굳이 지켜야 하냐며, 이해를 못하시는 팀원들을 설득하고 설득했다.&lt;/p&gt;
&lt;p&gt;설득한 만큼 책임지고, 이해하지 못한 팀원들을 붙잡고 구조를 이해시키려고 노력했다. 처음에 이해를 못하시던 팀원도, 이 프로젝트에선 빠져야겠다고 푸념하는 팀원도, 어디부터 손을 대야 할 지 모르는 팀원들도 끈질기게 설명드리니, 조금씩 이해하시는 게 보였다. 그게 참 뿌듯했다.&lt;/p&gt;
&lt;p&gt;속도가 맞지않으면 내가 느리게 걸으면서 맞추면 된다. 저번의 팀프로젝트에서 갖게 된 신념이다. 나는 팀원들과 지속적으로 소통하면서 자연스레 커뮤니케이션 스킬을 얻었고, 나와의 커뮤니케이션으로 새로운 지식을 얻은 팀원들은 지식을 얻었다. 하지만, 상대방의 말을 경청하는 습관을 들여야겠다는 생각을 프로젝트 내내 했던 것 같다. 내가 너무 상대방의 말씀을 끊어내는 것이 의식적으로 느껴지기 시작하면서, 말을 끊어내는게 상대방 입장에서는 불쾌함을 느낄 수도 있겠다고 생각했다. 이런 나의 좋지않은 모습을 다시 한 번 성찰하고, 다신 같은 행동을 하지 말아야겠다는 반성을 했다.&lt;/p&gt;
&lt;p&gt;나와 같은 조가 된 이상, 단 한 분도 이해속도가 느려지게 막지 않을것이다. 물심양면으로 도와드려서 꼭 조원들과 주변에 좋은 영향력을 끼치고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-22 Today I Learn]]></title><description><![CDATA[객체지향 객체지향 Study 1. 다운캐스팅 부모가 자식의 참조변수형을 이용하여 형변환을 하는 것. 사용사례 2. 3-Tier Architecture Presentation - Application - Data 의 3단계로 구분되는 아키텍쳐
View…]]></description><link>https://mitoconcrete.github.io/22_11_22/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_22/</guid><pubDate>Tue, 22 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[객체지향] 객체지향 Study&lt;/h2&gt;
&lt;h3&gt;1. 다운캐스팅&lt;/h3&gt;
&lt;p&gt;부모가 자식의 참조변수형을 이용하여 형변환을 하는 것.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용사례&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Participant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MemberParticipant&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Participant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;NonMemberParticipant&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Participant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Participant&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// p 가 A 메소드를 사용하길 원할 경우&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;MemberParticipant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 3-Tier Architecture&lt;/h3&gt;
&lt;p&gt;Presentation - Application - Data 의 3단계로 구분되는 아키텍쳐
View - Controller - Model 의 MVC모델과 비슷한 듯 하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Presentation Tier&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 보여주는 것에 집중하는 계층&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application Tier&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service 계층으로서, Data Tier와 API를 이용한 통신을 한다.&lt;/li&gt;
&lt;li&gt;가져온 데이터를 가공하여 클라이언트에 전달해주는 비즈니르 로직을 제공하기도 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Data Tier&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository 라고도 표현하며, 데이터베이스 안에 있는 데이터를 Application Service의 요청으로 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221122 : 완전히 아는 상태에서 설계하기&lt;/h2&gt;
&lt;p&gt;오늘 튜터님께서 하신 강의를 토대로 리팩토링을 해보면서, 무릎을 탁치는 순간들이 있었다.
계속 똑같은 &lt;code class=&quot;language-text&quot;&gt;getMenuItem&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;getMenu&lt;/code&gt; 가 반복되어서 왜 계속 똑같은 코드를 치시는 거지 라고 의문을 가졌다.
또한, 내가 직접 처음부터 작성해보려고 했는데, 3 Tier의 정확한 이해가 없이 빌드업 해나가려고하니, 구조가 계속 꼬이고 역할 할당이 잘 되지 않아서 구조를 짜는게 잘 되지 않았다.&lt;/p&gt;
&lt;p&gt;코드를 이해하고 보니, 결국엔 객체의 역할과 책임이 부여되고, &lt;code class=&quot;language-text&quot;&gt;getMenuItem&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;getMenu&lt;/code&gt; 은 각자의 역할에 따라 할당된 것들이었다. 같은 기능을 하는 것 처럼 보여도, Service(Application)에서의 &lt;code class=&quot;language-text&quot;&gt;getMenuItem&lt;/code&gt; 은 Data Tier에서 가져오는 데이터이고, Repository(Data) 에서의 &lt;code class=&quot;language-text&quot;&gt;getMenuItem&lt;/code&gt;은 직접적으로 데이터베이스에서 가져오는 것이다. main은 어쩔수없이 UI와 Service가 혼용되는 식으로 구성되어있는데, 너무 절차지향같지 않도록 잘 구현하는 것이 중요 할 것 같다.&lt;/p&gt;
&lt;p&gt;확실한 것이 아니라면, 손을 멈추고 고민해보고 주변에 도움을 요청하던 리서치를 하던, 확실해진 상태에서 개발에 돌입하는것이 서비스 품질에도 좋은 영향을 끼칠 수 있겠다는 생각이 들었다. 만일, 내가 아무런 이해없이 내 설계대로 서비스를 계속 구현했다면, 객체지향의 원칙을 무시한 엉망진창 서비스가 탄생했을 것이다.&lt;/p&gt;
&lt;p&gt;나는 잘하기 위해 왔지, 잘난척을 하러온 것이 아니다. 명심하자!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-21 Today I Learn]]></title><description><![CDATA[알고리즘 약수구하기 & 약수의 갯수 구하기 n의 약수를 구할 때는, a * b == n 이 되는 규칙을 항상 따른다. 따라서, n 번이 아니라 1/2n…]]></description><link>https://mitoconcrete.github.io/22_11_21/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_21/</guid><pubDate>Mon, 21 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[알고리즘] 약수구하기 &amp;#x26; 약수의 갯수 구하기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;n의 약수를 구할 때는, a * b == n 이 되는 규칙을 항상 따른다.&lt;/li&gt;
&lt;li&gt;따라서, n 번이 아니라 1/2n 번 만 반복문을 돌아도 된다. 따라서, 제곱근을 이용해 절반횟수만 반복문을 돌 수 있도록 설정한다.&lt;/li&gt;
&lt;li&gt;i 와 i // j 를 하면 한 사이클에서 2개의 약수를 구할 수 있다.&lt;/li&gt;
&lt;li&gt;단 약수가 같은 수인 경우를 제외시키기 위해서 조건문을 이용하여 필터링 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;number&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; limit&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; power&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    answer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; number &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        divider_cnt &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&apos;&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; 일 때 &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; 번 반복문을 거친다.&apos;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt; j &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&apos;&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;의 약수 &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
                divider_cnt &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;j&lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                    divider_cnt &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
                    &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&apos;&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;의 약수 &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;//&lt;/span&gt; j&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; divider_cnt &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; limit&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            divider_cnt &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; power
        answer &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; divider_cnt
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; answer&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[객체지향] 객체지향 Study&lt;/h2&gt;
&lt;h3&gt;1. setter 을 사용하지 말라?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@backfox/setter-%EC%93%B0%EC%A7%80-%EB%A7%90%EB%9D%BC%EA%B3%A0%EB%A7%8C-%ED%95%98%EA%B3%A0-%EA%B0%80%EB%B2%84%EB%A6%AC%EB%A9%B4-%EC%96%B4%EB%96%A1%ED%95%B4%EC%9A%94&quot;&gt;setter를 쓰지말라고 하고 그냥가버리면 어떡해요..&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;setter를 사용하지마란 의미는, 절대 사용하지 말라는 말라기보단 객체의 책임 역할 핵심에 집중하여 의미없는 set을 이용해 멤버변수의 무분별한 업데이트를 막자는 의미이다.
setPrice 를 해놓고 discount 한 price를 전달하여 업데이트한다면, 그것은 의미와 맞지 않는다.
만약 불가피하게 사용해야만 한다면, 구체적인 네이밍을 명시해줌으로서 모두가 납득할만한 setter를 배치해야한다.
하지만, 사용하지 않는 것을 추천한다.&lt;/p&gt;
&lt;h3&gt;2. SOLID 5원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SRP(Single Responsibility Principle) : 단일 책임 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 클래스는 하나의 책임만을 가져야한다. 어떤 클래스를 수정했을 때, 다른 부분에서의 변경이 거의 없다면, 이 원칙을 잘 지킨 것 이다. 클래스를 수정하는 기준은 유일해야한다. 이유는 클래스는 단 하나의 책임을 가지고 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OCP(Open/Closed Principle) : 개방/폐쇄의 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;확장에는 개방적이나, 변경에는 닫혀있어야 한다. 하나의 참조변수로 여러타입의 변수를 선언 할 수 있는 것을 지향(Open)해야하지만, 단일 메소드를 변경하는 것을 지양(Close)한다.&lt;/li&gt;
&lt;li&gt;어떤 클래스에 걷기기능만 있다가 뛰기, 수영하기 등의 기능이 나중에 추가되었다고 했을 때, 계속 걷기 메소드를 수정하여 기능을 추가하기 보다는, 각 기능에 대한 인터페이스를 생성하고 그것을 상속받아 추가하는 것이 더 적은양의 코드를 수정하면서 기능을 구현 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LSP(Liskov Subsitution Principle) : 리스코프 치환 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서브타입은 언제나 상위타입으로 치환 할 수 있어야한다. 상속으로 이를 구현 할 수 있으며, 주의할 점은 상호합의된 정합성을 깨뜨리면 안된다.&lt;/li&gt;
&lt;li&gt;이 원칙을 지키지 않으면, 메소드가 이상하게 동작할 수 있으며, 이는 테스트를 통해 검증이 되지않기에 주의해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ISP(Interface Segregation Principle) : 인터페이스 분리 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트가 자신이 사용하지 않는 메소드에 의존하면 안된다.&lt;/li&gt;
&lt;li&gt;범용 인터페이스를 제공하기 보단, 역할에 맞는 인터페이스를 각각 만들어 상속하여 실행하는게 목적에 맞다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DIP(Dependency Inversion Principle) : 의존관계 역전 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체간 협력과정에서 의존관계가 형성되는데, 변하기 어려운 것을 기준으로 삼아 의존관계를 만드는 것이 좋다.&lt;/li&gt;
&lt;li&gt;변하기 어려운 것은 추상적인 개념이나 흐름이고, 변하기 쉬운것은 구체적인 행동을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SOLID 원칙을 발전시켜 만든 것이 디자인패턴이다. SOLID 원칙을 지키다보면 자연스레 디자인 패턴을 쓰고 있을 수 있다!&lt;/p&gt;
&lt;h3&gt;3. 추상화 vs 구체화&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;추상화는 어떤 사물에게서 공통적 성질을 뽑아 개념화하는 것이다.&lt;/li&gt;
&lt;li&gt;구체화는 어떤 사물의 특징을 세부적으로 구현하는 것이다.&lt;/li&gt;
&lt;li&gt;상속을 위한 부모를 정의하는 것은 추상화에 가깝고, 그것을 상속하면 상속할수록 구체화가 더해진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Java] Java Study&lt;/h2&gt;
&lt;h3&gt;1. 상속&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;생성자와 초기화 블록은 상속되지 않는다.&lt;/li&gt;
&lt;li&gt;자식클래스의 멤버변수는 부모클래스의 멤버변수 갯수와 같거나 항상크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 오버라이딩&lt;/h3&gt;
&lt;p&gt;오버라이딩 시 접근제어자와 Exception은 제한된 조건 안에서 오버라이딩이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;접근제어자는 부모보다 권한이 작아질 수 없다.&lt;/li&gt;
&lt;li&gt;부모보다 더 넓은 범위의 Exception을 선언 하는 것은 불가하다.&lt;/li&gt;
&lt;li&gt;static 메소드를 인스턴스 메소드로 변경하는 것은 불가하다.&lt;/li&gt;
&lt;li&gt;인스턴스 메소드를 static 메소드로 변경하는 것은 불가하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. super&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클래스는 지역변수로 자신의 주소값을 사용 할 수 있다. 그것이 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;인데 상속은 받은 클래스는 &lt;code class=&quot;language-text&quot;&gt;super&lt;/code&gt;를 지역변수로 사용이 가능하다. &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;super&lt;/code&gt; 모두 인스턴스가 생성되어야 사용가능하기 때문에, static 메소드에서는 사용이 불가하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. super()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자식클래스가 인스턴스화 될 때, 부모클래스의 생성자를 우선적으로 실행시켜 부모클래스의 멤버들을 초기화 시켜주어야 한다. 자바 컴파일러는 잠재적으로 super()생성자를 실행시켜준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5. 패키지&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 디렉토리이자, class 보따리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. import&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;java.lang.*&lt;/code&gt;과 같이 *을 사용하여 모든 클래스를 가져와도, 실행속도에는 큰 영향이 없다.&lt;/li&gt;
&lt;li&gt;static 클래스를 호출하면 클래스이름을 생략할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;7. 제어자&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;접근제어자는 단하나만 사용가능하며, 이외 제어자들은 조합이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;final :&lt;/strong&gt; 변경할 수 없는 값에 선언하며, 이 키워드를 이용하면, 상속 및 오버라이딩 확장이 불가하다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;제어자 조합주의 :&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static, abstract : static은 무조건 몸통이 존재해야함&lt;/li&gt;
&lt;li&gt;abstract, final : 역할 상충(상속을 해야 이용 가능한 것 vs 상속이 불가한 것)&lt;/li&gt;
&lt;li&gt;abstract, private : 상속받는 곳에서 private으로 선언한 것에 접근 할 수 없다.&lt;/li&gt;
&lt;li&gt;private, final : 의미가 비슷하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;8. 다형성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;참조변수의 타입에 따라, 사용할 수 있느 멤버변수의 갯수가 달라진다.&lt;/li&gt;
&lt;li&gt;부모의 참조변수로 자식을 사용할 수 없는 이유는 사용하는 멤버변수가 자식이 항상 같거나 많기 때문이다.&lt;/li&gt;
&lt;li&gt;메소드의 경우 참조변수의 타입에 관계없이, new 를 통해 선언한 인스턴스의 메소드를 사용하지만, 멤버변수는 참조변수를 따라간다.&lt;/li&gt;
&lt;li&gt;인스턴스 변수에 직접 접근하게 되면, 참조변수가 무엇이냐에 따라 값이 변할 수 있기 때문에, 직접적인 접근은 지양한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;9. 형변환&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;참조변수의 타입을 강제로 정의하여, 사용할 수 있는 멤버의 범위를 조정한다. 인스턴스자체가 바뀌는 것은 아님.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;10. instanceof&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자신이 속한 모든 인스턴스에 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;를 반환한다. 단 getName을 통해 접근하면, 참조변수가 가리키고 있는 인스턴스이름을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;11. 인터페이스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인터페이스의 모든 멤버변수는 &lt;code class=&quot;language-text&quot;&gt;public static final&lt;/code&gt;로 정의한다.&lt;/li&gt;
&lt;li&gt;인터페이스의 장점은 클래스 간의 관계를 느슨하게 만들어준다는 것이다. 클래스 A와 B가 있다고 했을 때, A는 B클래스를 매개변수로 받아 사용하는 메소드가 있다. 따라서, A클래스를 사용하기 위해선, 반드시 B클래스의 정의가 필요하다. 하지만, 인터페이스를 사용하게 되면 의존관계가 되는 기능만 선언하고 해당 인터페이스만 매개변수로 전달하여 사용하면 되니, B클래스를 굳이 선언 할 필요가 없어지기에, 의존관계가 클래스-클래스를 사용하는 것 보단 훨씬 느슨해진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Before&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BUsage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// After&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BUsage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;I&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;인터페이스에서 새로운 메서드를 추가하는 일은 해당 인터페이스를 사용하는 모든 클래스에 영향을 줄 수 있다. 따라서 &lt;code class=&quot;language-text&quot;&gt;defalt&lt;/code&gt;메소드를 인터페이스에 추가 할 수 있는 기능이 추가되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;12. 내부 클래스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;두개의 클래스가 긴밀한 관계에 있을 때, 따로 선언해주는 것보다 내부에 선언해주어 코드의 복잡성을 줄여준다.&lt;/li&gt;
&lt;li&gt;외부 클래스의 멤버변수처럼 사용되기도 하고, 메서드내에서 지역변수처럼 사용되기도 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;13. 익명클래스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클래스 선언과 인스턴스 생성을 동시에 하는 클래스. 일회용 클래스이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221121&lt;/h2&gt;
&lt;p&gt;자바의 객체지향 세계에 녹아들기에 배워야 할 것들, 신경써야할 것들이 너무나도 많다. 몰입해보자!!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-3rd Weekly I Learn]]></title><description><![CDATA[FACT-01. 알고리즘 강의를 완강하고 강의 내 모든 문제를 풀어보았다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/22_11_3rd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_3rd/</guid><pubDate>Sun, 20 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-01. 알고리즘 강의를 완강하고 강의 내 모든 문제를 풀어보았다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1문제를 푸는데 거의 하루를 꼬박사용하였다.&lt;/li&gt;
&lt;li&gt;카카오와 삼성의 문제는 문장이 길고, 한눈에 들어오지 않는 경우가 많았다.&lt;/li&gt;
&lt;li&gt;중간중간 이해가 가지않는 문장들이 있어서 해석이 어려웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;높은 레벨의 문제는 대부분 지문이 길고 해석이 어렵다.&lt;/li&gt;
&lt;li&gt;따라서, 지문에 대한 해석을 완벽히 해내야, 알고리즘 문제에서 승산이 있음을 깨달았다.&lt;/li&gt;
&lt;li&gt;문장만 길지, 풀이 패턴이 비슷한 것을 확인 할 수 있었다.&lt;/li&gt;
&lt;li&gt;이해가 가지 않는 문장까지 완벽히 해석해야, 제대로 된 결과값을 도출 할 수 있다는 사실을 깨달았다.&lt;/li&gt;
&lt;li&gt;처음 코드를 작성했을때 보다, 점점 클린한 코드가 만들어지는 것을 보았다.&lt;/li&gt;
&lt;li&gt;기존 로직을 계속 수정하는 것 보다, 아예 처음부터 다시 코드작성을 하는 것이 완성도나 성공률이 높음을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;감을 잃지 않고, 긴 문장에 대한 두려움을 없애기 위해 매일 최소 1개의 알고리즘 문제를 풀어보아야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-02. 팀원들이 알고리즘 문제를 풀 수 있도록 도와주었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀원들이 정말 쉬운 문제임에도 불구하고, 어떤 순서로 문제를 풀어야 할 지 혼란스러워하는 모습을 보고 안타까웠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀원들에게 어떤식으로 문제를 풀려고 하는지 말해달라고 부탁드렸는데, 대부분의 팀원이 조건문을 어디에 사용할지, 반복문을 어디에 사용할지부터 고려하시는 모습을 볼 수 있었다.&lt;/li&gt;
&lt;li&gt;기술의 사용보단, 문제를 어떻게 풀어나갈 것인지 먼저 간단한 말로 정의해보라고 말씀드렸고, 처음엔 어려워하시는 모습을 보이셨지만 조금씩 이해하시는 모습을 볼 수 있었다.&lt;/li&gt;
&lt;li&gt;다음날 많은 팀원들이 주어진 문제를 풀고 기뻐하는 모습을 볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타인들에게 긍정적인 영향력을 끼칠 수 있는 프레젠테이션을 주도적으로 해봐야겠다고 생각했다. 내 영향력으로 다른사람들이 좋은결과를 보는 것은 정말 기쁜일이란 것을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-03. 객체지향의 개념을 공부했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체지향이 지향하는 세계관이 매우 재미있게 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체지향이 지향하는 바에 재미를 느낀 뒤, 몰입도가 상승하면서 빠르게 개념들을 흡수하는 내 모습을 볼 수 있었다.&lt;/li&gt;
&lt;li&gt;객체가 단순히 모방이 아닌 새로운 세계를 창조하기 위함임을 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 것에 빠르게 몰입하기 위해선, 그것에 대한 세계관, 지향점, 스토리를 우선적으로 학습하고, 세계관에 공감하고 재미를 느낄 수 있는 상황을 만들어야겠다고 생각했다.&lt;/li&gt;
&lt;li&gt;일단은 자바의 객체지향을 학습중이니, 객체지향 세계관에 대한 몰입을 최대한 유지 할 수 있도록 노력해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-04. 자바 용어를 잡고, 메모리구조를 파악했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바언어에 대한 이해가 어려웠고, 용어들에 대한 정리가 잘 되지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바의 기반이 되는 JVM 메모리구조에 대해 학습하고, 그것을 기반으로 용어정리를 하니, 더욱더 이해가 잘되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실습기반의 이해도 좋지만, 기본이론에 대한 학습이 우선 되야하는 것은 불가피한 것임을 깨달았다.&lt;/li&gt;
&lt;li&gt;해당 언어에 대한 몰입을 유지해가면서, 복잡하게 느껴지는 이론은 메모리구조부터 차례대로 학습하도록 해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-05. 2일 연속 지각을 했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀원들에게 부끄러웠고, 나 하나의 지각으로 인해 팀원들의 학습분위기가 어수선해짐을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내 몸이 생각보다 건강하지 않음을 깨달았다.&lt;/li&gt;
&lt;li&gt;핸드폰을 늦게까지 보고, 생각이 꼬리를 무는 현상이 지속됨에 따라 자는시간에 다른 것들을 찾아보게 되면서 새벽까지 깨어있는 상황이 반복되었다.&lt;/li&gt;
&lt;li&gt;이것이 꼬리를 물고 다음날 컨디션 저하까지 이어지는 모습을 볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나뿐만아니라 남을 위해서라도, 스케쥴과 컨디션 관리는 꾸준히 해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;긴 기간의 마라톤을 위해 정해진 수면시간은 꼭 챙겨야겠다는 다짐을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-18 Today I Learn]]></title><description><![CDATA[객체지향 객체지향개론…]]></description><link>https://mitoconcrete.github.io/22_11_18/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_18/</guid><pubDate>Fri, 18 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[객체지향] 객체지향개론&lt;/h2&gt;
&lt;h3&gt;1. 객체지향이란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;객체는 현실의 사물을 지칭하는 말이다. 이것이 상호작용하며, 우리는 살아간다.&lt;/li&gt;
&lt;li&gt;객체지향의 첫 등장은 &lt;strong&gt;시뮬레이션&lt;/strong&gt; 이었다. 현실의 사물을 가상세계로 이동시켜 시뮬레이션함으로서 시/공간적 리소스를 절약하기 위함이었다.&lt;/li&gt;
&lt;li&gt;따라서, 객체지향이 지향하는 것은 객체와 객체간 상호작용으로 구성된 현실을 모방한 새로운 세계를 탄생시키는 것 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 객체의 의인화&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현실의 존재는 객체화가 되며, 추상적인 것들 조차도 구체적인 모습으로 변화한다.&lt;/li&gt;
&lt;li&gt;즉, 조금은 능동적으로 움직일 수 있는 상태가 된다.&lt;/li&gt;
&lt;li&gt;클래스 안에 존재하는 속성들은 실제세계의 속성들로 구성되어야 한다. 이런 속성들은 또 다른 객체(유/무형의 개념도 포함)로 이뤄져 있고, 따라서 객체는 객체로 이뤄진다고 말할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 객체지향 설계 핵심&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메시지를 전송/전달 :&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체들의 상호작용은 어떠한 요청을 전달하고 전달받으며 이뤄진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;객체 간 협력 :&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체마다 특정한 &lt;strong&gt;역할&lt;/strong&gt;과 &lt;strong&gt;책임&lt;/strong&gt;이 부여되고, 서로에게 메시지를 전달-전송하며 협력하며 목표를 달성한다. 이런 상호협력이 잘 이뤄지지 않는다면, 프로그램의 신뢰도가 저하되고 이는 즉 프로그램의 품질저하로 이어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 핵심 키워드&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;객체지향은 역할, 책임을 가진 객체들이 메시지를 주고 받으며 협력하는 관계로 프로그램을 구성한다. 따라서, 클래스보단 객체에 집중을하는 게 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5.[CS] 프로세스와 스레드&lt;/h2&gt;
&lt;p&gt;프로그램이 RAM(주 기억장치)에 올려져 실행될 때는, 단독으로 실행되는 것이 아니라 CPU로부터 자원을 할당받아 실행된다.
이 때 자원을 할당받는 단위를 &lt;strong&gt;프로세스&lt;/strong&gt; 라고 칭하며, 프로세스 내에서 일을 수행하는 단위를 &lt;strong&gt;스레드&lt;/strong&gt;라고 한다.&lt;/p&gt;
&lt;h3&gt;1. 프로세스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU로 부터 독립된 메모리공간을 할당 받는다. 이때 할당받은 공간을 다시 여러공간으로 나누어 관리하는데 이를 &lt;strong&gt;프로세스 공간&lt;/strong&gt;이라고 한다. 구성은 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Code&lt;/li&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;멀티 프로세스는 이런 프로세스를 여러개를 사용하여 프로그램의 연산을 수행하는 것을 의미한다. 프로세스는 각기 독립적이기 때문에 멀티프로세스 환경에서는 1개의 프로세스 다운이 프로그램에 큰 영향을 미치지 않는다. 다만, 프로세스가 변경될 때마다 &lt;code class=&quot;language-text&quot;&gt;Context Switching&lt;/code&gt;으로 인해 많은 리소스를 사용하게되며, &lt;code class=&quot;language-text&quot;&gt;IPC통신&lt;/code&gt;을 사용하여 서로의 자원을 공유하는데 이는 연산이 복잡하여, 많은 부하를 주게된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 스레드&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스 공간&lt;/strong&gt;에서 Code, Data, Heap 영역을 공유하고, 각 스레드 마다의 Stack을 가지게 된다.&lt;/li&gt;
&lt;li&gt;공간을 공유하기 때문에, Context Switching이나 IPC 통신같이 오버헤드를 주는 상황이 없다. 따라서, 자원공유가 매우 빠른 속도로 가능하다. 또한 가까운 위치에 있는 자원을 공유하기 때문에 비용이 적게 소모된다.&lt;/li&gt;
&lt;li&gt;단, 같은 공간을 공유하기 때문에 데이터의 무결성을 저하시키기도한다. 같은 데이터에 접근했을경우 해당 데이터에 대한 신뢰를 보장하지 못한다. 이는 프로세스 내의 모든 스레드에 영향을 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221118&lt;/h2&gt;
&lt;p&gt;어제 그렇게 다짐을 했지만, 오늘은 12시 30분에 일어나는 미친짓을 해버렸다. 심지어 어젠 정말 일찍잠들었는데..
상황은 벌어졌기에, 팀원들과 매니저님들께 연락드리고 죄송하단 말씀을 드렸다. 의도치않게 신뢰를 깨고 있는 것만 같아 정말 죄인이 된 것만 같았다.
남은 기간은 절대 늦지 말아야지..&lt;/p&gt;
&lt;p&gt;오늘은 객체지향이 무엇인지에 대한 세션이 마련되었다. 하루종일 자바의 정석 객체지향파트를 읽으면서, 객체지향의 세계에 매료되고 있었는데, 튜터님의 세션은 약간 세계관 설명과 같은 느낌이 있었다. 그래서 더욱더 몰입이 잘되었다.&lt;/p&gt;
&lt;p&gt;좋은 징조라고 느껴졌다. 일 경험이 많다고는 할 수 없지만, 내가 잘한다고 평가받았던 대부분의 일은 그 회사의 세계관 즉 미션에 깊이 공감하는 것 들이었다.
맥도날드알바를 과거에 꽤 오래했었다. 알바생들을 관리하는 크루트레이너라는 자리에 올랐었는데, 맥도날드는 해본사람은 알겠지만 업무분담이 꽤 정확하게 구분되어 있다. 포지션이 구분되어있고, 포지션마다 맡은 역할이 있다. 나는 이렇게 포지션을 지켜 각자 업무를 하는 것 만으로도 음식의 퀄리티가 보장되는 것에 큰 흥미를 느꼈고, 이런 시스템을 갖추고 있는 맥도날드의 시스템에 매료되었다. 어떻게 해야 동선을 더 줄일 수 있을까, 어떻게 해야 더 빨리 만들 수 있을까? 하는 고민을 항상했고, 그 결과 매장 내에서 손이 빠른 사람 중 한명으로 등극(?)하게 되었다.&lt;/p&gt;
&lt;p&gt;두번째로는 군대에서의 경험인데, 나는 공군을 나왔고 공군에 간 목적이 확실히 있었다. 청주에 친한 친구들 2명이 근무를 하고 있었고, 거기에 가야만 했다. 공군은 시험성적 순으로 자대를 배치하기 때문에, 내가 원하는 자대에 가기 위해선 높은 성적을 받아야만 했다. 공부만 잘해선 안되고, 태도점수가 크게 반영이 되고 그 비중이 꽤 높았다. 따라서, 의도치 않게(?) 모범생이 되버렸는데, 제식이나 생활측면에서 높은점수를 받고 수료했다. 군대에 대해 계속 공부하다보니, 세계관에 매료되어 재미를 느껴버렸고, 이게 좋은결과로 이어진 것이다. 이런 나를 좋게봤던 빨간모자 조교님이 &apos;넌 내 후임이 되었으면 좋겠어&apos;라며 따로 불러 말씀해주신 덕에, 조교 면접까지 보았지만, 결국은 조교가 되지 않았다는것은 여담이다.&lt;/p&gt;
&lt;p&gt;마지막으로는 라이프가드 일을 할 때 였는데, 내가 일하던 라이프가드는 퀄리티를 위해 미국에서 라이프가드 교육업체를 불러 관리를 하고 있었다. 따라서, 주기적으로 불심검문이나 실상황시뮬레이션같은게 많이 진행되었다. 또한, 이는 내 평가점수와 직결되었다. 일단 공부는 열심히 했는데, 마냥 걸어다는 것은 정말 지루했다. 그러던 찰나에, 눈앞에서 어떤 아이가 빠져 허우적대는것을 보았고, 부모님들은 수심이 얕은 곳이라 방심했는지 보지 못하였다. 내가 그 아이를 구했을 땐 물을 너무많이 먹어서, 구토를 할 정도로 좋은 상태는 아니었다. 그 아이의 얼굴을 보고 난 이후로 부턴, 더더욱 라이프가드 세계관에 빠져들었다. 하루종일 누군가를 구하는 시뮬레이션을 돌리고, 어느구역에서 익수자가 발생한다면 어떻게 할지 프로토콜도 모두 세워놓았다. 어느새 나는 신뢰받는 동료가 되어있었다.&lt;/p&gt;
&lt;p&gt;길게 옛날 이야기를 했지만, 내가 객체지향에 대한 세계관을 들으면서 생각이 들었던 것은 매트릭스의 세계관이었다. 나는 매트릭스라는 영화를 매우 재미있게 봤고 아직도 돌려본다. 객체가 지향하는것은 현실의 모방이기 때문에, 학습하면서 점점 흥미를 느끼게 되었고, 이런 세상을 만드는 방법에 공감이 되자마자 한순간에 몰입이 되었다. 그 이후로, 어떤 개념을 학습하고 설명하는 것이 재미있게 느껴지고 있다. 계속 이 몰입을 유지하면서 튼튼하고 빈틈없게 누구보다 객체지향 세계를 만들 수 있는 사람이 되고싶다는 생각을 하게 되었다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-17 Today I Learn]]></title><description><![CDATA[…]]></description><link>https://mitoconcrete.github.io/22_11_17/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_17/</guid><pubDate>Thu, 17 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[객체지향] 객체란?&lt;/h2&gt;
&lt;p&gt;실제로 존재하는 유형의 물체 혹은 무형의 개념/이론을 통칭하는 말이다.&lt;/p&gt;
&lt;h2&gt;[객체지향] 소프트웨어란?&lt;/h2&gt;
&lt;p&gt;변화가능 한 것. 하지만, 시간이 지남에 따라 변화에 대한 비용이 줄어들어야 하는 것.&lt;br&gt;
시간이 지남에 따라 변화에 대한 비용이 늘어난다면, 잘못된 소프트웨어일 확률이 높다.&lt;br&gt;
객체지향은 변화에 대한 비용을 감소시키기 위한 디자인패턴 중 하나이다.&lt;/p&gt;
&lt;h2&gt;[Java] 생성자?&lt;/h2&gt;
&lt;p&gt;생성자는 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;키워드를 이용해 인스턴스를 초기화 메서드이다. 생성자로 정의된 매개변수를 통해 이 객체가 생성된 의도를 파악 할 수 있음.&lt;/p&gt;
&lt;h2&gt;[Java] 클래스? 인스턴스? 객체?&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;클래스&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;인스턴스&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;인스턴스를 정의한 명세이다.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;클래스를 new 키워드를 이용하여 실체화 시킨 객체이다.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;인스턴스를 총칭하는 포괄적 개념이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;붕어빵 틀로 많이 부르곤 한다.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;실체화 하는 과정을 &apos;인스턴스화&apos; 한다고 칭하며, 인스턴스는 JVM의 힙에 저장되어 사용된다.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;객체 &gt; 인스턴스&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;[Java] void&lt;/h2&gt;
&lt;p&gt;반환 타입으로 void를 명시해주면, 자바컴파일러는 암묵적으로 void함수에 &lt;code class=&quot;language-text&quot;&gt;return ;&lt;/code&gt;을 넣어준다.&lt;/p&gt;
&lt;h2&gt;[Java] Primitive Type vs Wrapper Class&lt;/h2&gt;
&lt;p&gt;ex)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int vs Interger&lt;/li&gt;
&lt;li&gt;boolean vs Boolean&lt;/li&gt;
&lt;li&gt;long vs Long&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Primitive Type&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Wrapper Class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;메모리에 곧바로 값이 저장된다.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;원시타입을 객체로 구현한 것으로서 저장 시, 객체의 참조위치가 저장된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Boxing :&lt;/strong&gt; Primitive Type -&gt; Wrapper Class&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unboxing :&lt;/strong&gt; Wrapper Class -&gt; Primitive Class&lt;/li&gt;
&lt;li&gt;JDK 1.5부터는 auto boxing/unboxing 을 지원하게 되어 명시적으로 형변환을 해줄 필요가 없어짐.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Java] 매개변수(parameter) vs 인자(argument)&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 매개변수&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Phone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Phone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// &amp;lt;= 이렇게 받아올 변수들을 정의하는 것을 매개변수&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 인자&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Phone&lt;/span&gt; phone &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Phone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;갤럭시&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &amp;lt;= 이렇게 전달하는 것을 인자&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Java] 원시형 매개변수 vs 참조형 매개변수&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;원시형 매개변수&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;참조형 매개변수&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Read 가능&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Create, Read, Update, Delete 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;인자로 전달한 것과 별개로 동작한다.&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;인자로 전달한 것의 주소를 참조하여, 전달받은 인자에 영향을 준다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;[Java] 객체 변수 종류&lt;/h2&gt;
&lt;p&gt;객체의 변수에는 멤버변수와 지역변수가 있다.&lt;br&gt;
그 중에서도 멤버변수는 클래스변수와 인스턴스변수로 분리된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Phone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 멤버변수 시작&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; phoneNumber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;//1. 클래스 변수&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//2. 인스턴스 변수&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 멤버변수 끝&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getPhone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; phoneDetailName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//3. 지역변수&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1. 클래스 변수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- `static`키워드로 선언 된 변수로서, 클래스 메모리에 올라가게 된다.
- 메모리 저장 시점은 단 1회로서, 컴파일러는 클래스 변수를 가장먼저읽어, 클래스 메모리로 이동시킨다.
- 이 때 클래스 변수는 생성자를 이용한 선언없이 사용이 가능하다.

```java
Phone.phoneNumber
```&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 인스턴스 변수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- new 키워드를 통해 **인스턴스가 생성된 시점**에 힙메모리에 올라간다.
- 이곳에 주소값을 두고, 콜스택에 이 주소값을 쌓아서 사용한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 지역 변수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 메소드 내에서만 사용 할 수 있는 변수이다.
- 각 메소드의 런타임 즉, 스택에서 invoke가 시작 될 때 유효해진다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Java] 객체 메소드 종류&lt;/h2&gt;
&lt;p&gt;객체의 메소드는 클래스 메소드와 인스턴스 메소드가 있다.&lt;/p&gt;
&lt;h3&gt;1. 클래스 메소드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;static 키워드로 선언된 메소드로서, 인스턴스 변수나 인스턴스 메소드를 사용하지 않는 것을 클래스 메소드라고 한다.
따라서, 클래스 메소드안에서 인스턴스 변수를 사용할 수 없다. 왜냐하면, 클래스 메소드가 사용가능한 시점은 인스턴스가 생성되지 않은 시점이기 때문이다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 인스턴스 메소드&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;인스턴스 변수를 필요로 하는 메소드. 인스턴스 생성 된 후이기 때문에 인스턴스 변수와 클래스 변수를 모두 사용 할 수 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Java] 인터페이스 vs 추상클래스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;추상 클래스는 부모의 기능을 확장할 때 사용한다. 주로, 상속관계가 확정적일 때 주로 사용. 수직적 확장. (템플릿 메소드 패턴 검색)&lt;/li&gt;
&lt;li&gt;인터페이스는 객체들에 대한 동일한 동작을 보장하기 위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Java] 객체지향의 3가지 특성과 구현예시&lt;/h2&gt;
&lt;h3&gt;1. 캡슐화&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 객체가 어떻게 동작하는지 외부에 노출을 막는다.
- 객체내부의 기능이 변경되도, 외부에는 큰 영향을 끼치지않는다.
- 접근제어자를 통해 구현한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 추상화&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 어떤 사물의 특성에서 공통적인 특성/성질을 뽑아 의미있는 표현으로 정의한다.
- 예를 들어, 카카오톡, 메시지, 메일에는 &apos;전송&apos;이라는 동일동작이 있다. 하지만, 각기 전송을 하기 위한 조건이 다르다. 따라서, 추상적 명세로 &apos;전송&apos;이라는 동작을 인터페이스에 정의해놓고, 그것을 클래스에서 실행하되 오버라이딩을 통해 자신의 특성에 맞게 정의하여 실행 시킬 수 있다.
- 어떤 특정한 변경없이, &apos;전송&apos;이라는 하나의 동작 키워드로 카카오톡, 메시지, 메일모두에게 명령을 내릴 수 있도록 한다. 즉, kakaoSend/MessageSend/EmailSend 에 대한 메소드구현없이 Send라는 메소드를 갖고와서 자신의 특성에 맞게 사용할 수 있는 것 이다.
- 인터페이스/추상클래스를 통해 구현한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 다형성&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 특별한 비용없이, 다양한 타입을 갖는것이 가능해지는 특성이다.
- 업캐스팅과 오버라이딩을 통해 구현이 가능하다.
- 업캐스팅이란 부모 클래스로 형변환을 하여 자식클래스를 선언하는 것.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Plug&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Plug on&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InternetOfThings&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartPlug&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Plug&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InternetOfThings&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

     &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Smart&lt;/span&gt;냉장고 &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Plug&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InternetOfThings&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

     &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SmartPlug&lt;/span&gt; smartPlug &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartPlug&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
smartPlug&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
smartPlug&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Plug&lt;/span&gt; plug &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; smartPlug&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
plug&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
plug&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;InternetOfThings&lt;/span&gt; iot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; smartPlug&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
iot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; smart냉장고&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//........&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ......&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
iot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; smartPlug&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
iot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; smart냉장고&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 비즈니스 로직&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
iot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 냉장고&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 iot는 스마트냉장고, 스마트플러그등 다향한 상태를 받아올 수 있다.
한개의 변수가 다양한 변수타입을 가질 수 있는 것을 다형성이라고하고, 이는 상속,실행을 업캐스팅함으로서 구현 할 수 있다.&lt;/p&gt;
&lt;h2&gt;[Java] 초기화 블럭&lt;/h2&gt;
&lt;h3&gt;1. 클래스 초기화 블럭&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;static&lt;/code&gt; 키워드로 정의하는 초기화 블럭으로서, 클래스가 생성되는 시점을 볼 수 있다. 클래스 변수를 초기화 할 때 사용한다.&lt;/p&gt;
&lt;h3&gt;2. 인스턴스 초기화 블럭&lt;/h3&gt;
&lt;p&gt;인스턴스가 생성되기 직전에 사용되는 초기화 블럭으로서, 클래스 변수와 인스턴스 변수 모두에 접근가능하다.&lt;/p&gt;
&lt;h2&gt;[Java] 멤버변수의 초기화 시기와 순서&lt;/h2&gt;
&lt;p&gt;(클래스 별로 1회만 실행됨) 클래스 로딩 -&gt; 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭 -&gt; (인스턴스 생성마다 반복됨) 인스턴스 생성 -&gt; 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자&lt;/p&gt;
&lt;p&gt;아래는 2개의 인스턴스를 생성하고, 어떤 순서로 시행되는 지 로그를 찍어본 것이다.
클래스 초기화는 단 1회만 시행되고, 인스턴스 생성마다 초기화가 진행되는 모습을 확인 할 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221117_01.png&quot; alt=&quot;멤버변수 초기화&quot;&gt;&lt;/p&gt;
&lt;h2&gt;[회고] 221117&lt;/h2&gt;
&lt;p&gt;오늘부터 자바의 꽃인 객체지향을 학습하게 된다. 일단, 실제 사례를 통해 어떤식으로 객체지향개념이 적용되는지 명확히 볼 수 있었다. 몇년간 암기식으로만 외우던 것을 실제 사례를 보면서하니, 확 와닿았고, 너무 재미있었다.&lt;/p&gt;
&lt;p&gt;오늘은 몸이 좋지 않았다. 코감기가 심하게 오는지 어지럽고 피곤한 상태가 지속되었다. 계속 꾸벅꾸벅졸다가 이건 아닌 것 같아서 병원에 다녀왔는데 몸이 금방나아져서 공부에 집중 할 수 있었다. 갈까 말까 고민했는데, 결론적으로 이런 상황에서 팀의 분위기를 저해하지 않기 위해서는 내 몸상태에 대해서 빠르게 파악하고 대처하는 것도 능력이겠다 생각했다. 내가 조는걸 보고 다른 팀원 분들도 괜시리 집중을 못하는 것 같아 죄송했다. 다녀와서 공부가 잘되니, 팀원들이랑 소통도하고, 질문도 주고받았다. 내가 활발해지니, 팀의 분위기가 조금은 올라가는 것처럼 느껴져 기분이 좋았다. 모난 행동을 하는 것은 아주 사소한 것도 팀이 나가는 방향에 방해가 될 수 있다는 자각을 항상 해야겠다.&lt;/p&gt;
&lt;p&gt;오늘 하루종일 자바의 정석을 보면서, 자바학습을 했다. &lt;strong&gt;객체지향프로그래밍I&lt;/strong&gt; 을 보며 공부했는데, 내가 자바스크립트 공부할 때 어렵다고 간과했던 메모리 동작부가 나왔다. 과거에 이걸 간과하고 개발한 것이 너무 마음에 걸려서, 새로운 언어를 배움에 따라 엔진동작부터 천천히 시작하고자 했다. 생각보다 어렵게 다가오지 않았다. 또한 각 영역에 대한 이해를 하고나니, 지루하게 읽히던 책이 재미있게 다가왔다.&lt;/p&gt;
&lt;p&gt;다만, 확실하게 이해했다고 생각했지만, 동작순서에 대한 질문이 들어왔을땐 등땀이 주르륵 흐르면서 입밖으로 내뱉질 못했다. 이것또한 모르는것이기 때문에, 자신감있게 입밖으로 개념을 뱉을 수 있도록 곱씹어야겠다는 다짐을 했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-16 Today I Learn]]></title><description><![CDATA[회고 221116 "죽을 때 까지 코딩하는 법"…]]></description><link>https://mitoconcrete.github.io/22_11_16/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_16/</guid><pubDate>Wed, 16 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221116&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&quot;죽을 때 까지 코딩하는 법&quot;&lt;/strong&gt; 1회 완독&lt;br&gt;
&lt;strong&gt;&quot;죽을 때 까지 코딩하는 법&quot;&lt;/strong&gt; 을 완독했다. 정말 소중한 글귀들이 너무 많다. 길게 갈 수 있는 개발자가 되기 위한 마인드셋과 환경을 찾는법, 그리고 어떤 환경에서 일을 해야할지에 대한 정보를 얻을 수 있었다. 또한, 책 자체가 읽기 부담스럽지 않고, 정말 이야기하듯이 적은 책이라 재미있고, 부담없이 다가왔다. 일단 1회독 했으니 여유 될 때 2회독 3회독 해서 이 안에 있는 글을 체득해야겠다는 생각을 했다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전 팀원들의 발전을 보다&lt;br&gt;
직전 팀원 분들이 알고리즘 문제를 푸는 것을 너무 두려워하는 것이 느껴져, 전 날 늦게까지 함께 문제를 풀었었다. 어쩌다 보니 코딩쇼가 되었지만, 팀원 분들이 공통적으로 알고리즘을 접했을 때 어디부터 손을 대야 할 지 감을 못잡으시는게 보여, 짧은 실력이지만 코딩인터뷰 하듯이 말하면서 내가 푸는 과정을 공유했다. 그동안 깨달은 점을 공유드리면서 문제를 풀었는데 짚어드린 순서는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;문제를 먼저 완벽히 이해한다.&lt;/li&gt;
&lt;li&gt;개발 용어를 배제한 현실 언어로, 문제를 풀기위한 큰 순서를 정리한다.&lt;/li&gt;
&lt;li&gt;큰 순서를 기반으로 필요한 도구들을 구글링하여 리서치 하여 세부 순서를 결정한다.&lt;/li&gt;
&lt;li&gt;결정한 문제 풀이 순서대로 코드를 작성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;많은 팀원분들이 반복문, 조건문에 대한 사용에 부담을 느끼고 계신게 느껴졌고 &apos;도구를 잘 사용하는 것이 아닌 순서를 잘짜야 어디에 적절한 도구를 사용 할 수 있을지 이해 할 수 있다.&apos;라는 메시지를 전달드리고자 노력했다.&lt;/p&gt;
&lt;p&gt;드디어 대망의 타임어택 당일, 문제난이도는 어렵지않았다. 다만, 다른 팀원분들은 어려움을 겪으시는 것 같았다. 멘탈점검을 위해 DM을 드렸는데 다들 조금씩 문제를 풀어나가고 계셨고, 팀원들이 성장한게 보여서 너무 뿌듯했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221116_01.png&quot; alt=&quot;팀원들의 피드백&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;애증의 삼성문제를 드디어 풀어내다.&lt;br&gt;
알고리즘 수업에서 마지막에 전달받은 삼성문제를 풀어냈다.
아직은 혼자 힘으로 풀기엔 벅차서, 다른 사람들의 풀이법을 보았다. 하지만, 내가 참고한 것은 그들이 어떻게 문제를 이해했는지 였지, 로직을 베끼진 않았다.&lt;/p&gt;
&lt;p&gt;이 고집 때문에 한 문제를 2일간 푼거긴 하지만, 따라치기로 영혼없이 옮겨적는 것이 나한테 아무 영향을 줄 수 없다는 것을 깨달은 뒤로는, 다른사람의 풀이법을 참고는 하되 &lt;strong&gt;내가 이해 할 수 있는 로직/남이 봐도 깔끔한 로직으로 어떻게 바꿀 수 있을까&lt;/strong&gt;를 끊임없이 고민하고, 그것이 확정되는 순간 코드를 작성하고 있다.&lt;/p&gt;
&lt;p&gt;이해안되는 점에 대해 끊임없이 고민하고, 필요한 것은 적용하고, 필요하지 않은 것은 쳐내면서 온전히 내가 이해 할 수 있는 코드를 작성했다. 여러번 갈아치웠지만, 그 과정에서 계속적인 필터링이 일어나 최종본은 정말 군더더기 없이 로직이 작성되었다. 내가 초반에 설계한 순서에 맞고, 레퍼런스코드보다 이해하기 쉬웠기 때문에 모두 작성을 한 뒤 매우 뿌듯함을 느꼈다.
이런 코드는 정답인 경우가 많다.&lt;/p&gt;
&lt;p&gt;삼성, 카카오 등의 문제를 풀게 되면서 깨달은 점이 몇가지 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;문제를 &lt;strong&gt;정말 잘 완전히&lt;/strong&gt; 이해해야한다.&lt;/li&gt;
&lt;li&gt;중간에 이해하기 힘든 지문이 있는경우, 그걸 완벽히 이해한 뒤 진행해야 의도에 맞는 답을 얻을 수 있다.&lt;/li&gt;
&lt;li&gt;문제풀이가 결정되면 최대한 천천히 그리고 꼼꼼히 코드를 작성해야한다. 단, 코드를 작성하다 흐름을 놓치면 모두 지우고 다시 시작하는 것이 더 좋은 경우가 많다. 지우지 않고 진행하면 스파게티가 될 확률이 높다.&lt;/li&gt;
&lt;li&gt;문제풀이가 결정되도, 머릿속에서 주어진 예제가 어떻게 흘러가는지 상상해보고 그 흐름이 확실시 된 순간 코드를 작성하는게 성공률이 높다.&lt;/li&gt;
&lt;li&gt;DFS, BFS에서는 visited를 사용해야한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;과거 수학문제를 풀던 시절이 생각났다. 처음 풀 때 굉장히 오래걸린 문제는 같은 유형을 풀고 익숙해지면 기하급수적으로 푸는 속도가 줄어든다. 알고리즘문제도 수학문제를 푸는 것과 별반 다를 것이 없다는 것을 깨달았다. 두려워하지말고, 문제에 직면하고 풀어나가는 과정을 받아들이고 즐기자!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-15 Today I Learn]]></title><description><![CDATA[회고 221115 : 알고리즘에 패배했지만, 깨달음을 얻다. 오늘부로 모든 알고리즘 강의를 마쳤다. 주어진 삼성기출문제…]]></description><link>https://mitoconcrete.github.io/22_11_15/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_15/</guid><pubDate>Tue, 15 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[회고] 221115 : 알고리즘에 패배했지만, 깨달음을 얻다.&lt;/h2&gt;
&lt;p&gt;오늘부로 모든 알고리즘 강의를 마쳤다. 주어진 삼성기출문제 3문제 중에, 난 어느것도 빠른시간 내에 풀지 못했다.
좌절하기 보단, 하루걸리던 문제에 대해선 점차 시간을 조금씩 줄여나가야겠다는 다짐을 했던 것 같다.
문제를 제대로 이해하는 것이 우선이고, 그다음으로 문제를 풀어나가기 위한 순서를 잡는게 다음이라는 깨달음이 점점 문제를 풀다보니 들었다.
하지만 이게 고작 레벨2에 해당되는 문제이기 때문에, 중견이상 기업의 코딩테스트에 통과를 하기 위해선, 어마어마한 연습과 데이터가 쌓여야겠다는 생각을 했다.
꾸준히 천천히 가보자!&lt;/p&gt;
&lt;h2&gt;[다짐] 221115&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제 풀이 시, 문제에 대한 이해부터 제대로 하기&lt;/li&gt;
&lt;li&gt;내가 풀어나가는 방식에 자신감을 가지기&lt;/li&gt;
&lt;li&gt;너무 길어지는 코드에는 의심을 가지기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-14 Today I Learn]]></title><description><![CDATA[알고리즘 BFS, DFS 의 visited BFS와 DFS에서 visited를 기록하는 것과 기록하지 않는 것은, 퍼포먼스에서 큰 차이를 보인다.
다만 visited…]]></description><link>https://mitoconcrete.github.io/22_11_14/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_14/</guid><pubDate>Mon, 14 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[알고리즘] BFS, DFS 의 visited&lt;/h2&gt;
&lt;p&gt;BFS와 DFS에서 visited를 기록하는 것과 기록하지 않는 것은, 퍼포먼스에서 큰 차이를 보인다.
다만 visited는 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;의 시간으로 접근 할 수 있는 구조를 문제의 특성에 맞게 구성하고, 적용하는 능력이 중요하다.&lt;/p&gt;
&lt;h2&gt;[알고리즘] 중간회고&lt;/h2&gt;
&lt;p&gt;그동안 긴 문제를 보면 거부감이 느껴졌다. 따라서, 알고리즘 문제는 코딩테스트 이외에는 접할 기회가 없었다. 하지만, 반 강제적으로 요즘 매일매일 알고리즘 문제를 접하고 있는데, 느끼는 점은 긴 문장에도 별거아닌 문제가 많다는 것이다.&lt;br&gt;
가장 중요한 것은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제를 얼마나 잘 이해했는가&lt;/li&gt;
&lt;li&gt;풀어나가는 과정을 얼마나 순차적으로 진행 할 수 있는가
인 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요즘 알고리즘 문제를 접했을 때, 노트 문항을 요약하여 다시 정리하는 습관을 들이고 있다.&lt;br&gt;
이렇게 하니, 문제에 대한 이해도가 조금은 더 올라가 조금씩 정답에 접근하기 위한 순서가 잡히는 경험을 했다.&lt;br&gt;
가장 중요한 건, 내가 생각한 파훼법에서 &lt;em&gt;시간을 단축시키기 위한 방법을 얼마나 자유자재로 사용할 수 있는 가&lt;/em&gt;인 것 같다.&lt;br&gt;
이는 알고리즘 오답노트 작성을 통해서 이겨낼 수 있는 문제라고 생각한다.&lt;/p&gt;
&lt;p&gt;문제에 대한 두려움이 사라졌으니, 잘 이겨내 보자!&lt;/p&gt;
&lt;h2&gt;[회고] 221114 : 모닥불 개발자가 되기&lt;/h2&gt;
&lt;p&gt;요즘 읽고있는 책이 있다. &lt;strong&gt;&quot;죽을 때 까지 코딩하는 법&quot;&lt;/strong&gt;이라는 책인데, 내일배움캠프에서 보물찾기를 통해 받은 책이다.&lt;br&gt;
처음 봤을 땐 과한 워딩에 &apos;재미있겠다&apos;라는 막연한 생각을 갖고 있었는데, 읽다보니 뼈를 때리는 글귀가 많았다. 그래서 요즘은 시간나는대로 틈틈히 읽으면서 깨달음을 얻고 있다.&lt;br&gt;
요즘 읽고 있는 부분은 &apos;모닥불 개발자&apos;인데, 어떻게든 꾸준히 개발을 이어나가는 개발자들을 의미한다.&lt;/p&gt;
&lt;p&gt;반면 &apos;촛불 개발자&apos;는 화르륵불태우고 금방사라지는 수명이 짧은 개발자이다. 여태까지 나는 &apos;촛불 개발자&apos;에 가까운 행동양식을 보였다. 지식보단 경험에 의존한 의사결정을 했고, 꾸준히 공부를 하는 것 없이, 필요 때 마다 공부를 했다. 하지만, 개발자는 지식노동자로서, 꾸준한 자기계발과 학습을 해야만 한다. 이를 잘 할 자신이 없다면..나는 도태되는게 맞다고 생각한다. 도태 된 것이 맞아서, 이렇게 다시 공부를 하고있긴하지만..하하&lt;/p&gt;
&lt;p&gt;뭐든 개발커리어를 쌓기위해 꾸준히 하는게 중요한 것 같다. 나는 매번 &apos;시간이 없었다&apos;라는 핑계로 내가 해야만 하는 것들을 미뤘다. 작은 것을 꾸준히 하는 것이 중요한 것 같다.&lt;br&gt;
매번 면접때 마다 느꼈던 &lt;strong&gt;&lt;em&gt;아 뭐라도 꾸준히 해놓을 걸,&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;블로그 써놓을 걸&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;미리 공부할 걸&lt;/em&gt;&lt;/strong&gt; 등등의 후회에 대한 것들을 조금씩 습관으로 만들어서, 내가 선망의 대상으로 바라보았던 그런 개발자가 되어 모닥불 처럼 가늘고 길게 가고 싶다.&lt;/p&gt;
&lt;h2&gt;[다짐] 221114&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제를 접했을 때 무서워 하지말자&lt;/li&gt;
&lt;li&gt;개발에 대해서는 &apos;해보자&apos;라고 마음먹은 것에 대해 꾸준히 실천하기&lt;/li&gt;
&lt;li&gt;TIL 미루지 않기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-2nd Weekly I Learn]]></title><description><![CDATA[FACT-01. 자바강의를 1회독 하였다. FEELINGS…]]></description><link>https://mitoconcrete.github.io/22_11_2nd/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_2nd/</guid><pubDate>Sat, 12 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-01. 자바강의를 1회독 하였다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바의 객체지향은, 과거 국비지원학원에서 나를 그만두게 만든 원인 중 하나였다.&lt;/li&gt;
&lt;li&gt;따라서, 자바는 융통성 없고/단단하고/딱딱하고/자유롭지않은 이미지로 박혀있다. 언어를 배우는데 있어서 한발자국 한발자국이 무겁게 느껴진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 언어를 능숙하게 다룬 뒤, 다른 언어를 배우는 것은 많은 시간단축에 도움이 되고 있다.&lt;/li&gt;
&lt;li&gt;다만, 고정관념이 지속적으로 다음에 어떤것을 배울지 마음을 무겁게 하는 것은 있다.&lt;/li&gt;
&lt;li&gt;객체지향은 아직도 어렵지만, 매우 실용적인 프로그래밍 패턴이다. 인터페이스를 잘 이용하고 싶어졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내 마음을 힘들게 하는 것은 항상 다음 성장에 도움이 되었다. 따라서, 두려워하지말고 맞설 것 이다.&lt;/li&gt;
&lt;li&gt;알고리즘을 빠르게 끝내고 자바를 복습하면서, 프로젝트에 꼼꼼하게 대비할 생각이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-02. 자료구조와 알고리즘 강의를 듣고 있다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그래도 기본 자료구조와 기초 알고리즘에 대해선 익숙해진 것 같다.&lt;/li&gt;
&lt;li&gt;다만, 고급알고리즘인 DP는 정말 어려운 것 같다.&lt;/li&gt;
&lt;li&gt;문제의 난이도가 올라가면 문제에 사용된 알고리즘이 어떤건지 파악이 힘들다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;어렵지만, 문제를 고민하고 해결해 나가는 과정은 언제나 재미있다.&lt;/li&gt;
&lt;li&gt;나는 한번 정해진 솔루션은 끝까지 구현해내려는 고집이 있는데, 그것은 좋지 않은 태도 인 것 같다.&lt;/li&gt;
&lt;li&gt;처음엔 어렵게 느껴져도 한줄씩 천천히 풀어나가다 보면 결국엔 솔루션에 도달한 경우가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 솔루션에 대해 고집하려는 태도를 버리고, 다른 방법을 이용해서 파훼해보려고 노력해야겠다.&lt;/li&gt;
&lt;li&gt;내가 어려워하는 것이 확실해졌으니, 그것들에 대해 막막한 감정이 없어지도록 반복숙달해야겠다.&lt;/li&gt;
&lt;li&gt;너무 한번에 솔루션을 도출해내려고 하지말고, 문제 해결을 위한 순서를 적고 그대로 코드를 작성해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-03. 다른 팀원들과 한 팀원에게 return을 이해시키기 위해 시간을 썼다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쉽게 이해시켜드릴 수 있을 줄 알았지만, 그러지 못했다.&lt;/li&gt;
&lt;li&gt;컴퓨터 사고가 익숙하지 않은 사람들에게 컴퓨터 사고를 이해시키는 것은 생각보다 어려웠다.&lt;/li&gt;
&lt;li&gt;다른 사람이 제시하는 솔루션에 대해 스스로 평가하고, 적절한 솔루션과 적절하지 않은 솔루션을 무의식적으로 구분했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;많은 설명보다, 상대의 레벨에 맞는 짧은&apos;한 줄&apos;이 상대방의 이해에 도움이 되었다.&lt;/li&gt;
&lt;li&gt;생각이 한 번 트인상대를 이해시키는 것은 어렵지 않았다.&lt;/li&gt;
&lt;li&gt;결과적으로, 모든 팀원들의 한마디 한마디가 모여 팀원의 이해를 도울 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이해를 하기 위해서는 먼저 이해도를 진단해야한다. 보통 로우레벨로 갈수록 그림이 늘어나고 하이레벨로가면 그림은 사라지고, 명확한 한 줄만 남는다. 다만, 경우에 따라 명확한 한 줄이 로우레벨의 인원에게 도움을 줄 수 있다. 상대방의 문제에 대한 이해를 온몸으로 이해 한 뒤, 솔루션을 제시해야한다. 그렇지 않으면 상대방은 솔루션을 받아들이지 못한다.&lt;/li&gt;
&lt;li&gt;또한 의미없는 솔루션은 없다. 도움을 주려는 사람이 악의 구렁텅이에 빠뜨리려고 유도하는 것이 아니라면, 굳이 타인의 도움을 적절하지 않다고 스스로 판단해서 막을필요는 없다. 내가 다른사람의 도움을 평가 해서는 안된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-04. 질문 답변하는 과정에서 나혼자 기분이 좋지 않았던 순간들이 있었다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 드린 솔루션으로 문제가 해결 된 뒤, 다른 솔루션이 달렸을 때 기분이 좋지않았다.&lt;/li&gt;
&lt;li&gt;다른 사람들이 문제와 관계없거나, 딥한 개념들을 늘어놓는다고 생각이 되면 기분이 좋지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;어떤 결론이 났을 때 &apos;내말이 맞다&apos;라는 생각과 고집을 아직도 놓지 못했다고 느꼈다.&lt;/li&gt;
&lt;li&gt;다른 사람들 보다 많이 아는 것을 계속 의식한다고 생각했다.&lt;/li&gt;
&lt;li&gt;경력이 쌓여서 기분이 좋지 않았다고 하기엔, 나는 과거부터 비슷한 패턴에서 비슷한 기분을 느꼈다. 내가 아닌 다른사람이 자신의 지식을 뽐내면 나보다 잘하는 것을 보면서 샘을 냈던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들이 나를 볼 때도 마찬가지로 그렇게 느꼈을 것 같다는 생각을 했다. 그러면서도 이 필드가 자신의 지식을 뽐내야 하는 필드라는 것을 계속 망각한다&lt;/li&gt;
&lt;li&gt;샘을 내기보단, &apos;좀 치는데? 잘하는데?&apos; 라는 인정의 감정으로 돌려야 할 것 같다. 또한 그 목적이 첨언을 하는 것 이라면, 더더욱 샘을 내면 안된다. 그들도 시간을 내서 내 답변을 &apos;보충&apos; 해준것이다.&lt;/li&gt;
&lt;li&gt;따라서, 다른 사람의 첨언에 대해 부정적인 감정보단 긍정적인 감정을 느끼려고 노력하고, 필요한 부분들/몰랐던 부분들은 자존심을 내려놓고 흡수하자! 마치 조던을 카피하는 코비브라이언트처럼! 언젠가 나도 그들 이상의 레벨에 오를 수 있다.&lt;/li&gt;
&lt;li&gt;열린 마음으로 상대방의 의견을 수용하고, 나 또한 열심히 내 지식을 자랑해야겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-11 Today I Learn]]></title><description><![CDATA[알고리즘 그래프 노드간의 연결관계 및 방향성에 초점이 맞춰져있는 자료구조 1-…]]></description><link>https://mitoconcrete.github.io/22_11_11/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_11/</guid><pubDate>Fri, 11 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[알고리즘] 그래프&lt;/h2&gt;
&lt;p&gt;노드간의 연결관계 및 방향성에 초점이 맞춰져있는 자료구조&lt;/p&gt;
&lt;h3&gt;1-1. 방향성을 이용해 그래프를 표현하는 법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;유방향 그래프 : 노드의 종착점에 화살표를 이용해 다음 노드를 향하도록 함.&lt;/li&gt;
&lt;li&gt;무방향 그래프 : 노드간 연결에 화살표가 그려져 있지 않은 그래프&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1-2. 그래프를 표현하는 방법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인접행렬 : 2차원 배열을 이용하여, x -&gt; y 를 (x,y) 번째 배열에 체크를 하는식으로 표현한다.&lt;/li&gt;
&lt;li&gt;인접리스트 : 각 노드의 인접노드를 배열에 담아 딕셔너리에 저장하는 방식&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;두 방식의 차이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;공간 vs 시간&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;인접행렬은 2차원배열이기 때문에 접근이 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(N^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;의 속도를 보장한다. 하지만, 배열을 사용하기 때문에 상대적으로 적은 공간을 사용한다.&lt;/li&gt;
&lt;li&gt;인접리스트는 딕셔너리를 이용하기 때문에 많은 공간을 사용한다. 접근이 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;의 속도를 보장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1-3. DFS&lt;/h3&gt;
&lt;p&gt;깊게 파고들어가 노드를 살펴보는 방식이다. 자식을 파고들어가야하기 때문에 &lt;strong&gt;스택&lt;/strong&gt;을 이용하여 구현하는것이 용이하다.&lt;/p&gt;
&lt;h3&gt;1-4. BFS&lt;/h3&gt;
&lt;p&gt;횡으로 모든노드들을 찬찬히 살펴보는 방식이다. &lt;strong&gt;큐&lt;/strong&gt;를 이용하여 구현한다.&lt;/p&gt;
&lt;h2&gt;[알고리즘] DP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;겹치는 부분문제(Overlapping Subproblem) : 공통의 규칙을 찾아 문제를 쪼갠다.&lt;/li&gt;
&lt;li&gt;메모이제이션(Memoization) : 결과를 기록하여 다시 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[CS] CPU 전반전 개론&lt;/h2&gt;
&lt;h3&gt;3-1. CPU의 발전&lt;/h3&gt;
&lt;p&gt;CPU는 싱글코어에서 멀티코어로 발전해오고 있다. &lt;em&gt;무어의 법칙&lt;/em&gt;에 의하면, 매년 2배씩 프로세스의 성능은 발전하고 있는데 왜 갯수를 늘리는 방식을 선택할까.
성능의 향상은 발열과 직접적인 관계가 있다. 발열을 잡는데는 한계가 있기 때문에, 횡으로 갯수를 늘려 성능을 보장하는 방법을 택하고 있다.&lt;/p&gt;
&lt;h3&gt;3-2. CPU의 구성&lt;/h3&gt;
&lt;p&gt;CPU는 여러개의 코어로 구성되어 있고, 그 코어는 여러개의 레지스터로 구성되어있다.
1개의 레지스터는 1개의 상태를 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CU(Control Unit)&lt;/strong&gt;
프로그램이 보낸 연산요청을 특정레지스터에 저장해놓았다가, 가져온 뒤(fetch) 해석(decode)하여, 연산이 필요한 것들을 &lt;strong&gt;ALU&lt;/strong&gt;에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALU(산술논리연산자)&lt;/strong&gt;
산술논리연산을 통해 반환한 결과를 프로그램에 전달한다. 이후, 프로그램 메모리의 상태가 변경된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;캐시&lt;/strong&gt;
디스크와의 연산에 대한 핑퐁시간을 줄이기 위해, 빈도가 잦은 연산을 저장하여 핑퐁시간을 줄임.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;캐시 일관성에 대해 조사해보기&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3-3. 레지스터의 구성과 기능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;구성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;범용(general purpose)&lt;/li&gt;
&lt;li&gt;특수용(special purpose)&lt;/li&gt;
&lt;li&gt;PC(Program Counter) register : 명령어를 순차적으로 실행할 수 있도록 돕는 레지스터&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3-4. CPU와 프로그래머는 어떻게 통신할까?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPU는 바이너리만 알아들을 수 있다.&lt;/li&gt;
&lt;li&gt;이것을 개선하기 위해 어셈블리어가 개발되었다.&lt;/li&gt;
&lt;li&gt;하지만, 이것또한 허들이 있어 High Level 언어인 C, C++, Java와 같은 언어가 생겼다.&lt;/li&gt;
&lt;li&gt;각 언어는 컴파일러/인터프리터를 통해 언어를 바이너리 파일로 변환한다.&lt;/li&gt;
&lt;li&gt;변환한 파일은 cpu로 전달하여 적절한 연산을 하여 결과를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3-5. ISA(Instruction Set Architecture)&lt;/h3&gt;
&lt;p&gt;기계어 명령어들의 집합.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CISC와 RISC 가 있으며, 최근엔 명령어 체계가 간단한 RISC가 자주 쓰이고 있다.&lt;/li&gt;
&lt;li&gt;RISC 를 사용하게 되면 한 사이클 내에서 명령어 수행이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221111&lt;/h2&gt;
&lt;p&gt;알고리즘 파트에 진입하게 되면서, 수강생들의 격차가 많이 나고 있다. 듣는강의의 진행도에 따라 순위를 표기해주는데, 한 파트 차이로 등수가 중간에서 상위권으로 뛰어 올라갔다.&lt;br&gt;
그만큼, 많은 분들이 기본알고리즘에서 고급알고리즘으로 넘어오는데 허들을 겪고 있다는 소리이다. 그러면서, 질문방이 매우 활성화되고 있고, 아는 한에서는 적극적으로 도움을 드리고자 노력하고 있다. 하지만 가끔 속상할 때가 있다. 이미 내가 해결했다고 생각한 이슈에 댓글이 달리는 순간이 그런 순간이다. 그럴때마다 &apos;내 답변이 충분히 문제를 해결한 것 같은데&apos;, &apos;내가 더 잘 답변한 것 같은데&apos; 라는 쓸데없는 생각이 들면서, 자존심이 상한다.&lt;/p&gt;
&lt;p&gt;나는 어느순간부터 감정이 올라오면 감정을 뱉기보단, 그 감정의 원인이 무엇인지 곰곰하게 생각하는 버릇을 들이고있다. 생각해보니, 이 이슈는 내가 남들보다 답변을 쉽게 잘했다, 혹은 남들보다 더 잘 설명했다는 &apos;자만심&apos;에서 오는 자존심에서 발생된 이슈라고 판단했다.&lt;/p&gt;
&lt;p&gt;다시 생각했다. &apos;내가 이렇게 자존심을 부릴이유가 있나..? 내가 개발자로 근무를 했지만, 모자른 점이 많다고 느껴서 여기온거고, 난 내가 이정도 안다라고 뽐내러 온게 아니라 배우러 온 것이다.
답변경쟁을 하려 온게 아니라, 답변을 하는 과정을 통해 배우고, 커뮤니케이션 하는 과정을 통해 소프트스킬을 배우러 온 것 이다. 또, 여기는 개발경력이 없더라도 나보다 뛰어나신 분들이 충분히 많다. 내가 더 겸손한 자세로 배워야겠다.&apos; 라는 생각을 했다.&lt;/p&gt;
&lt;p&gt;가끔 나는 &apos;경력&apos;의 늪에 빠지곤한다. 내가 과거에 근무하던 체육계는 경력이 곧 능력이었다. 학교도 학년이 곧 능력이었고, 군대도 짬이 곧 능력이었다. 이렇게 경력이 곧 능력이 되는 업계에서 근무하다, 실력이 곧 능력이 되는 업계에 들어오니, 적응이 안된다. 입에 붙은 &apos;내가 해봤는데~&apos;, &apos;라떼는~&apos; 이라는 단어는 말하면서도 스스로 수치스럽다. 2년차 개발자 ~ 라는 타이틀은 현재 내가 내세울만한 타이틀은 아닌 것 같다. 2년차에 걸맞는 능력이 없기에 배우러왔고, 다시 차근차근 능력을 쌓으러 왔다. 겸손하고 인정하자. 하지만, 내가 확실히 아는것에 대해서는 말할 수 있는 자신감은 유지하자. 단, 그것을 &apos;경력&apos;의 프레임을 가지고 얘기하진 말자.&lt;/p&gt;
&lt;h2&gt;[다짐]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;경력직 이라는 마인드를 의식적으로 없애고 겸손하기.&lt;/li&gt;
&lt;li&gt;&apos;나는 배우러 온 것이다&apos;라는 생각을 되새기기.&lt;/li&gt;
&lt;li&gt;개발자로서의 소양을 쌓기.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-10 Today I Learn]]></title><description><![CDATA[알고리즘 정렬 1-1. 병합정렬 인자가 쪼개지지 않을때까지 쪼갠뒤, 병합하면서 정렬하는 기법. 분할-정복(Divide-Conquer…]]></description><link>https://mitoconcrete.github.io/22_11_10/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_10/</guid><pubDate>Thu, 10 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[알고리즘] 정렬&lt;/h2&gt;
&lt;h3&gt;1-1. 병합정렬&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인자가 쪼개지지 않을때까지 쪼갠뒤, 병합하면서 정렬하는 기법.&lt;/li&gt;
&lt;li&gt;분할-정복(Divide-Conquer) 기법을 사용하는 대표적인 방법 중 하나.&lt;/li&gt;
&lt;li&gt;분할의 시간복잡도는 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(logN)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;병합의 시간복잡도는 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(N)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;따라서, 병합정렬은 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(NlogN)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 의 시간복잡도를 가진다.&lt;/li&gt;
&lt;li&gt;병합정렬의 과정&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Python] 파이썬 딕셔너리의 주소값 체이닝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;파이썬 딕셔너리 주소참조 기능 이용하여 enqueue 구현 중, 초기에 생성된 0x103148a30주소를 가진 next에 계속 tail로 오는 값들이 이어지는 것으로 보임.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;data&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;next&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;__main__&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node &lt;span class=&quot;token builtin&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;token number&quot;&gt;0x103148a30&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;__main__&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node &lt;span class=&quot;token builtin&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;token number&quot;&gt;0x103148a30&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;data&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;next&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;__main__&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node &lt;span class=&quot;token builtin&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;token number&quot;&gt;0x103148a30&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;__main__&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node &lt;span class=&quot;token builtin&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;token number&quot;&gt;0x1032e08b0&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;data&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;next&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;__main__&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node &lt;span class=&quot;token builtin&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;token number&quot;&gt;0x103148a30&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;__main__&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Node &lt;span class=&quot;token builtin&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;token number&quot;&gt;0x1032eed60&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Python] 딕셔너리 내부 구현&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;파이썬 딕셔너리는 해시테이블과 비슷하게 동작한다.&lt;/li&gt;
&lt;li&gt;내부적으로 배열을 사용하며, Key값을 내장된 함수로 인덱스로 변환하여, 인덱스에 값을 저장하도록 구현되어 있다고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[알고리즘] 해시테이블에서 충돌을 해결하는 방법&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;링크드리스트나 튜플을 이용하여 옆으로 이어나가는 식으로 충돌을 해결한다.&lt;/li&gt;
&lt;li&gt;개방주소법(Open Addressing)을 이용하여, 배열의 남는 공간에 값을 저장한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;[알고리즘] 해시테이블의 시간복잡도와 공간복잡도&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;의 시간복잡도를 보장한다.&lt;/li&gt;
&lt;li&gt;많은 메모리를 차지하여, 공간복잡도 측면에서는 좋지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[알고리즘] 트리 관련 용어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sibling : 동일레벨의 노드&lt;/li&gt;
&lt;li&gt;이진트리 : 자식의 갯수가 최대 2개인 트리&lt;/li&gt;
&lt;li&gt;완전이진트리 : 자식의 갯수가 최대 2개이며, 노드의 삽입이 최하단 왼쪽부터 차례대로 채워지는 트리&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[알고리즘] 완전이진트리를 배열로 표현하는법&lt;/h2&gt;
&lt;p&gt;인덱스로 부모와 자식의 관계를 표현하는것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;     &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;    &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 트리에서 아래의 규칙을 따른다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;현재 인덱스 * 2 왼쪽자식의 인덱스&lt;/li&gt;
&lt;li&gt;현재 인덱스 * 2 + 1 오른쪽자식의 인덱스&lt;/li&gt;
&lt;li&gt;현재 인덱스 // 부모의 인덱스&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;[알고리즘] 완전이진트리의 높이&lt;/h2&gt;
&lt;p&gt;각 레벨 별 최대노드 갯수는 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;2^k&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.849108em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.849108em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathnormal mtight&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;개이다. 이걸 이용하여, 현재 트리의 레벨을 구할 수 있다.
높이가 h이고, 완전꽉찬이진트리에 대한 노드 수를 구하기 위한 식은 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;/msup&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;N = 2^(h+1)-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.68333em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.9713299999999999em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8879999999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mopen mtight&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.64444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 이다. 따라서, &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;h = log(N+1) -1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.64444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 이기 때문에, 노드의 수에 상관없이, 트리의 높이는 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(logN)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;의 높이를 가진다.&lt;/p&gt;
&lt;h2&gt;[알고리즘] 최대힙에서 노드의 삽입과 삭제&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;노드의 삽입
트리의 높이 만큼의 시간복잡도를 가진다. 최대힙은 완전이진트리에서 구현되므로, 완전이진트리의 높이인 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;logN&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;만큼의 시간복잡도를 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가장 마지막에 넣은 뒤, 부모와 값을 비교해주면서 올라가며 적절한 위치를 찾는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;노드의 삭제
트리의 높이 만큼의 시간복잡도를 가진다. 최대힙은 완전이진트리에서 구현되므로, 완전이진트리의 높이인 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;logN&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;만큼의 시간복잡도를 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가장 첫번째 인자를 삭제하고, 마지막인자를 첫번째로 옮긴 뒤, 해당 노드를 아래로 내리며 적절한 위치를 찾는다.&lt;/li&gt;
&lt;li&gt;매 단계에서 가장 중요한것은 왼쪽, 오른쪽, 자신 중에서 가장 큰 값을 찾는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;[회고] 221110&lt;/h2&gt;
&lt;p&gt;오늘은 하루종일 인강듣고 알고리즘 문제풀고의 반복이었다. 문제를 하나씩 깨나가는 과정이 재미있게 다가왔다. 팀원 중 한 분이 함수의 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;의 동작에 대해 혼란스러워 하며, 도움을 요청하였다. 팀원들 모두가 공부를 멈추고 도와드리기 시작했다. &lt;code class=&quot;language-text&quot;&gt;print&lt;/code&gt;으로 출력되는 것과 값이 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;되는 것의 차이점부터 시작하여, 함수를 사용하는 이유까지 설명드렸다.&lt;/p&gt;
&lt;p&gt;나는 이 분이 겪는 어려움이 이해가 갔던게, 처음 c언어를 배울때 stadio 어쩌고 적혀있는 것 부터 시작해서, return 적혀있는 것 까지 하나하나 뭔뜻인지 알고싶어했고, 하지만 그 당시에는 그걸 어떻게 검색해야하는지 어떻게 동작하는지 알지못했다. 그 이후에도 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;의 용도에 대해 긴가민가하다가, 이런 정의를 보았고, 그 이후로 이해가 확실히 빨라졌다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;return을 만나는 순간, 함수는 중단되며, 해당 함수가 호출된 곳으로 이동한다. 반환된 값이 있다면, 호출된 곳에 반환된 값을 넣어준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;지금은 당연한 작동방식이지만, 그 때는 당연하지 않았다. 따라서, 이 팀원에게 이 문구를 알려드렸고, 그 이후로 &quot;아하&quot;하시며, 스스로 함수의 호출순서를 읊어가시며 이해하셨다는 시그널을 보내주셨다.
다른 팀원들도 디버깅툴과 여러 레퍼런스를 전달드리며, 이해를 도왔다. &apos;팀&apos;이 개인이 겪는 어려움을 해결 한 것 이다. 다들 열과 성을 다해 설명을 해드렸기에, 그 분이 이해하시자마자 모두들 기뻐하는 반응을 보여주셨다.&lt;/p&gt;
&lt;p&gt;어떤 유튜브영상을 보다가, 수학강사 정승제님이 은퇴한 운동선수들에게 사칙연산을 가르치는 영상을 보았다. 정승제님은 중학교과정이상만 가르쳤기때문에, 사칙연산은 &apos;당연히&apos;이렇게 동작하는 것 이라고 생각하셨는데, 운동선수들은 이 &apos;당연한&apos;것에 대해 이해하지 못했다. 정승제님은 사칙연산을 가르치는 경험이 없었기에 처음에는 답답해도 하시고, 어떻게 강의를 시작하셔야 할지 갈피를 잡지 못하셨다.&lt;/p&gt;
&lt;p&gt;오늘 내 느낌이 그랬다. 과거에 어려움을 겪었던 경험이 있었지만, 어느순간 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;은 나에게 있어 당연하게 동작하는 것이 되어버렸기에, 처음엔 어디부터 어떻게 설명드려야 할 지 갈피를 잡지 못했다. 당연히 &apos;이걸 왜 이해를 못하지?&apos;라는 답답함이 밀려왔으나, 과거의 경험이 떠오르고 나서는 &apos;이해 못할 수 있지&apos;의 포용적인 태도로 변했다.&lt;/p&gt;
&lt;p&gt;프로그래밍엔 &apos;당연한 것&apos;은 없다. 모두 0과 1의 조합으로 컴퓨터에 신호를 보내 동작하는 것이고, 내부의 동작은 우리눈으로 정확하게 확인 할 수 없다.&lt;/p&gt;
&lt;p&gt;그렇기에 더더욱 익숙한 것도 당연히 여기지 않으며, 탐구하는 자세가 필요하다. 오늘의 일을 계기로 조금 더 익숙해지는 것을 경계하여, 어떤 현상을 바라보는 시야가 좁아지지 않도록 노력해야겠다는 생각을 했다.&lt;/p&gt;
&lt;h2&gt;[다짐]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;익숙해지는 것을 경계하기&lt;/li&gt;
&lt;li&gt;상대방의 의견에 온전히 동의하고 말 멈추기&lt;/li&gt;
&lt;li&gt;할말이 있어도 적절한 시기엔 참기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-09 Today I Learn]]></title><description><![CDATA[Python 배열 배열은 본래 메모리의 특정부분을 미리 할당받아 사용한다. 하지만, 파이썬의 배열은 길이가 자유롭게 변화한다. 이유는 파이썬는 내부적으로 동적배열을 사용하며, O(…]]></description><link>https://mitoconcrete.github.io/22_11_09/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_09/</guid><pubDate>Wed, 09 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[Python] 배열&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;배열은 본래 메모리의 특정부분을 미리 할당받아 사용한다.&lt;/li&gt;
&lt;li&gt;하지만, 파이썬의 배열은 길이가 자유롭게 변화한다.&lt;/li&gt;
&lt;li&gt;이유는 파이썬는 내부적으로 동적배열을 사용하며, O(1)의 속도가 보장되도록 내부 로직이 구현되어 있기 떄문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Python] for...else&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;for...else 문의 else는 &lt;strong&gt;break, continue등을 거치지 않고, 완벽하게 반복문이 종료되었을 때&lt;/strong&gt;의 처리를 위해 사용된다.&lt;/li&gt;
&lt;li&gt;다음은 input으로 입력된 배열에서 최댓값을 찾는 알고리즘이다.&lt;/li&gt;
&lt;li&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find_max_num&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;# 이 부분을 채워보세요!&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; num &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; nums&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;curr target num is : &apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; num&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; compare_num &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; nums&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&apos;num &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; compare with &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;compare_num&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; num &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; compare_num&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; num&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;처음에 봤을 땐 하나도 이해가 되지 않았지만, &lt;code class=&quot;language-text&quot;&gt;[3, 5, 6, 1, 2, 4]&lt;/code&gt;의 input을 주고, 로그를 찍으니 아래와 같이 표현되었다.&lt;/li&gt;
&lt;li&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curr target num is :  3
num 3 compare with 3
num 3 compare with 5
curr target num is :  5
num 5 compare with 3
num 5 compare with 5
num 5 compare with 6
curr target num is :  6
num 6 compare with 3
num 6 compare with 5
num 6 compare with 6
num 6 compare with 1
num 6 compare with 2
num 6 compare with 4&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;즉, 6번의 모든 숫자를 순회해야, else로 넘어갈 수 있는 것이다. 반복문을 모두 순회하기 위해선, &lt;code class=&quot;language-text&quot;&gt;num &amp;lt; compare_num&lt;/code&gt; 이 조건을 피해야하는데, 그러기 위해선 &lt;code class=&quot;language-text&quot;&gt;num&lt;/code&gt;이 가장 큰 숫자여야 하는 것이다.&lt;/li&gt;
&lt;li&gt;잘 사용하진 않을 것 같지만,, 신기해서 기록한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[알고리즘] 소수정렬(아리스토테네스의 체)&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find_prime_list_under_number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;number&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    prime_list &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; prime_list&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            prime_list&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;append&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; prime_list&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[알고리즘] 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오.&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;모든 숫자를 1로 변환하고자 할 때&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 -&gt; 0 으로 바뀌는 포인트를 카운팅한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;모든 숫자를 0으로 변환하고자 할 때&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 -&gt; 1 로 바뀌는 포인트를 카운팅한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;풀이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위의 1,2 에 해당되는 카운팅과 피벗체크포인트를 두고, 각 조건에 따라 변화를 주어 카운팅한다.&lt;/li&gt;
&lt;li&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;find_count_to_turn_out_to_all_zero_or_all_one&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;string&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
 zero_to_one_cnt&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; one_to_zero_cnt &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
 is_zero_to_one_convert_mode_active&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; is_one_to_zero_convert_mode_active &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
         is_zero_to_one_convert_mode_active &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;
     &lt;span class=&quot;token keyword&quot;&gt;elif&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
         is_one_to_zero_convert_mode_active &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;False&lt;/span&gt;

     &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; is_one_to_zero_convert_mode_active&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
         is_one_to_zero_convert_mode_active &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;
         one_to_zero_cnt &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
     &lt;span class=&quot;token keyword&quot;&gt;elif&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; is_zero_to_one_convert_mode_active&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
         is_zero_to_one_convert_mode_active &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;
         zero_to_one_cnt &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;

 &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;zero_to_one_cnt&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; one_to_zero_cnt&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;[알고리즘] 버블정렬&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;앞에서 부터 두개씩 비교하여, 매 사이클마다 가장 큰 수가 맨 뒤로 가도록 만드는 정렬기법&lt;/li&gt;
&lt;li&gt;시간복잡도 : &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(N^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bubble_sort&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
              array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; array&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[알고리즘] 선택정렬&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;사이클에서 가장 작은수를 매 사이클마다 바뀌는 리스트의 가장 앞에 위치시키는 정렬 기법&lt;/li&gt;
&lt;li&gt;시간복잡도 : &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(N^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selection_sort&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        min_val_idx &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;# print(f&apos;min val : {array[min_val_idx]}&apos;)&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;# print(f&apos;compare val : {array[j]}&apos;)&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;min_val_idx&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                min_val_idx &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; j
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; min_val_idx&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;min_val_idx&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;min_val_idx&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[알고리즘] 삽입정렬&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;매 사이클의 마지막 인자를 매 사이클마다 바뀌는 리스트의 최적에 위치에 놓는 정렬기법&lt;/li&gt;
&lt;li&gt;시간복잡도 : &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(N^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;버블 정렬과 선택 정렬은 최선이든 최악이든 항~~상 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(N^2)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 만큼의 시간이 걸렸지만, 최선의 경우에는 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;Ω&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;Ω(N)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;Ω&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 만큼의 시간 복잡도가 걸림&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;insertion_sort&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;공부해 볼 것&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JIT 컴파일러 구조 및 동작원리&lt;/li&gt;
&lt;li&gt;Python 컴파일러 별 속도&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[회고] 221109&lt;/h2&gt;
&lt;p&gt;매번 느끼는 거지만, 알고리즘문제는 풀기전에는 그렇게 풀기싫은데 막상 문제에 접하게 되면 몰두하게 된다.
내배캠에 참여하게 되면서, 받은 책이 있다. 그 책에 한 글귀가 내가 왜 개발자라는 직군을 선택했는지, 명확하게 정리해주었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코딩이 즐거운 이유는 몰입을 유도해낼 조건을 모두 가지고 있기 때문이다.
몰입을 유도해내는 조건은 계속해서 도전과제가 주어지고, 그 도전과제를 해결하는 것을 통해 성장하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;내가 개발자로서 처음 길을 택했던 계기는, 2017년 4월에 &lt;strong&gt;별찍기&lt;/strong&gt;문제를 거의 한 1주일 동안 고민해서 해냈던 경험 이후 였다.&lt;br&gt;
그 일주일 간 몰입했던 경험과 몰입을 통해 원하는 결과를 얻어냈던 순간이 정말 좋았던 기억이 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221109_01.jpg&quot; alt=&quot;개발자가 되기로 마음먹은날&quot;&gt;&lt;/p&gt;
&lt;p&gt;하지만, 그 이후로 계속 왜인지 모르게 알고리즘은 자신도 없고, 뭔가 내 영역이 아니란 느낌을 받아서 의식적으로 밀어내었다.&lt;/p&gt;
&lt;p&gt;개발자라는 직업은 계속 새로운 환경에 노출되어야 성장하는 것 같다. 나도 의도적으로 알고리즘문제를 접해도 &apos;풀수 있다는 마인드&apos;를 가지고 임해봐야겠다.&lt;/p&gt;
&lt;p&gt;오늘은 강의 진도를 무진장 뺏는데, 다른팀원들을 보니 스케쥴대로 따라가는 것 같았다. 심지어 어떤 팀원 분은 아예 프로그래밍이 처음이라 강의를 따라가는 것이 버거워 책을 사서 개인공부를 하신다고 하신다.
내배캠이전 내가 다른부트캠프에서 공부를 하던 시절이 떠올랐다. 모든 게 다 중요한 것만 같아서, 매번 암기하고 정리하고 외우고 하느라 진도가 잘 빠지지 않았다. 그리고, 아티클 같은 것들을 막 첨부되어있는데, 불친절하게 &apos;이거 읽어보면 좋다&apos;라는 뉘앙스로 전달되었다. 너무 많은 정보가 쏟아지니 항상 머리가 터질 것만 같았다. 지금와서 생각해보면 그 때는 어떤게 중요하고 중요하지 않은 건지 필터링 할 수 있는 기준과 집중해야하는 범위가 명확하지 않아서 너무 힘들었다.&lt;/p&gt;
&lt;p&gt;어려움을 겪으시는 팀원들의 모습을 보니, 예전에 힘들어했던 경험이 오버랩되었다. 또한, 뮨재해결에 조금이나마 익숙해진 내 모습을 보면서, 꽤나 내가 개발직군이 익숙해졌구나~ 싶어 감개무량했다.
지난주에도 그랬던 것 처럼, 어려움을 겪는 팀원들에게 올바른 방향을 잡아주고, 나 또한 적극적으로 도움을 받으며 공부기간을 보내보려고 한다.&lt;/p&gt;
&lt;p&gt;또한, 지속적으로 내 자신감이 초기와 같지 않다는 것이 느껴지고 있는데, 의도적으로 자신감을 유지하려고 해야겠다. 자신감이 없어지면 의견을 내는것에 소극적이게 된다..!!
내 자신감을 저하시키는 요소들은 의도적으로 무시하려고 하자.&lt;/p&gt;
&lt;h2&gt;[다짐]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;의도적으로 자신감 다시 높이기&lt;/li&gt;
&lt;li&gt;새로운 문제에 노출 되는 것을 두려워하지 않기&lt;/li&gt;
&lt;li&gt;내 의견을 적극적으로 표출하기&lt;/li&gt;
&lt;li&gt;상대방의 말을 경청하기&lt;/li&gt;
&lt;li&gt;이해할 수 있는 단어를 선택하여 설명하기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-08 Today I Learn]]></title><description><![CDATA[Java 1. JVM / JRE / JDK JDK, JRE, JVM 관계 1-1. JVM (Java Virtual Machine) 우리가 Java…]]></description><link>https://mitoconcrete.github.io/22_11_08/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_08/</guid><pubDate>Tue, 08 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[Java] 1. JVM / JRE / JDK&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/image/221108_01.png&quot; alt=&quot;JDK, JRE, JVM 관계&quot;&gt;&lt;/p&gt;
&lt;h3&gt;1-1. JVM (Java Virtual Machine)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;우리가 Java로 작성한 코드는 컴파일러를 통해 &lt;code class=&quot;language-text&quot;&gt;.class&lt;/code&gt;확장자를 가진 바이너리(=바이트) 코드로 바뀐다.&lt;/li&gt;
&lt;li&gt;컴파일된 바이너리 코드는 운영체제(Mac,Window,IOS,Android)마다 다르게 인식한다.&lt;/li&gt;
&lt;li&gt;Java는 운영체제별 JVM을 제공하여, 컴파일된 코드가 운영체제에 상관없이 똑같은 동작을 낼 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;즉, JVM은 컴파일 코드를 읽고/검증하고/실행하여 운영체제가 변해도 똑같은 동작을 할 수 있게 돕는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1-2. JRE (Java Runtime Environment)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;말그대로, 자바 코드의 실행 시 필요한 도구들을 갖춘 &lt;strong&gt;환경&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;JVM + 자바 프로그램 실행에 필요한 라이브러리 파일(system.out, 등...)으로 구성되어있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1-3. JDK (Java Development Kit)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JRE + 개발을 위한 도구(컴파일러, 디버거, ...)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Java] 2. 예외&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/image/221108_02.png&quot; alt=&quot;Throwable&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바는 예외처리도 예외에 관한 클래스를 상속받아 구현한다.
&lt;code class=&quot;language-text&quot;&gt;Throwable&lt;/code&gt;이라는 클래스가 있고, 그 하위자식들로 예외를 표현한다.&lt;/p&gt;
&lt;h3&gt;2-1. 예외 기본&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Error : 컴퓨터나 JVM이 동작할 수 없는 크리티컬한 상황.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exception : 그 외의 대부분 문제상황.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RuntimeException : 프로그램 실행도중 발생 할 수 있는 상황에 사용됨.&lt;/li&gt;
&lt;li&gt;IOException : 파일을 읽고 쓰는 상황에서 발생 할 수 있는 상황에 사용됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;catch 는 이어서 사용하여, 다양한 예외를 잡을 수 있다. 단, 더 작은 범위의 Exception 부터 사용하여야, 더 많은 예외를 잡는 것이 가능해진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    검증 코드
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;작은범위의 에러&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    예외 시 처리&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;넓은범위의 에러&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    예외 시 처리&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2-2. try-with-resource&lt;/h3&gt;
&lt;p&gt;입출력을 사용 할 때, 파일을 열고 닫는 행위를 해야한다.
이 때 의무적으로, close() 메소드를 호출하여 처리해야하는데, &lt;code class=&quot;language-text&quot;&gt;try-with-resource&lt;/code&gt; 방식을 사용하게 되면 try에 전달한 자원을 try실행이후 자동으로 close 해주면서, 효율적인 코드를 작성하는데 도움을 준다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;try-with-resource&lt;/code&gt; 방식은 closeable interface 를 implements 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; 자원할당&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; 코드실행
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; 자원 자동해제
&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;2-3. 메소드에 예외처리를 전가하기&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;throws&lt;/code&gt;키워드를 사용하여, 예외를 메소드 실행시점으로 전가 시킨다. 단, 해당 키워드를 통해서 정의한 메소드는 반드시, try-catch문을 이용하여 정의한 exception에 대한 예외처리를 반드시 해야한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception_1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception_2&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;sdsada&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception_1&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Exception_2&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Java] 3. Collection&lt;/h2&gt;
&lt;p&gt;자료구조를 표현하고 사용하기 위한 클래스의 집합.&lt;/p&gt;
&lt;h3&gt;3-1. ArrayList vs HashSet&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList는 순서가 보장됨, HashSet은 순서가 보장되지 않음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3-2. ArrayDeque(Double-Ended Queue)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Stack과 Queue의 기능을 모두 포함하면서 성능이 더 좋다.&lt;/li&gt;
&lt;li&gt;하지만, Thread-Safe하지 않기에, 멀티쓰레드 환경에서는 문제가 있다.&lt;/li&gt;
&lt;li&gt;그래서 pop(), push(), peek() 등에 synchronized를 이용해 ArrayDeque을 구현하면 된다.&lt;/li&gt;
&lt;li&gt;ArrayDeque의 push는 addFirst와 동일하게 동작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Java] 4. Generics&lt;/h2&gt;
&lt;p&gt;Collection 클래스를 Generics를 통해 컴파일타임에 타입체크해줌으로서, 프로그램의 안정성을 증대시켜준다.&lt;/p&gt;
&lt;h3&gt;4-1. 사용예들&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Type&lt;/span&gt;
&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Element&lt;/span&gt;
&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Key&lt;/span&gt;
&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Value&lt;/span&gt;
&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Number&lt;/span&gt;
&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//Result&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Java] 5. 람다와 스트림&lt;/h2&gt;
&lt;h3&gt;5-1. 람다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;식별자 없이 실행 가능한 함수.&lt;/li&gt;
&lt;li&gt;코드가 간결해지지만, 익명함수기에 재사용성이 줄어든다는 단점이 있다.&lt;/li&gt;
&lt;li&gt;forEach, map, filter, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5-2. 스트림&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 여러개 표현 할 수 있는 곳에는 흐름이 생기고, 그 흐름을 이용해서 조작을 하는 것이다.&lt;/li&gt;
&lt;li&gt;데이터가 삭제되고, 수정되고, 들어오고 하면서 데이터가 유동적으로 변하게 된다. 이를 흐름이라 칭하는 것 같다.&lt;/li&gt;
&lt;li&gt;java8에서 적용되었다.&lt;/li&gt;
&lt;li&gt;흐름내부에서만 변동되지, 흐름의 대상을 직접적으로 수정하지는 않는다.&lt;/li&gt;
&lt;li&gt;한번닫힌 흐름은 재사용이 불가하다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;collect()&lt;/code&gt; 를 이용하여 스트림과정에서 return된 결과를 모아준다. 매개변수를 통해 collection타입도 변경가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[CS] 6. API(Application Programing Interface)&lt;/h2&gt;
&lt;p&gt;데이터를 주고받는 형식에 대한 약속(규약-Interface)&lt;/p&gt;
&lt;h2&gt;[Python] 7. set&lt;/h2&gt;
&lt;p&gt;set은 집합을 만들기 위한 개념으로서 합/교/차집합을 구하는 것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 교집합&lt;/span&gt;
&lt;span class=&quot;token builtin&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 합집합&lt;/span&gt;
&lt;span class=&quot;token builtin&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 차집합&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;set은 중복을 없애준다. 단, 순서를 보장하지 않는다.&lt;/p&gt;
&lt;h2&gt;[Python] 8. 다양한 매개변수를 받는방법&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (a,b,c,) 튜플형식으로 인자가 들어옴&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt;kwargs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;kwargs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# {&quot;a&quot;:1,&quot;b&quot;:2, ...} 와 같은 딕셔너리 형태로 인자가 들어옴&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[회고] 221108 : 왜 겁을 내는가&lt;/h2&gt;
&lt;p&gt;질문방에는 다양한 질문이 올라온다. 다양한 사람들이 다양한 답변을 한다. 컴퓨터전공 수강생들/개발을 좀 해본 수강생들/튜터님들/매니저님들..
나는 다양한 답변이 올라오는 곳에서의 토론은 의식적으로 피한다. 왜그런지 곰곰하게 생각해보니 아래의 결론이 도출되었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내 의견이 틀리는 것이 무서워서&lt;/li&gt;
&lt;li&gt;내 의견이 지적당하는게 두려워서&lt;/li&gt;
&lt;li&gt;토론에 휘말리기 싫어서&lt;/li&gt;
&lt;li&gt;내가 잘난척하는 느낌이 나는것이 싫어서&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;너무나도 명확하게 내가 고쳐야 할 점들이 도출되었다. 내가 봐 온 위대한 개발자들은 군중앞에서 말하고, 의견을 나누고, 토론하는 것을 즐겼다.
다만, 그게 틀릴지라도 틀린것에 반박할 수 있는 지식을 가지고 있었지만 말이다.
어쨋던, 난 너무 내 틀에 갖혀있다는 생각을 했다. 토론이 이뤄질 때, 비전공자 팀원들이 모여있는 방에 숨어 저건 맞다 저건아니다 하는 시시비비를 가리는 모습을 보면서 앞으로 나서지 못하고 뒤에서 의견을 내는 내가 한심하게 느껴졌다.&lt;br&gt;
이건 아니다.&lt;br&gt;
이건 성장할 수 없는 태도다.&lt;br&gt;
왜 겁을 내는가.&lt;br&gt;
변해야한다.&lt;br&gt;
내 틀에서 벗어나야한다.&lt;/p&gt;
&lt;h2&gt;[다짐] 221109&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;상대방의 의견을 경청하기 / 무시하지 않기&lt;/li&gt;
&lt;li&gt;적극적으로 질문하기&lt;/li&gt;
&lt;li&gt;적극적으로 토론하기&lt;/li&gt;
&lt;li&gt;적극적으로 잘난척하기(내가 토론을 할 수있는 것에 대해)&lt;/li&gt;
&lt;li&gt;지속적으로 의문을 갖고 어떤 문제에 대해 파고들기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-07 Today I Learn]]></title><description><![CDATA[Java 자바의 특징 객제 지향적 프로그래밍을 지향한다. Write One Run Anywhere JRE(Java Runtime Environment) 를 이용해, 플랫폼(맥,윈도우,안드로이드,IOS)에 종속되지 않고 실행된다. Java…]]></description><link>https://mitoconcrete.github.io/22_11_07/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_07/</guid><pubDate>Mon, 07 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;[Java] 자바의 특징&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객제 지향적 프로그래밍을 지향한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write One Run Anywhere&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JRE(Java Runtime Environment) 를 이용해, 플랫폼(맥,윈도우,안드로이드,IOS)에 종속되지 않고 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;[Java] 변수&lt;/h2&gt;
&lt;p&gt;어떤 값을 할당하는 공간을 &lt;strong&gt;메모리&lt;/strong&gt;라고 한다. 그 공간에 이름을 붙혀주는 것을 &lt;strong&gt;변수&lt;/strong&gt;라고 한다.&lt;/p&gt;
&lt;h2&gt;[Java] 초기값&lt;/h2&gt;
&lt;p&gt;Java는 초기값을 할당해주지 않으면, 해당 자료형의 초기값을 기본값으로 자동할당하여 초기화한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token import&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;java&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;util&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;byte&lt;/span&gt; byteT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;short&lt;/span&gt; shortT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; intT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; longT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;float&lt;/span&gt; floatT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;double&lt;/span&gt; doubleT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; charT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; booleanT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; stringT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt; mapT&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;byteT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;shortT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;intT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;longT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;floatT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0.0&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;doubleT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0.0&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;charT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;booleanT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//false&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;stringT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//null&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mapT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//null&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[Java] 객체지향&lt;/h2&gt;
&lt;h3&gt;객체지향기본 - 클래스&lt;/h3&gt;
&lt;p&gt;틀&lt;/p&gt;
&lt;h3&gt;객체지향기본 - 인스턴스&lt;/h3&gt;
&lt;p&gt;클래스 틀을 이용해 만들어진 실제 사용 객체.&lt;/p&gt;
&lt;h3&gt;객체지향기본 - 인스턴스의 특징&lt;/h3&gt;
&lt;p&gt;붕어빵이 구워진 뒤 먹은붕어빵, 식은붕어빵, 갓 구운 붕어빵 등등 각각의 상태가 달라지는 것 처럼. 인스턴스는 생성 된 뒤로 그 상태가 각각 다르게 변함.&lt;/p&gt;
&lt;h3&gt;객체지향기본 - 메소드&lt;/h3&gt;
&lt;p&gt;함수&lt;/p&gt;
&lt;h3&gt;객체지향기본 - 생성자&lt;/h3&gt;
&lt;p&gt;인스턴스 초기화 메소드. new 키워드를 이용해 사용하며, return 값이 없고 자신이 속해있는 class와 같은 값을 가진다.&lt;/p&gt;
&lt;h3&gt;객체지향기본 - 기본 생성자 초기화&lt;/h3&gt;
&lt;p&gt;생성자를 정의하지 않고, 인스턴스를 초기화해도 잘 동작이 된다. 그 이유는 자바컴파일러가 자동으로 매개변수가 없는 기본생성자를 만들어주기 때문이다.&lt;/p&gt;
&lt;h3&gt;상속 - 오버로딩(쌔삥)&lt;/h3&gt;
&lt;p&gt;부모에 있는 같은 이름의 메소드를 만들되, 매개변수의 갯수, 타입이 다른 메소드를 만드는 것.&lt;/p&gt;
&lt;h3&gt;상속 - 오버라이딩&lt;/h3&gt;
&lt;p&gt;부모에 있는 메소드 중 메소드이름, 매개변수의 갯수, 타입, return타입 모두 일치하지만 기능자체를 새로 정의한 함수를 만드는 것.&lt;/p&gt;
&lt;h3&gt;접근제어자&lt;/h3&gt;
&lt;p&gt;키워드별 권한 접근제한 정도&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;private &gt; default &gt; protected &gt; public&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;private : 같은 클래스 내 에서만 접근이 가능함.&lt;/li&gt;
&lt;li&gt;default : 같은 패키지 내 에서만 접근이 가능함.&lt;/li&gt;
&lt;li&gt;protected : 같은 패키지, 다른패키지의 자손클래스에서 접근이 가능함.&lt;/li&gt;
&lt;li&gt;public : 접근 제한 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;접근제어자 - 캡슐화&lt;/h3&gt;
&lt;p&gt;객체지향이란 &lt;strong&gt;객체 간 상호작용을 표현&lt;/strong&gt; 한 것이다. 상호작용을 할 때는 우리가 현실에서도 모든 정보를 남에게 공개하지 않는 것 처럼, 정보에 대한 제한을 두어야 한다. 이런 제한을 두어 정보를 숨기는 것을 &lt;strong&gt;캡슐화&lt;/strong&gt;라고 하며, 접근제어자는 자바의 캡슐화 구현을 위해 가장 필요한 개념이다.&lt;/p&gt;
&lt;h3&gt;추상클래스&lt;/h3&gt;
&lt;p&gt;추상메소드를 선언 할 수 있는 클래스. 상속없이 그 자체로 생성자를 이용해 인스턴스를 생성하는 것이 불가하다.
&lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt; 키워드를 사용하여 상속하며, 다중상속이 불가하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;추상메소드&lt;/h3&gt;
&lt;p&gt;설계도(매개변수 정의)만 있고, 구현체(몸통)은 없는 메소드. 구현은 자식클래스에서 구현해야한다.&lt;br&gt;
미완성으로 남겨두는 이유는 &lt;strong&gt;상속받는 클래스 마다 반드시 동작이 달라지는 경우&lt;/strong&gt;에 상속받는 클래스 작성자가 반드시 작성하도록하기 위함입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; 리턴타입 메소드이름&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;인터페이스&lt;/h3&gt;
&lt;p&gt;객체의 특정행동의 특징을 정의한다. 인터페이스를 실행하는 클래스는 반드시 인터페이스에 정의된 메소드를 구현해주어야한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;implements&lt;/code&gt; 키워드를 이용해서 상속할 수 있으며, 다중상속이 가능하다.&lt;/p&gt;
&lt;h3&gt;인터페이스와 추상클래스의 차이 정리&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;인터페이스&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;추상클래스&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;구현하려는 객체의 동작의 명세&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;클래스를 상속받아 이용 및 확장을 위함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;다중 상속 가능&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;다중 상속 불가능 , 단일 상속&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;implements를 이용하여 구현&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;extends를 이용하여 구현&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;메소드 시그니처(이름, 파라미터, 리턴 타입)에 대한 선언만 가능&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;추상메소드에 대한 구현 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;[회고] 221107&lt;/h2&gt;
&lt;p&gt;처음 타입을 배울 땐 몰랐는데, 객체지향개념에 들어가니 내가 왜 옛날에 국비지원학원에서 자바수업에 그렇게 들어가기 싫어했는지 깨닫게 되었다.&lt;/p&gt;
&lt;p&gt;하지만, 그 때보다는 다른 이론을 받아들이는데에 있어서 조금은 여유로워 진 것이 느껴졌다. 다른 언어를 프레임워크레벨까지 보고 와서 그런건가..? 웹플로우에 익숙해져서 인가.. 하지만 아직 자바의 객체지향을 잘 사용하기 위해 만들어진 인터페이스나 추상메서드의 개념은 언제 어디에 사용해야하는지 익숙하지 않다. 불편함을 익숙함으로 만드는 것에 익숙해져야 개발자다! 얼른 많이 시행착오 겪어서, 손에 익었으면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-1st Weekly I Learn]]></title><description><![CDATA[FACT-01. 처음보는 4분과 팀 프로젝트를 진행했다. FEELINGS 5일이라는 짧은시간이지만 심적거리감이 매우 가까워졌다. FINDINGS…]]></description><link>https://mitoconcrete.github.io/22_11_1st/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_1st/</guid><pubDate>Sun, 06 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;FACT-01. 처음보는 4분과 팀 프로젝트를 진행했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5일이라는 짧은시간이지만 심적거리감이 매우 가까워졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;짧은시간동안 심적거리감을 가깝게 만들기 위해선, 함께 시련을 극복하는 것이 가장 효과적이라는 것을 느꼈다. 서로 인강만 보면서 공부하는 시스템이었다면, 이렇게 친해질 수 있을까? 회사에서 친해지는 동료들은 주로 같은팀, 즉 같은 시련을 동고동락했던 사람들 이었다는 것을 다시금 깨달았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;회사에 빠르게 적응하기 위해서, 혹은 다른사람과 빠른시간이내에 가까워지고 싶다면, 시련을 제안하고 같이 극복해보려고 하자.&lt;/li&gt;
&lt;li&gt;시련은 다양한 부류가 있다. 스터디를 통해 특정목표를 달성하거나, 프로젝트를 어떤 기한내에 완성시킨다던가..&lt;/li&gt;
&lt;li&gt;생각해보니, 그래서 크로스핏 박스에서 사람들이랑 금방 친해졌던 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-02. 팀장이 아닌데, PM의 역할을 자청해서 프로젝트를 리드했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음엔 팀장님의 역할을 내가 가져가는게 아닌가 싶어 죄송했다. 따라서, 팀장님께 계속 내가 어떤 일을 하려고 하는지 공유드렸다. 난, 프로젝트를 리드 할 자신이 있었고, 일정 내에 완수시킬 자신이 있었기에 PM을 자청했고, 팀장님과 팀원의 신뢰를 받았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀장님께선 내가 주도적으로 이끌어 가는 것엔 처음엔 당황하셨으나, 신뢰가 쌓인 다음부터는 전적으로 나를 믿고 지지해주셨고, 신뢰가 쌓이면서 프로젝트가 순항하는 모습을 발견하게 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 역할을 자진해서 맡을땐, 끝까지 성공적으로 이끌어갈 플랜이나 자신감이 있을 때 지원하자. 즉, 다른사람들에게 신뢰를 얻을 자신이 있을 때 하자.&lt;/li&gt;
&lt;li&gt;단, 포지션에 지원 할 땐 동료가 당황 할 수 있으니, 서로 합의 후에 진행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-03. git과 github 특강이 있었고, 팀원들과 git을 이용한 협업을 했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;과거에 가장 어려움을 겪었던 점이기에 팀원들을 잘 이해시키고, 이끌어 갈 수 있을지 확신이 없었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 강의로만 보는 것 보다, 실패하더라도 실제로 적용해보는 것이 학습에 효과적이라는 점을 볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 시도를 할 땐, 두려워하지 말고 일단 해보자!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-04. 개인페이지를 모아 flask 프로젝트 틀을 잡아 팀원들에게 전달했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;과거 프로젝트를 그대로 복붙하는거라서, 내가 한건 api를 복붙해서 사용하는 것이었다. 하지만, 서버-클라이언트의 구조를 이해하기엔 이것을 잇는 것 만큼 좋은 경험이 없었다고 생각하는데, 팀원들에게 그런 경험을 할 수 있는 기회를 뺏은 것 같아서 죄송했다. 각자에게 미션을 드리고 잇는 것을 도와드리는 방향으로 갔어야 했는데, 내가 이 업무를 맡으면서 백엔드 작업의 80%는 한 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 할 수 있고, 남이 못하는 것은 일단 남이 할 수 있게 만드는게 서로에게 윈윈이 되겠다는 것을 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 할 수 있고, 남이 못하는 일은 남이 하도록 만들어야 서로의 속도를 맞출 수 있다.&lt;/li&gt;
&lt;li&gt;반대로 내가 못하고, 남이 할 수 있는 일에는 내가 자진해서 하고 조언을 요청하는 식으로 일을 진행하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-05. git 을 이용한 협업플로우에 문제가 있음을 발견했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;회고 할 때 발견했는데, 이미 중간부터 이건 아니다 라는 것을 느끼고 있었는데 &apos;문제 없겠지 뭐&apos; 라는 안일한 생각으로 계속 진행했다. 결론적으로, 안그래도 머리가 아픈 팀원분들에게 더 혼란을 드렸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 제대로 알지 못하는 것은, 현실에서 이행하지 않는게 좋겠다는 생각을 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 것을 제안하거나, 적용 할 때는 확실히 이해하고 남에게 설명 할 수 있을 정도의 레벨까지 만들고 진행하자. 빵꾸(?)가 있는 것은 그 빵꾸(?)를 메꾸고, 제안하던지 하자!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-06. 일정에 맞추어 업무를 완료했다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제일 힘들었던 것이 정도를 지키는 것이었다. 솔직히, 구현하고 싶은 기능도 많았고, 내가 마음먹고 진행하면 단독으로 하면 되는 것도 많았는데, 팀플레이를 택했다.&lt;/li&gt;
&lt;li&gt;팀플레이를 택하는데 가장 영향을 많이 줬던 사건은, 첫날 API를 짜는데 매니저님의 제안을 통해 깨닫게 된 팀원들의 흔들리는 눈동자를 보고 반성하게 된 사건이었다.&lt;/li&gt;
&lt;li&gt;욕심부리지 않고 할 수 있는 범위의 업무를 할당하고 조정한 것이 일정에 맞추어 업무를 완료하는데 가장 도움이 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 잘하는 것도 중요하지만, 남들과 어떻게 속도를 맞추냐가 협업의 관건이라는 것을 느꼈다.&lt;/li&gt;
&lt;li&gt;욕심내면 할 수 있겠다 싶었던 기능도 최종적으로 보았을 때, 할 시간이 없었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모두가 감당가능한 일정이 모두에게 행복을 준다.&lt;/li&gt;
&lt;li&gt;욕심을 배제한 자신이 일정을 책임질 수 있는 업무를 기본구현기능으로 잡고, 먼저 끝낸 사람에게는 추가적인 업무를 할 수 있도록 하는게 나은 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FACT-07. 발표를 마치고, 튜터님으로 부터 긍정적인 피드백을 받았다.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FEELINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 팀이 랜딩페이지만 드래그하면서 화면과 기능에 대한 설명을 하니, 튜터님께서는 그에 맞게 UI&amp;#x26;UX에 대한 피드백을 해주셨다. 우리팀은 특별한 기능이 없었기 때문에, 전반적인 피드백을 받길 원했다. 따라서, 우리가 어떻게 일정을 진행했고, 어떤 히스토리로 랜딩페이지를 만들게 되었는지 설명드리고, 어떤 파트를 어떤 분이 맡으셨는지 시연을 하면서 설명드리니, 사실 남들에 비해 많은 기능이 없는 페이지임에도 불구하고 흠 잡을 것 없었다는 피드백을 받았다.&lt;/li&gt;
&lt;li&gt;발표의 큰 맥락을 잡고, 머릿속으로 내가 어떤파트를 설명하고 있는지 신경써가며 완성된 문장을 뱉으려고 노력했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FINDINGS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;피드백을 받고 싶은 범위를 확실히 하는것과 그렇지 않는것은 천지차이라는 것을 깨달았다. 목적을 확실히 하고, 그에 관해 어필하니 상대방도 &apos;아~ 이 팀은 이런걸 신경썼구나. 많은 기능은 없지만, 중요하다고 생각하는것을 잘 타겟팅했네&apos; 라고 생각해주시는 것 같았다. 그래서, 좋은 피드백을 받았다고 느꼈다.&lt;/li&gt;
&lt;li&gt;또한, 예전부터 나는 남에게 말을 못이해시키는 경우가 많았는데, PPT를 통해 내가 지금 말하고 있는 부분이 어떤 부분인가 계속 상기하면서 발표를 진행하니, 상대방도 내가 말하고자하는 것을 잘 이해하는 것 처럼 느껴졌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUTURE&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;상대방으로부터 피드백 받고 싶은게 있다면, 상대방이 &apos;아 이 사람은 이부분을 피드백받고 싶구나.&apos; 라고 느낄 수 있도록 어필해주어야 한다.&lt;/li&gt;
&lt;li&gt;PPT는 내가 무엇을 말하고 있는지 갈피를 잡게하는 가장 좋은 수단인 것 같다. 아니면, 큰 맥락을 기억하고, 내가 무슨 부분을 말하고 있는지, 다음에 해야할 것은 무엇인지 계속 상기하면서 발표하는게 길을 잃지 않고 말을 뱉는 것에 많은 도움을 주는 방법이라고 느꼈다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-04 Today I Learn]]></title><description><![CDATA[1. 회고 221104 회고 프로젝트 발표준비 1차 프로젝트 발표 및 피드백 2차 프로젝트 발표 및 피드백 갈무리…]]></description><link>https://mitoconcrete.github.io/22_11_04/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_04/</guid><pubDate>Fri, 04 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. [회고] 221104 회고&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;프로젝트 발표준비&lt;/li&gt;
&lt;li&gt;1차 프로젝트 발표 및 피드백&lt;/li&gt;
&lt;li&gt;2차 프로젝트 발표 및 피드백&lt;/li&gt;
&lt;li&gt;갈무리&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;br&gt;
전 날, 사다리 타기로 발표를 담당하게되어, 오전은 내내 발표 준비로 하루를 보냈다.&lt;br&gt;
발표를 잘하는 편이 아니고, 짧은 시간 안에 우리팀이 일주일동안 뭘했는지를 효과적으로 어필해야하기 때문에 PPT를 준비했다.
전체적인 발표틀을 잡고 그에 맞게 PPT를 구성했다. 남들앞에 서는 것에 익숙치않아, 준비하는데도 입술이 바싹바싹말랐는데 이것을 무서워하면 내 성장이 없겠다라고 생각이 들어, 마음을 계속 다잡았다. 또한, 팀원들도 계속 자신감을 심어주어 너무 감사했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221104_01.png&quot; alt=&quot;자존감 올려!&quot;&gt;&lt;/p&gt;
&lt;p&gt;팀원분들의 회고를 받아 정리를 하는작업도 애를 먹었다. 각 팀원분들께 회고를 요청드리고 받은 글들을 조금은 있어보이게(?) 워딩을 바꾸거나 임팩트있는 업무를 강조하는 식으로 요약하여 PPT에 정리하였다. 몇몇 팀원분은 본인의 성과와 회고를 애매하게 적어놓으셔서, 개인적으로 DM을 드려 어떻게 느낌을 받으셨는지 끈질기게 물어보았다.(죄송..) 결론적으로, 성공적으로 시간내에 모든 준비를 마칠 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;br&gt;
프로젝트 발표회가 시작되었다. 우리 조는 2번째 발표였다.
말을 할 때 흐리지 않고, 완벽하게 문장을 구현 할 수 있도록 신경쓰면서 노력했다. 발표순서는 아래와 같이 진행되었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;프로젝트 목적 및 히스토리&lt;/li&gt;
&lt;li&gt;프로젝트 시연&lt;/li&gt;
&lt;li&gt;팀원 별 프로젝트 회고&lt;/li&gt;
&lt;li&gt;팀원 별 코드 자랑 타임&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;원활하게 발표가 진행되었고, 튜터님의 피드백도 나쁘지 않았다. 무사히 마무리 되었다..
이후에 마음편히 다른 분들의 발표를 경청했는데, 능력자 분들만 모인조도 보였고, 간신히 프로젝트를 마무리 한 조도 있었다.
이렇듯 모두 각자의 속도가 다른 것이 발표회를 통해 확연하게 보여서 신기했다.&lt;br&gt;
팀원들이 다른 분들의 발표를 듣고, 기가 죽어있는 모습이 보였지만 개인의 속도가 있는 것이니 괜찮다고 다독여 드렸다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;br&gt;
A반은 다른 튜터님께 다시한번 피드백을 받는 시간을 가졌다.&lt;br&gt;
다른 팀들은 홈페이지 UI&amp;#x26;UX를 보여드리고, 뼈대에 대해서만 피드백을 받았다. 튜터님도 그 전 히스토리를 모르니, UI&amp;#x26;UX에 대한 피드백을 주로 주시는 것 같았다. 따라서, 우리는 그간의 히스토리를 공유드리고, 시연을 하는식으로 발표를 진행하기로 했다. 비록 다른조에 비해 특출난 결과물은 없지만, 어떤 식으로 기획하고 진행하였는지 히스토리를 공유드리고, 홈페이지를 직접 시연하면서 누가 어디를 맡았는지 소개했다. 튜터님께서 조금더 신경써서 봐주시는 느낌이 들었고, 회고까지 찬찬히 봐주시고 피드백 주셔서 감사했다.&lt;br&gt;
결론적으론, &apos;흠 잡을 데가 크게 없다&apos; 라는 피드백을 받을 수 있었고, 발표전략이 잘 맞았던 것 같아서 안도하였다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;br&gt;
이번주를 끝으로 첫번째 프로젝트의 팀원들과 헤어지게 되면서, 아쉬움을 토로하며 KPT를 진행했다.&lt;br&gt;
팀원분들은 기술적으로, 나는 계속 팀원들의 문제해결에 도움을 주며 소프트스킬적으로 첫 날 보다는 많이 발전했다는 것이 느껴져서 좋았다.
첫날은 아무것도 정해진것 없는 혼돈의 도가니였지만, 결론적으로 현시점에 기한안에 프로덕트를 깔끔하게 만들고, 발표까지 마쳐 좋은피드백도 받으면서, 나름(?) 성공적으로 프로젝트 기간이 종료되어 개인적으로 감회가 새로웠다.&lt;/p&gt;
&lt;p&gt;팀원들과도 5일동안 많이 친해질 수 있어서 좋았고, 아쉬움에 마지막 사진을 다같이 모여 찍고 마무리했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221104_02.png&quot; alt=&quot;자존감 올려!&quot;&gt;&lt;/p&gt;
&lt;h2&gt;2. 발표자료&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/EvmyjPKNl40&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/EvmyjPKNl40/0.jpg&quot; alt=&quot;프로젝트 시연 비디오&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://peach-sort-527.notion.site/4-3-6d05934d672a4a3ea9bdd3105b4308e8&quot;&gt;프로젝트 정리 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.canva.com/design/DAFQ8Ls5yH8/9WEPsEOFx8Xx7vlvnjTkqw/view?utm_content=DA%5B%E2%80%A6%5Dmpaign=designshare&amp;#x26;utm_medium=link&amp;#x26;utm_source=publishsharelink&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-03 Today I Learn]]></title><description><![CDATA[1. 알고리즘 영어가 싫어요 문제 영어가 싫은 머쓱이는 영어로 표기되어있는 숫자를 수로 바꾸려고 합니다. 문자열 numbers가 매개변수로 주어질 때, numbers를 정수로 바꿔 return 하도록 solution 함수를 완성해 주세요. 2. git…]]></description><link>https://mitoconcrete.github.io/22_11_03/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_03/</guid><pubDate>Thu, 03 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. [알고리즘] 영어가 싫어요&lt;/h2&gt;
&lt;h3&gt;문제&lt;/h3&gt;
&lt;p&gt;영어가 싫은 머쓱이는 영어로 표기되어있는 숫자를 수로 바꾸려고 합니다. 문자열 numbers가 매개변수로 주어질 때, numbers를 정수로 바꿔 return 하도록 solution 함수를 완성해 주세요.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; numbersAsString &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;zero&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;one&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;two&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;three&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;four&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;five&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;six&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;seven&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;eight&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;nine&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; temp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; string &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; numbers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    temp &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; string
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numbersAsString&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;includes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      result &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; numbersAsString&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      temp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. [git] fork를 이용한 git 협업 플로우&lt;/h3&gt;
&lt;p&gt;이번 프로젝트 일 때, fork를 이용해서 진행했는데 뭔가 예전에 했던 방식이랑 다르게 동작해서 계속 팀원들이 최신버전의 코드를 받기 위해 github에서 sync fork를 한뒤 진행했다. 원래는 upstream과 origin을 각각두고, upstream에서 계속 최신코드를 받아서 사용해야하는데 이번엔 origin만 두게되어.. 좀 희안한 플로우가 되었다... 다음엔 이런실수를 하지 않아야지..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221103_01.png&quot; alt=&quot;이상적인 Fork협업 플로우&quot;&gt;&lt;/p&gt;
&lt;h2&gt;2. [회고] 221103 회고&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;프로젝트 마무리&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;br&gt;
오늘까지 프로젝트를 완성해야 내일 넉넉하게 발표준비를 할 수 있기 때문에, 각 임무를 열심히 수행 중이신 팀원들에게 죄송하지만..
어쩔수없이 시간을 정해놓고 문제를 해결하길 요청드렸다.
다행히도 다들 git에서 문제를 겪으신것 빼고는, 시간안에 기능을 구현하셔서 제출해주셨다.&lt;br&gt;
그 과정에서 다들 내 덕에 문제를 해결했다는 피드백을 주셨는데, 다들 문제를 해결하는 과정에서 확신이 없다보니 맞는방향으로 가고있음에도 불구하고 그걸 적용하지 않고 있다가, &apos;잘하고 계십니다!&apos;라는 피드백을 드렸을 때 그제야 코드를 적용하시는 모습을 보면서 내가 팀원분들의 생각을 막고 있는 것 같다는 생각이 들어서 많이 죄송했다.&lt;/p&gt;
&lt;p&gt;아마도 나중엔 팀원들이 내 도움이 아닌 본인 스스로의 능력으로 코드를 작성하셨다는 것을 깨달을 것이라고 생각한다.&lt;/p&gt;
&lt;p&gt;좀 민망 모먼트가 있었는데, 서버-클라이언트 연결을 하고, 각 페이지에 해당되는 방명록만 받아볼 수 있는 기능을 담당하는 팀원이 작업을 마치고 후련해하고 계셨는데, 할당업무 범위에 대한 오해가 있었다. 우리 프로젝트는 메인페이지 + 각 멤버별 페이지로 구성되어 있는데, 팀원분은 각 멤버별 페이지에서만 해당기능을 동작하도록 만드는 것이라고 생각했고, 나는 메인페이지를 포함한 모든페이지에서 동작하도록 만드는 것을 제안드린 것이었다. 이런 상황을 말씀드리니 팀원분께서 많이 부담스러워 하시는 것이 보였다. 그도그럴게, 어제부터 몇십시간동안 집중을 유지하며 오셨고, 그걸 다 해결했다고 생각했는데 그게 아니라고 하니 아마 소위 &apos;멘붕&apos;이 오셨던게 확실해보였다.&lt;br&gt;
사실 메인페이지 내용을 불러오는게 다른페이지에 작성하셨던 코드와 별반차이는 없지만, 그게 이미 &apos;멘붕&apos;상태인 팀원에게는 받아들이기 버거울 수 있다는 생각을 했다. 가이드를 머리로는 이해하셨는데, 행동으로 하실 체력이 없어보였다..
따라서, 내가 콘솔같은 자잘한 것들을 정리하면서, 해당부분을 작업해드리기로 했다. 근데, 내가 작업하는 과정을 공유해달라고 하셔서 작업과정을 화면을 공유하고 팀원들이 내가 지금 어떤 행동을 하고 있는지 알 수 있도록 말하면서 진행했다. 근데 정신을 차리고보니 zep을 봤는데, 멘토님과 매니저님께서 오셔서 그 과정을 구경하고 계셨다(!)
멘토님께 프로젝트 관여는 최소한으로 해달라는 미션(?)를 받았기 때문에 내가 코드를 작성하고 있는것을 들킨 상황이 민망했다..&lt;/p&gt;
&lt;p&gt;그래도, 처음에 서먹했던 팀원들이 내가 할당한 업무를 통해 성취감을 얻고, 성장한 것이 보여서 뿌듯했다.
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
근데 왜 제가..발표죠?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221103_02.png&quot; alt=&quot;사다리타기로 발표 걸림&quot;&gt;&lt;/p&gt;
&lt;h2&gt;3. [회고] 내일 다짐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;두괄식으로 이야기하기&lt;/li&gt;
&lt;li&gt;머릿속에 생각을 정리한 뒤, 말하기&lt;/li&gt;
&lt;li&gt;남들앞에 서는 것을 두려워하지 않기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-02 Today I Learn]]></title><description><![CDATA[1. JSON과 XML XML(eXtensible Markup Language) 마크업 언어로서, 데이터를 정의할 때 쓰인다. 해당 문서의 요소는 데이터로서, 유저는 작성된 데이터를 저장하여 다른곳에 전송한다. HTML…]]></description><link>https://mitoconcrete.github.io/22_11_02/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_02/</guid><pubDate>Wed, 02 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. JSON과 XML&lt;/h2&gt;
&lt;h3&gt;XML(eXtensible Markup Language)&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;xml&quot;&gt;&lt;pre class=&quot;language-xml&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;xml&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;1.0&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;toy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;robot&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;toy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;fruit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;apple&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;fruit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;xml&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;마크업 언어로서, 데이터를 정의할 때 쓰인다.&lt;/li&gt;
&lt;li&gt;해당 문서의 요소는 데이터로서, 유저는 작성된 데이터를 저장하여 다른곳에 전송한다.&lt;/li&gt;
&lt;li&gt;HTML과 유사한 방식으로 데이터에 해당되는 태그를 열고 닫음으로서, 데이터를 정의한다.&lt;/li&gt;
&lt;li&gt;XML에는 데이터설명,버전을 적을 수 있어, 이를 이용해 데이터의 무결성을 보장한다.&lt;/li&gt;
&lt;li&gt;따라서, 은행,정부문서와 같은 데이터의 무결성이 중요한 곳에서 XML을 주로 사용한다.&lt;/li&gt;
&lt;li&gt;문서를 파싱하여, 가공가능 한 데이터로 만드는 것에 시간이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JSON(JavaScript Object Notation)&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string-property property&quot;&gt;&quot;toy&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;robot&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string-property property&quot;&gt;&quot;fruit&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;apple&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;key : value 쌍으로 이루어진, 데이터 형태&lt;/li&gt;
&lt;li&gt;JSON은 자바스크립트 함수인 eval()로 파싱되어 해석된다.&lt;/li&gt;
&lt;li&gt;문자열을 전송받은 후 곧바로 문자열을 파싱하므로 XML에 비하여 가공속도가 빠르다.&lt;/li&gt;
&lt;li&gt;따라서, 빨리 읽고 쓸 수 있다는 장점이 있다.&lt;/li&gt;
&lt;li&gt;하지만, 데이터의 버전이나, 설명같은 부가설명을 할 수 없기 때문에 무결성을 보장 할 수 없다.&lt;/li&gt;
&lt;li&gt;따라서, 무결성 보장을 위한 검증을 추가적으로 신경써줘야한다.&lt;/li&gt;
&lt;li&gt;JSON은 XML과 다르게, 배열사용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. [회고] 221102 회고&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;팀 프로젝트 진행&lt;/li&gt;
&lt;li&gt;팀원들 문제 해결1 : git flow&lt;/li&gt;
&lt;li&gt;팀원들 문제 해결2 : 업무 할당&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;br&gt;
개인 게시판 마크업이 끝나고, 팀원들의 모든 HTML파일을 모았다. 팀원명을 클릭했을 때, 클릭한 팀원의 페이지로 이동하는 로직을 작성해야했다.
팀원들이 5명인데, 기존에는 팀원들 5명에대한 html을 rendering하는 함수를 일일히 작성해야하는지 고민했다.&lt;/p&gt;
&lt;p&gt;같은 기능이 반복될 것 같아서, 지속적으로 고민하다 갑자기 문득떠오른게 query parameter을 이용하여, 동적으로 html파일을 선택하고 rendering하는 방법이었다!
query parameter 전달기능을 곧바로 &lt;code class=&quot;language-text&quot;&gt;app.py&lt;/code&gt;에 적용해보았는데 잘 동작하길래 곧바로 아래의 api를 작성하여 적용하였다.
이제 우리 팀페이지는 하나의 함수에서 동적으로 선택되어 보여진다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/members&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; methods&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;members&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    parameter_dict &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;to_dict&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; parameter_dict&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; render_template&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&apos;members/&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;.html&apos;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;br&gt;
나의 욕심으로 이번 프로젝트에서 팀원들이 git을 사용하도록 제안하였다. 아침에 &lt;em&gt;진실의 방(=휴게실)&lt;/em&gt;에서 git을 사용하는 모습을 간단히 시연해드렸는데, 처음에 3분만 계셨는데 시연이 모두 끝나고 돌아보니깐 팀원들이 모두 시연을 보러와주셨다. 휴게실 책상이 작은데 옹기종기 모여있는 모습이 귀여웠다.
public repo에 권한만 있다면, 다른팀원들도 PR을 없이 push/pull 다 할 수 있을 줄 알았는데, 내 착각이었다.
역시나 권한문제가 발생하였고, 내 repo를 fork해서 PR을 날려야 하는 상황이 되었다.&lt;/p&gt;
&lt;p&gt;죄송하다고 말씀드리고 모든 팀원들의 &lt;code class=&quot;language-text&quot;&gt;remote origin&lt;/code&gt;을 fork repo로 변경하는 것을 도와드렸다. 원래는 가이드 드릴 때 직접적인 커멘드를 말씀드리지 않았는데, 배우지 않은 부분이라 지금어떤일을 하고 있는지 정도만 이해시키고 내가 커멘드를 직접 말씀드리며 가이드를 드렸다.
몇몇 분들은 아직 아리까리하시다고 피드백 주셨지만, 금새 적응하여 PR을 하시고, 재미있어하는 모습을 보여주셔서 내가 다 뿌듯했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221102_01.jpg&quot; alt=&quot;팀원들이 커밋을 보낸순간&quot;&gt;&lt;/p&gt;
&lt;p&gt;git문제를 해결해드리면서, 가장 신경을 썻던 것은 &apos;내가 문제를 직접적으로 해결해드리지 않는것&apos;과 &apos;정답을 말하지 않는 것&apos;이었다. 가이드가 끝나고 난 뒤, 혹시 의사를 결정하는데 있어서 내 의견이 많이 방해가 되었는지, 문제를 해결하고 난 뒤 온전히 본인 것이라는 기분이 들지 않는지, 흐름은 이해되셨는지 체크했다. 다행히도, 긍정적인 반응들을 보내주셔서 감사했다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;br&gt;
팀원들이 모두 집중 할 수 있는 프로젝트가 되었으면 해서 끊임없이 어떻게 업무를 분배하면 좋을지 고민했다. 메인페이지 + 개인페이지의 구성으로 이루어진 프로젝트 특성상 개인페이지의 작업을 모두 마친 현상태에서, 메인페이지로 오버헤드가 몰릴 것이 당연한 상황이었다.
따라서, 메인페이지에 업무가 모이지 않도록 다른 곳으로 업무를 분산시키는 것이 좋겠다는 생각을 했고, 모든 페이지를 모아서 작업을 할 때, 필요한 작업들을 추려서 팀원숫자만큼 나누어보았다.&lt;br&gt;
어쩌다보니, 프로젝트 리드(?) 같은 역할을 수행하게 되었는데 팀장과 역할이 겹치는 부분이 많아서 불편해 하실 수 있겠다는 생각이 들어 내가 하는 고민들을 공유하는게 낫겠다는 판단이 들어 팀장님께 내가하고 있는 고민들을 공유드리기 위해 미팅을 요청드렸다.&lt;br&gt;
오히려 내 고민을 이해해주시고, 오히려 생각못한 상황들을 대신 생각해줘서 고마웠다 라는 말씀을 해주셔서 너무 감사했다. 모두가 끊임없이 작업 할 수 있는 환경을 위해 남은 팀원들에게 git branch 를 생성하는 방법을 전달해주었고, 팀원들이 작업을 시작했다.&lt;br&gt;
나는 남은 Due까지 모두가 지치지 않고, 프로젝트를 끝 마칠 수 있도록 돕고싶고, 도울것이다. 팀원들의 성장을 막는 행동은 지속적으로 신경써서 하지 않으려고 한다.&lt;/p&gt;
&lt;h2&gt;3. [회고] 내일 다짐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;팀원의 생각흐름에 관여하지 않기, 흐르는 대로 함께가고, 그곳에서 최선의 방법을 찾아서 제시해주기.&lt;/li&gt;
&lt;li&gt;상대방의 성취감을 뺏지않으려고 노력하기&lt;/li&gt;
&lt;li&gt;자바 기본 문법 3단원까지 공부하기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-11-01 Today I Learn]]></title><description><![CDATA[1. 회고 221101 회고 개인페이지 제작 팀원들 문제 해결 튜터님과 상담 1) 오늘은 모든 팀원이 개인페이지 개발에 집중하기로 한 날이다. 어젯밤동안 구상한 UI를 Figma를 이용해 구현해보면서 개인페이지에 대한 틀을 잡았다. Figma…]]></description><link>https://mitoconcrete.github.io/22_11_01/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_11_01/</guid><pubDate>Tue, 01 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. [회고] 221101 회고&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;개인페이지 제작&lt;/li&gt;
&lt;li&gt;팀원들 문제 해결&lt;/li&gt;
&lt;li&gt;튜터님과 상담&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;br&gt;
오늘은 모든 팀원이 개인페이지 개발에 집중하기로 한 날이다. 어젯밤동안 구상한 UI를 Figma를 이용해 구현해보면서 개인페이지에 대한 틀을 잡았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221101_01.png&quot; alt=&quot;Figma 구상&quot;&gt;&lt;/p&gt;
&lt;p&gt;WIX의 템플릿에서 영감을 받았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/221101_02.png&quot; alt=&quot;레퍼런스 템플릿&quot;&gt;&lt;/p&gt;
&lt;p&gt;모바일은 따로 구상을 한게 아니라, 계속 CSS를 수정하면서 이쁜모양을 찾아보고 최종적으로 디자인을 결정하였다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;br&gt;
모든 개발을 마치고, 팀원들이 겪는 어려움을 해결해드렸다.&lt;br&gt;
어려움을 해결해드리는 과정에서 가장 신경썼던 점은, 스스로 문제를 해결하는 즐거움을 팀원들에게 뺏지 않는 것이었다.&lt;br&gt;
한 발자국만 더 가면 문제가 해결되는 경우가 많았기 때문에, 만약 내가 정확한 문제를 짚어 문제를 해결하면 해결하는 속도는 빨라지겠지만, 당사자입장에서는 당장은 좋아도 &apos;아 조금만 더 생각해볼걸&apos;이라는 후회가 남는 경우가 많을 거라고 생각했다.(실제로도 내가 겪음)&lt;br&gt;
따라서, 팀원분들이 겪고계신 문제를 공유해주시면, 우선은 화면을 보면서 정확한 원인을 파악하고 문제가 발생하는 순서를 같이 정렬해보며, 이 문제가 왜 발생했는지 고민해보실 수 있도록 유도했다. 보통은 이 과정 중에 &apos;아!&apos; 하시면서, 문제를 해결하시는 경우가 많았다.&lt;br&gt;
대부분 실패를 두려워하시고, 자신감이 없는 모습을 보이셔서 안타까웠는데, 그럴때마다 &apos;잘하고계십니다! 문제가 있으면 에러를 보여줄거에요. 생각하신 코드를 한번 적어보세요!&apos; 라고 말씀드렸다.&lt;br&gt;
팀원분들께 &apos;생각의 주도권을 뺏지 않았는지&apos;, &apos;설명해드리는 과정에서 속도가 적절했는지&apos; 등등의 피드백을 요청드렸고, 다행이도 긍정적인 피드백을 주셨다.&lt;br&gt;
다만, 지금까지는 내가 겪어봤고 아는 문제였기에 이런 스탠스를 지닐 수 있었지, 내가 모르는 문제들에 대해서도 일목요연하게 문제를 해결 할 수 있을지는 의문이긴하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;br&gt;
튜터님과 저녁에 상담을 진행했다. 내 경험들을 들으시고, 내가 현시점에 겪고 있는 고민들을 정확히 짚어주셨다.
&apos;어느 깊이까지 피드백을 드리면 좋을지&apos;, &apos;피드백으로 팀원들의 생각을 방해하는게 아닐지&apos; 또 이후에, 기술적인 고민에 대해서 솔직하게 공유드렸다.&lt;br&gt;
나는 어떤 기술을 습득해서 기획대로 만드는 것에는 자신있는데, 이 기술이 어떤원리로 동작하고 왜 사용하는지에 대해서는 잘 말하지 못한다.
따라서, 이 고민을 공유드렸고, 튜터님께서는 백엔드에서는 문제가 발생했을 때 크리티컬한 문제가 발생하고, 그 원인을 정확하게 진단하기 위해서는 어떤원리로 동작하는지 이해하고 공부해야한다고 답변을 주셨다.&lt;br&gt;
또한, 알고리즘에 대해 자세히 알지 못한다고 말씀드리니 &apos;그건 지금부터 하시면 됩니다!&apos;라고 유쾌하게 말씀주셨다.
퇴사이후 지난 시간동안 했던 스택선택과 커리어적 고민들을 털어놓으니 후련했다.&lt;br&gt;
자바강의를 미리들으며 공부해보는 것을 추천받았는데, 내일부터 한번 들어보려고 한다.&lt;/p&gt;
&lt;h2&gt;2. [회고] 내일 다짐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;상대방의 성취감을 뺏지않으려고 노력하기&lt;/li&gt;
&lt;li&gt;상대방의 말을 듣기&lt;/li&gt;
&lt;li&gt;말하고자하는 것에 대해 명확히하고, 정리가 된 후 입밖으로 말하기&lt;/li&gt;
&lt;li&gt;서로 모르는 문제에 대해, 문제를 해결해 나가는 과정을 의식하고 기록하기&lt;/li&gt;
&lt;li&gt;개인 공부 시작 (자바 + 알고리즘)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-10-31 Today I Learn]]></title><description><![CDATA[1. git git 구조의 이해 git 구조는 디렉토리 + 스테이징 + 저장소의 3가지로 구성되어 버전을 관리한다. 디렉토리 버전을 관리할 코드가 위치한 경로. 즉, .git…]]></description><link>https://mitoconcrete.github.io/22_10_31/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_10_31/</guid><pubDate>Mon, 31 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. [git] git 구조의 이해&lt;/h2&gt;
&lt;p&gt;git 구조는 디렉토리 + 스테이징 + 저장소의 3가지로 구성되어 버전을 관리한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;디렉토리&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;버전을 관리할 코드가 위치한 경로. 즉, .git파일이 위치하는 파일 자체를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스테이징&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;디렉토리에서 감지된 변화가 저장되는 임시 저장소. (git add 커멘드를 이용하여 디렉토리 -&gt; 스테이징으로 변화를 저장한다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;저장소&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;스테이징에서 commit한 변화를 하나로 묶어 버전으로 저장소에 저장한다.
저장소에 저장된 코드는 github과 같은 코드저장소에 &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; 하여 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2. [git] git pull VS git fetch&lt;/h2&gt;
&lt;p&gt;git fetch와 pull은 원격저장소의 코드의 변화를 감지하는 기능이 있다는데에서 공통점을 가지고 있다.&lt;br&gt;
차이점은, fetch는 원격저장소의 변화가 있어도 로컬의 코드에 덮어쓰지 않고, pull은 원격저장소의 변화를 코드에 덮어씌운다.&lt;/p&gt;
&lt;h2&gt;3. [회고] 221031 회고 : 이기적 개발&lt;/h2&gt;
&lt;p&gt;오늘 처음 내일배움캠프를 참여하여, 팀프로젝트를 진행했다.&lt;br&gt;
미니프로젝트의 주제는 사전캠프를 통해 배운 것들을 이용해, 팀 소개 페이지를 만드는 것이었다.&lt;br&gt;
팀 협업을 너무 오랜만에 해서 좋았지만 두려움도 있었다.&lt;br&gt;
그래서 그런지, 과거의 좋지않은 습관이 나왔다. 주변을 돌아보지 않고 나도모르게 API 문서를 와다다다 작성하고 있었다.&lt;br&gt;
결과적으로 초기 API는 5개가 나왔다. 이후에 매니저님께 문서 피드백 받았는데, 기한을 맞출 수 있는지 우려하셨고 모두의 속도에 맞출 수 있는 대안을 제시해주셨다. 매니저님의 피드백을 듣고, 팀원들의 얼굴을 보았다. 지쳐보이는 기색이 역력했다.&lt;br&gt;
죄송하다고 말씀드리고, API를 기초적인 기능만 빼고 모두 수정하여, 2개만 남겼다.
과연, 나는 오늘 팀원들에게 편안함을 줄 수 있는 동료였는가? 라고 평가를 해보았을 때, 전혀 아니라고 생각했다.&lt;/p&gt;
&lt;h2&gt;4. [회고] 내일 다짐&lt;/h2&gt;
&lt;p&gt;과거의 쓸데없는 경험은 버리자. 겸손하자.&lt;br&gt;
나는 팀 협업경험이 부족했다.&lt;br&gt;
그렇기에 팀과 함께 소통하는 개발자로 성장하고 싶었고, 따라서, PBL(Project Based Learn)방식으로 교육을 진행하는 내일배움캠프에 합류했다.&lt;br&gt;
팀원들의 속도에 맞출 수 있는 개발자로 성장하자.&lt;br&gt;
&apos;제가 예전에 해봤어요.&apos; 라는 설득력없는 근거(라고 쓰고 고집이라고 읽는다)보다, 모두가 납득할 수 있는 근거로 모두를 설득할 수 있는 개발자가 되자. 남을 기분좋게 만드는 사람이 되자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-09-02 Today I Learn]]></title><description><![CDATA[1. Javascript 실행컨텍스트 추후 추가예정 2. Javascript 스코프 체인 추후 추가예정 3. CS HTTP 상태코드 HTTP 상태코드 포스팅]]></description><link>https://mitoconcrete.github.io/22_09_02/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_09_02/</guid><pubDate>Fri, 02 Sep 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. [Javascript] 실행컨텍스트&lt;/h2&gt;
&lt;p&gt;추후 추가예정&lt;/p&gt;
&lt;h2&gt;2. [Javascript] 스코프 체인&lt;/h2&gt;
&lt;p&gt;추후 추가예정&lt;/p&gt;
&lt;h2&gt;3. [CS] HTTP 상태코드&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/HTTP_상태코드&quot;&gt;HTTP 상태코드 포스팅&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP]]></title><description><![CDATA[1. 2xx Success 200 : 성공 201 : 성공 + 새로운 리소스가 생성됨. 새롭게 생성된 리소스의 주소를  헤더에 담아 보낸다. 202 : 요청이 접수되었으나, 당장 처리하지 않음 (ex : 배치) 20…]]></description><link>https://mitoconcrete.github.io/HTTP_상태코드/</link><guid isPermaLink="false">https://mitoconcrete.github.io/HTTP_상태코드/</guid><pubDate>Fri, 02 Sep 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 2xx Success&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;200&lt;/strong&gt; : 성공&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;201&lt;/strong&gt; : 성공 + 새로운 리소스가 생성됨. 새롭게 생성된 리소스의 주소를 &lt;code class=&quot;language-text&quot;&gt;Location&lt;/code&gt; 헤더에 담아 보낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;202&lt;/strong&gt; : 요청이 접수되었으나, 당장 처리하지 않음 (ex : 배치)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;204&lt;/strong&gt; : 서버가 요청을 성공적으로 수행했지만, 응답에 보낼 데이터가 없음. (ex: 웹문서 편집기 자동저장)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 3xx Redirection&lt;/h2&gt;
&lt;p&gt;웹브라우저는 &lt;code class=&quot;language-text&quot;&gt;3xx 응답 + Location 헤더&lt;/code&gt;의 응답이 오면 해당주소로 자동이동한다.
이 때 응답주소에 따라 &lt;strong&gt;영구적 리다이렉션&lt;/strong&gt;, &lt;strong&gt;일시적 리다이렉션&lt;/strong&gt; , &lt;strong&gt;특수 리다이렉션&lt;/strong&gt;으로 구분된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;영구적 리다이렉션(301, 308) : 특정 리소스의 URI가 영구적으로 리다이렉트 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;301 Moved Permanently&lt;/h5&gt;
&lt;p&gt;실무에 많이 쓰임. 새로고침 시 요청이 GET으로 변경되고, 본문이 제거 될 수 있음.&lt;br/&gt;
이용자는 입력을 다시하는 경험을 할 수 있음. 하지만, 보통 입력하는 폼 자체가 모두 변경되기 때문에, 사용자는 체감을 거의하지 못함.&lt;/p&gt;
&lt;h5&gt;308 Parmanent Redirect&lt;/h5&gt;
&lt;p&gt;새로고침 시 요청을 POST로 변경하고, 본문을 유지함.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일시적 리다이렉션(302, 307, 303): 특정 리소스의 URI가 일시적으로 리다이렉트 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;302 Found&lt;/h5&gt;
&lt;p&gt;새로고침 시 요청이 GET으로 변경되고, 본문이 제거될 수 있음&lt;/p&gt;
&lt;h5&gt;307 Temporary Redirect&lt;/h5&gt;
&lt;p&gt;302와 기능은 같으나, 새로고침 시 요청메서드와 본문을 이전과 동일하게 유지함.(요청메서드 변경X)&lt;/p&gt;
&lt;h5&gt;303&lt;/h5&gt;
&lt;p&gt;302와 기능은 같으나, 새로고침 시 요청메서드를 &lt;strong&gt;무조건&lt;/strong&gt; GET으로 변경됨.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h6&gt;PRG(POST/Redirect/GET) - 일시적 리다이렉션&lt;/h6&gt;
&lt;p&gt;PRG 사용으로 중복주문상황을 막을 수 있다.
PRG를 사용하지 않은 상황에선 주문완료이후 유저가 새로고침을 했을 때, 동일 POST 요청이 들어가므로, 의도치않게 동일 주문이 1개 더 생기는 상황이 발생 할 수 있음
PRG를 사용하면, 리다이렉트 후 보여진 화면에서 GET만  호출되기 때문에, 유저가 새로고침을해도 동일주문이 생성되지 않음.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특수 리다이렉션(300, 304) : 결과대신 캐시를 이용한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;300 Multiple chioce&lt;/h5&gt;
&lt;p&gt;요청에 가능한 응답이 두 개 이상 있음을 나타냄 사용자 에이전트 또는 사용자는 둘 중 하나를 선택해야 함. 응답 중 하나를 선택하는 표준화된 방법이 없기 때문에 이 응답 코드는 거의 사용되지 않음. 서버가 원하는 것을 선택하면 Location 헤더를 생성해야함.&lt;/p&gt;
&lt;h5&gt;304 Not Modified&lt;/h5&gt;
&lt;p&gt;주로, GET, HEAD 요청 시 사용한다.
서버가 클라이언트에게 캐시가 만료되지 않았기 때문에 클라이언트에 저장된 캐시를 사용할 수 있도록 유도한다. 응답에 메시지 바디를 포함하면 안된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 4xx Client Error&lt;/h2&gt;
&lt;p&gt;오류의 원인이 클라이언트에 있기에, 같은 요청을 보냈을 시 100%실패함.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;400 Bad Request&lt;/h5&gt;
&lt;p&gt;클라이언트가 요청내용(파라미터, 메시지)을 다시 검토하고 보내야함.&lt;/p&gt;
&lt;h5&gt;401 Unauthorized&lt;/h5&gt;
&lt;p&gt;클라이언트가 해당리소스에 대한 인증이 필요함. 401 오류 발생시에 응답에 WWW-Authenticate 헤더와 함께 인증방법을 성명해야한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Authentication : 인증(로그인)이 필요&lt;/li&gt;
&lt;li&gt;Authorization : 인가(권한 부여)가 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h5&gt;403 Forbidden&lt;/h5&gt;
&lt;p&gt;요청을 이해했지만, 권한이 없어 접근이 불가함.&lt;/p&gt;
&lt;h5&gt;404 Not Found&lt;/h5&gt;
&lt;p&gt;요청리소스를 서버에서 찾을 수 없거나, 클라이언트가 권한이 없는 리소스에 요청을 보냈는데, 그 리소스를 숨기고 싶을때&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;4. 5xx Server Error&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h5&gt;500 Internal Server Error&lt;/h5&gt;
&lt;p&gt;서버 내부문제로 오류발생&lt;/p&gt;
&lt;h5&gt;503 Service Unavalidble&lt;/h5&gt;
&lt;p&gt;서버가 일시적인 과부하 또는 예정된 작업을 요청을 처리할 수 없음. Retry-After 헤더로 얼마 뒤에 복구 되는지 보낼 수 있음. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;!중요!&lt;/h2&gt;
&lt;p&gt;500에러는 정말 서버에 문제가 있을 때 내는 것이기 때문에, 비즈니스 로직 상 발생한 문제에 대해서 500보단 2xx, 4xx대 코드로 해결해야함.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-08-30 Today I Learn]]></title><description><![CDATA[1. 라운드 로빈 스케쥴링 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 간에 우선순위를 두지 않고 순서대로 시간단위로 CPU…]]></description><link>https://mitoconcrete.github.io/22_08_30/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_08_30/</guid><pubDate>Tue, 30 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 라운드 로빈 스케쥴링&lt;/h2&gt;
&lt;p&gt;시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 간에 우선순위를 두지 않고 순서대로 시간단위로 CPU를 할당하는 스케쥴링 방식입니다.
추후 학습할 자바스크립트 이벤트 루프의 동작방식이 라운드 로빈 스케쥴링 방식입니다.&lt;/p&gt;
&lt;h2&gt;2. 자바스크립트 프로토타입&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/JS_프로토타입&quot;&gt;프로토타입 학습 링크&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로토타입에 관하여]]></title><description><![CDATA[prototype 원형을 의미합니다.
원형의 속성을 조회하고 싶다면 아래와 같이 조회하면 된다. 하지만 new 키워드를 통해서 만든 복제품 에게는 원형의 속성을 조회할 수 없다.
예를 들어 아래의 코드에서는 prototype 이 undefined…]]></description><link>https://mitoconcrete.github.io/JS_프로토타입/</link><guid isPermaLink="false">https://mitoconcrete.github.io/JS_프로토타입/</guid><pubDate>Tue, 30 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;prototype&lt;/h2&gt;
&lt;p&gt;원형을 의미합니다.
원형의 속성을 조회하고 싶다면 아래와 같이 조회하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token comment&quot;&gt;// {...}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 new 키워드를 통해서 만든 &lt;strong&gt;복제품&lt;/strong&gt; 에게는 원형의 속성을 조회할 수 없다.
예를 들어 아래의 코드에서는 prototype 이 undefined 로 동작한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[[Prototype]]&lt;/h2&gt;
&lt;p&gt;원형의 속성의 주소를 저장하고 있는 내부 속성인 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 을 이용하여, 자식들에게 할당한다.
조회는 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;getPrototypeOf()&lt;/code&gt;을 이용하여 접근가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;foo&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Foo
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Coo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

Bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;// 1. foo&lt;/span&gt;
Coo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;// 2. foo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bar와 Coo에는 직접적인 name이라는 프로퍼티가 할당되어 있지않다. 하지만, 어떻게 name이라는 속성에 접근할 수 있었을까?
name을 조회하기 위해서 자바스크립트 엔진은 현재 인스턴스에 name이란게 없다면, 내부속성인 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 을 순차적으로 조회하며 name이라는 속성이 있는지 조회한다.&lt;/p&gt;
&lt;p&gt;아래는 Bar.name 시 foo가 출력되는 순서이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Bar.name -&gt; 없음&lt;/li&gt;
&lt;li&gt;Bar.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.name (=Foo.name) -&gt; &lt;strong&gt;&lt;em&gt;있음!&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;foo 출력&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래는 Coo.name 시 foo가 출력되는 순서이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Coo.name -&gt; 없음&lt;/li&gt;
&lt;li&gt;Coo.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.name (=Bar.name) -&gt; 없음&lt;/li&gt;
&lt;li&gt;Coo.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.name (=Foo.name) -&gt; &lt;strong&gt;&lt;em&gt;있음!&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;foo 출력&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;실제로 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 이 쓰이진 않고 위에서 언급한 것 처럼 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;getPrototypeOf()&lt;/code&gt;를 이용해 조회할 수 있다.&lt;/p&gt;
&lt;p&gt;그렇다면 아래의 상황에서는 어떻게 동작할까? &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;foo&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token literal-property property&quot;&gt;__proto__&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Foo
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Coo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

Bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;// 1. foo&lt;/span&gt;

Coo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;coo&apos;&lt;/span&gt; 

Foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;// 2. ?&lt;/span&gt;
Bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;// 3. ? &lt;/span&gt;
Coo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;// 4. ? &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정답은 &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;foo&lt;/li&gt;
&lt;li&gt;foo &lt;/li&gt;
&lt;li&gt;coo
이다. &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;2, 3의 동작은 위와 같지만, 4의 동작이 조금 달라진다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Coo.name -&gt; 있음&lt;/li&gt;
&lt;li&gt;coo 출력&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;새롭게 name을 자식에 할당함으로서, &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;을 조회하지 않고, 곧바로 name을 가져올 수 있었다.&lt;/p&gt;
&lt;h2&gt;프로토타입 체인&lt;/h2&gt;
&lt;p&gt;위의 과정에서 아래와 같은 과정을 거쳤다.
Coo.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.name (=Bar.name)
Coo.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;.name (=Foo.name)&lt;/p&gt;
&lt;p&gt;이 처럼 없는 속성을 계속 연결된 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;주소를 통해 찾아내려가는 현상이 마치 체인처럼 이어졌다고하여, &lt;strong&gt;프로토타입 체인&lt;/strong&gt; 이라고 명명한다.&lt;/p&gt;
&lt;h2&gt;constructor&lt;/h2&gt;
&lt;p&gt;constructor는 new 키워드를 이용하여 생성된 인스턴스가 자신을 낳은 주체가 무엇인지 표현하기 위해 사용되는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constructor &lt;span class=&quot;token comment&quot;&gt;// function Array&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constructor &lt;span class=&quot;token comment&quot;&gt;// function Foo&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;참고&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-06-14-prototype/&quot;&gt;https://tecoble.techcourse.co.kr/post/2021-06-14-prototype/&lt;/a&gt;
&lt;a href=&quot;https://ko.javascript.info/function-prototype&quot;&gt;https://ko.javascript.info/function-prototype&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-08-29 Today I Learn]]></title><description><![CDATA[1. 이벤트 실행 우선순위 인라인 이벤트실행 -> addEventListener 이벤트 실행
인라인 이벤트는 event 객체가 parameter로 넘겨지지 않습니다. 2. 버블링과 캡쳐링 버블링과 캡쳐링에 대하여]]></description><link>https://mitoconcrete.github.io/22_08_29/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_08_29/</guid><pubDate>Mon, 29 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 이벤트 실행 우선순위&lt;/h2&gt;
&lt;p&gt;인라인 이벤트실행 -&gt; addEventListener 이벤트 실행
인라인 이벤트는 event 객체가 parameter로 넘겨지지 않습니다.&lt;/p&gt;
&lt;h2&gt;2. 버블링과 캡쳐링&lt;/h2&gt;
&lt;p&gt;&lt;a href=&apos;/JS_버블링과캡쳐링&apos;&gt;버블링과 캡쳐링에 대하여&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[이벤트 버블링/캡쳐링]]></title><description><![CDATA[1. 버블링 정의 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는 현상.…]]></description><link>https://mitoconcrete.github.io/JS_버블링과캡쳐링/</link><guid isPermaLink="false">https://mitoconcrete.github.io/JS_버블링과캡쳐링/</guid><pubDate>Mon, 29 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 버블링 정의&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는 현상.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&apos;https://ko.javascript.info/article/bubbling-and-capturing/event-order-bubbling.svg&apos; width=&apos;300&apos; alt=&apos;[출처]javascript korea&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token special-attr&quot;&gt;&lt;span class=&quot;token attr-name&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token value javascript language-javascript&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 캡쳐링 정의&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;이벤트가 상위에서 하위로 전달되며 핸들러를 실행하는 현상.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&apos;https://ko.javascript.info/article/bubbling-and-capturing/eventflow.svg&apos; width=&apos;300&apos; alt=&apos;[출처]javascript korea&apos;&gt;&lt;/img&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token special-attr&quot;&gt;&lt;span class=&quot;token attr-name&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token value javascript language-javascript&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 구조에서 c를 클릭했을 경우, 이벤트가 a -&gt; b -&gt; c 로 전파되는 현상을 의미한다.
다음과 같이 event 를 등록 할 떄, capture option을 활성화하여 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;el&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; event &lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token literal-property property&quot;&gt;capture&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// or &lt;/span&gt;

el&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; event &lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. stopPropagation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;propagation의 뜻은 &lt;strong&gt;번식&lt;/strong&gt; 이다.
부모 element로의 캡쳐링/버블링을 막기위해선, stopPropagation 을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token special-attr&quot;&gt;&lt;span class=&quot;token attr-name&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token value javascript language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stopPropagation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행하게 되면, 이벤트는 c에서만 실행되게 된다.&lt;/p&gt;
&lt;h2&gt;4. stopImmediatePropagation&lt;/h2&gt;
&lt;p&gt;같은 레벨에 여러가지 이벤트 리스너가 등록되어 있을 경우에, stopPropagation을 사용하면
동일레벨에서의 메서드 실행을 제어하지 못한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token special-attr&quot;&gt;&lt;span class=&quot;token attr-name&quot;&gt;onclick&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token value javascript language-javascript&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;함수&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;함수&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 케이스에서 A함수의 실행만 시키고 싶어 stopPropagation을 함수내부에서 호출하여도, 같은레벨의 B함수는 계속 실행된다.
이유는 stopPropagation은 상위레벨로의 이벤트 전파만 방지하기 때문이다.&lt;/p&gt;
&lt;p&gt;위의 케이스에서는 stopImmediatePropatation을 사용하여, 같은레벨로 이벤트가 전파되는 것을 방지해준다.&lt;/p&gt;
&lt;h2&gt;5. Bubbling 되지않는 메서드&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;focus &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6. event.target vs event.currentTarget vs event.eventPhase&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;event.target :&lt;/strong&gt; 실제 이벤트가 발생한 타겟.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;event.currentTarget :&lt;/strong&gt; 현재 이벤트가 벌어지고 있는 모타겟.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;event.eventPhase :&lt;/strong&gt;  현재 이벤트 흐름 단계(캡처링=1, 타깃=2, 버블링=3)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7. 버블링을 굳이 막을 필요는 없다.&lt;/h2&gt;
&lt;p&gt;지금은 상위 요소에서 이벤트가 어떻게 쓰일지 확실치 않더라도, 추후에 버블링이 필요한 경우가 생기기 때문에 stopPropagation의 사용은 추천하지 않는다.&lt;/p&gt;
&lt;h2&gt;8. Bubbling이 Default value가 된 배경.&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;현실에서 사고가 발생하면 지역 경찰이 먼저 사고를 조사합니다. 그 지역에 대해 가장 잘 아는 기관은 지역 경찰이기 때문입니다. 추가 조사가 필요하다면 그 이후에 상위 기관이 사건을 넘겨받습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;9. 이벤트 위임(event delegation)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;캡쳐링과 버블링을 이용한 이벤트 핸들링 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;참고문헌&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.javascript.info/bubbling-and-capturing&quot;&gt;https://ko.javascript.info/bubbling-and-capturing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&quot;&gt;https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-08-28 Today I Learn]]></title><description><![CDATA[해시 테이블…]]></description><link>https://mitoconcrete.github.io/22_08_28/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_08_28/</guid><pubDate>Sun, 28 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;해시 테이블&lt;/h2&gt;
&lt;h3&gt;1. 개념&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;해시 - 고기와 감자를 잘게다져 요리한것. 키 값을 잘게 다져 특정 인덱스로 변경
&lt;br/&gt;-&gt; 키와 값을 받아 &lt;strong&gt;키를 해싱(잘게 쪼개어)&lt;/strong&gt;하여 도출된 인덱스에 값을 저장하는 구조&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;해시테이블이란?&lt;/strong&gt;&lt;br/&gt;  입력받은 값을 특정범위내의 숫자로 변경하는 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 해시충돌&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;해시함수를 거친 값이 동일하다면, 데이터가 삽입되는 위치가 중복되는 현상&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2-1. 해시충돌해결방법 1 : 선형탐사법&lt;/h4&gt;
&lt;p&gt;충돌이 발생하면 다음인덱스에 데이터 저장. 충돌이 발생하면 다른곳에 저장.&lt;/p&gt;
&lt;h4&gt;2-2. 해시충돌해결방법 2 : 제곱탐사법&lt;/h4&gt;
&lt;p&gt;충돌이 발생한 지점의 제곱만큼 옆으로 이동하여 데이터 저장 &lt;/p&gt;
&lt;h4&gt;2-3. 해시충돌해결방법 3 : 이중 해싱&lt;/h4&gt;
&lt;p&gt;A함수를 이용해 충돌이 발생하면 B함수를 통해 해싱하는것&lt;/p&gt;
&lt;h4&gt;2-4. 해시충돌해결방법 4 : 분리 연결&lt;/h4&gt;
&lt;p&gt;충돌이 발생하면, 연결리스트로직을 이용해 메모리에 저장. 한 메모리 내에 차지하는 데이터가 무한정 늘어날수 있음.&lt;/p&gt;
&lt;h3&gt;3.자바스크립트에서 해시테이블을 사용하는 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;배열&lt;/li&gt;
&lt;li&gt;객체&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; :&lt;/strong&gt; 키와 값이 다르게 저장. 키로 여러가지 타입을 저장할 수 있음.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt; :&lt;/strong&gt; 키와 값이 동일하게 저장. 중복된 내용 제거&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-08-25 Today I Learn]]></title><description><![CDATA[1. Javascript 구조분해할당을 통해 Swap을 구현 할 수 있다. ES6 문법이므로 이하 지원브라우저에서는 사용할 수 없음. 2. Javascript shift() 를 이용한 큐 구현은 효율적이지 못하다. shift…]]></description><link>https://mitoconcrete.github.io/22_08_25/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_08_25/</guid><pubDate>Thu, 25 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;1. [Javascript] 구조분해할당을 통해 Swap을 구현 할 수 있다.&lt;/h3&gt;
&lt;p&gt;ES6 문법이므로 이하 지원브라우저에서는 사용할 수 없음.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. [Javascript] shift() 를 이용한 큐 구현은 효율적이지 못하다.&lt;/h3&gt;
&lt;p&gt;shift를 이용하게 되면, 빈 첫번째 메모리를 메우는 동작을 하기 때문에 n의 속도가 보장된다.
따라서, 1의 속도를 보장해야하는 큐에서 적절하지 못하다. 아래와 같이 delete 를 이용하여 사용하면된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;location&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; priority&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;location &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; location
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;priority &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; priority
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;head &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rear &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;location&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; priority&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 추가 시 길이를 1늘려준다.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rear&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;location&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; priority&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;dequeue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 삭제시 앞에 빈칸을 하나 추가하고, head의 인덱스를 1증가시킨다.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;head&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;head&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// delete를 이용했기 때문에, 1의 속도를 보장한다.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; value
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. [HTTP] 상태코드의 종류&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1xx :&lt;/strong&gt; 요청이 수신되어 처리중 (거의사용하지않음)
&lt;strong&gt;2xx :&lt;/strong&gt; 정상처리
&lt;strong&gt;3xx :&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;요청을 완료하기 위해 추가적인 행동이 필요&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;4xx :&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;클라이언트 오류&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;5xx :&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;서버 오류&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4. [HTTP] 상태코드 추론&lt;/h3&gt;
&lt;p&gt;클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면 클라이언트는 &lt;strong&gt;상위 상태코드&lt;/strong&gt;로 해석해서 처리한다.&lt;br/&gt;
따라서, 미래에 새로운 상태코드가 추가되어도 클라이언트를 변경하지 않아도 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;388 -&gt; 3xx
499 -&gt; 4xx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[✏️ 2022-08-24 Today I Learn]]></title><description><![CDATA[1. form 을 통한 데이터 전송 시 http contents type aplication/x-www-form-urlencoded : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다. multipart…]]></description><link>https://mitoconcrete.github.io/22_08_24/</link><guid isPermaLink="false">https://mitoconcrete.github.io/22_08_24/</guid><pubDate>Wed, 24 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;1. form 을 통한 데이터 전송 시 http contents type&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;aplication/x-www-form-urlencoded&lt;/strong&gt; : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;multipart/form-data&lt;/strong&gt; : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. HTML form으로 GET요청도 가능하다.&lt;/h3&gt;
&lt;h3&gt;3. PUT은 일부 업데이트가 아니다.&lt;/h3&gt;
&lt;p&gt;기존의 리소스를 삭제하고 다른 리소스로 갈아치우는 것이기 때문에, 주의하여 사용해야한다.&lt;/p&gt;
&lt;h3&gt;4. PATCH는 리소스의 일부 업데이트를 의미한다.&lt;/h3&gt;
&lt;h3&gt;5. HTTP 메소드의 속성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;안전&lt;/strong&gt; : 호출해도 리소스를 변경하지 않는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET, HEAD, OPTION, TRACE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;멱등&lt;/strong&gt; : 여러번 호출해도 같은 결과를 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET, PUT, DELETE &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;캐시&lt;/strong&gt; : 응답결과의 리소스를 반복하여 사용가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET, HEAD&lt;/li&gt;
&lt;li&gt;POST, PUT : 캐시키를 이용해 body값까지 모두 캐싱해야하기 때문에 번거로워서 잘 쓰이지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. 메서드 설계 시 리소스에 해당되는 것은 &apos;명사&apos;이다.&lt;/h3&gt;
&lt;p&gt;ex) 미네랄을 캔다 에서 캔다가 중요요소가 아니라 미네랄을 기준으로 메서드를 설계해야한다.
GET /minerals -&gt; O
GET /dig -&gt; X &lt;/p&gt;
&lt;h3&gt;7. GET은 스펙상으로 body를 붙힐 수 있다.&lt;/h3&gt;
&lt;p&gt;구현이 되지 않은 서버가 많은 것일 뿐.&lt;/p&gt;
&lt;h3&gt;8. HEAD는 body를 붙힐 수 없는 GET이라고 보면된다.&lt;/h3&gt;
&lt;h3&gt;9. POST는 리소스 상태의 변경을 위한 용도로도 사용된다.&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;POST /car/{id}/start
POST /car/{id}/stop&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이때는 메서드에 동사를 사용한다.&lt;/p&gt;
&lt;h3&gt;10. POST와 PUT의 차이는 리소스의 정보를 어디서 알고있느냐의 차이다.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;POST : 리소스의 생성을 요청하면, 서버에서 생성정보를 보내줌&lt;/li&gt;
&lt;li&gt;PUT : 클라이언트에서 업데이트 할 리소스를 정해서 보내줌. 이 때, 클라이언트 내에 스토어로 리소스를 따로 관리해줘야하는 전제조건이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;11. 배열은 연속되는 순서로 메모리를 차지한다. 인덱스 값은 연속되지만, 주소값은 반드시 연속되어 증가하지 않는다.&lt;/h3&gt;
&lt;h3&gt;12. 자바스크립트 배열은 해시맵과 같아서, 논리값 할당이 가능하다. 단, 배열의 실제길이에 영향을 주지는 않는다.(사용권장X)&lt;/h3&gt;
&lt;h3&gt;13. 연결리스트는 메모리를 순서대로 차지하지 않는다.&lt;/h3&gt;</content:encoded></item></channel></rss>