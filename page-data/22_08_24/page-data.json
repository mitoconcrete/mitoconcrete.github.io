{"componentChunkName":"component---src-templates-post-jsx","path":"/22_08_24/","result":{"data":{"site":{"siteMetadata":{"title":"mitoconcrete"}},"markdownRemark":{"id":"e2e4aaa7-0968-5bbe-8808-c44ecd8527de","excerpt":"1. form 을 통한 데이터 전송 시 http contents type aplication/x-www-form-urlencoded : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다. multipart/form-data : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다. 2…","html":"<h3>1. form 을 통한 데이터 전송 시 http contents type</h3>\n<ul>\n<li><strong>aplication/x-www-form-urlencoded</strong> : string을 인코딩해서 전달해야 하기 때문에 urlencoded 라는 타입을 명시하여 사용한다.</li>\n<li><strong>multipart/form-data</strong> : 이미지 전송 시, 바이너리 파일로 여러 파트를 끊어서 보내야 할 경우 사용한다.</li>\n</ul>\n<h3>2. HTML form으로 GET요청도 가능하다.</h3>\n<h3>3. PUT은 일부 업데이트가 아니다.</h3>\n<p>기존의 리소스를 삭제하고 다른 리소스로 갈아치우는 것이기 때문에, 주의하여 사용해야한다.</p>\n<h3>4. PATCH는 리소스의 일부 업데이트를 의미한다.</h3>\n<h3>5. HTTP 메소드의 속성</h3>\n<ul>\n<li>\n<p><strong>안전</strong> : 호출해도 리소스를 변경하지 않는다.</p>\n<ul>\n<li>GET, HEAD, OPTION, TRACE</li>\n</ul>\n</li>\n<li>\n<p><strong>멱등</strong> : 여러번 호출해도 같은 결과를 보여준다.</p>\n<ul>\n<li>GET, PUT, DELETE </li>\n</ul>\n</li>\n<li>\n<p><strong>캐시</strong> : 응답결과의 리소스를 반복하여 사용가능하다.</p>\n<ul>\n<li>GET, HEAD</li>\n<li>POST, PUT : 캐시키를 이용해 body값까지 모두 캐싱해야하기 때문에 번거로워서 잘 쓰이지 않는다.</li>\n</ul>\n</li>\n</ul>\n<h3>6. 메서드 설계 시 리소스에 해당되는 것은 '명사'이다.</h3>\n<p>ex) 미네랄을 캔다 에서 캔다가 중요요소가 아니라 미네랄을 기준으로 메서드를 설계해야한다.\nGET /minerals -> O\nGET /dig -> X </p>\n<h3>7. GET은 스펙상으로 body를 붙힐 수 있다.</h3>\n<p>구현이 되지 않은 서버가 많은 것일 뿐.</p>\n<h3>8. HEAD는 body를 붙힐 수 없는 GET이라고 보면된다.</h3>\n<h3>9. POST는 리소스 상태의 변경을 위한 용도로도 사용된다.</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">POST /car/{id}/start\nPOST /car/{id}/stop</code></pre></div>\n<p>이때는 메서드에 동사를 사용한다.</p>\n<h3>10. POST와 PUT의 차이는 리소스의 정보를 어디서 알고있느냐의 차이다.</h3>\n<ul>\n<li>POST : 리소스의 생성을 요청하면, 서버에서 생성정보를 보내줌</li>\n<li>PUT : 클라이언트에서 업데이트 할 리소스를 정해서 보내줌. 이 때, 클라이언트 내에 스토어로 리소스를 따로 관리해줘야하는 전제조건이 있다.</li>\n</ul>\n<h3>11. 배열은 연속되는 순서로 메모리를 차지한다. 인덱스 값은 연속되지만, 주소값은 반드시 연속되어 증가하지 않는다.</h3>\n<h3>12. 자바스크립트 배열은 해시맵과 같아서, 논리값 할당이 가능하다. 단, 배열의 실제길이에 영향을 주지는 않는다.(사용권장X)</h3>\n<h3>13. 연결리스트는 메모리를 순서대로 차지하지 않는다.</h3>","frontmatter":{"title":"✏️ 2022-08-24 Today I Learn","date":"August 24, 2022","update":"August 24, 2022","tags":["TIL","HTTP","자료구조","Javascript"],"series":"TIL"},"fields":{"slug":"/22_08_24/","readingTime":{"minutes":3.32}}},"seriesList":{"edges":[{"node":{"id":"e2e4aaa7-0968-5bbe-8808-c44ecd8527de","fields":{"slug":"/22_08_24/"},"frontmatter":{"title":"✏️ 2022-08-24 Today I Learn"}}},{"node":{"id":"b0fc9180-62b1-58e2-af70-1231ece7a2a6","fields":{"slug":"/22_08_25/"},"frontmatter":{"title":"✏️ 2022-08-25 Today I Learn"}}},{"node":{"id":"6b7d224d-9787-5ad0-a09a-a0aea951c9d3","fields":{"slug":"/22_08_28/"},"frontmatter":{"title":"✏️ 2022-08-28 Today I Learn"}}},{"node":{"id":"76752784-23b0-55ca-bbbd-0ba530241cc0","fields":{"slug":"/22_08_29/"},"frontmatter":{"title":"✏️ 2022-08-29 Today I Learn"}}},{"node":{"id":"de350902-d7dd-5e81-a12c-94f43d5f7ee3","fields":{"slug":"/22_08_30/"},"frontmatter":{"title":"✏️ 2022-08-30 Today I Learn"}}},{"node":{"id":"575c9238-12d9-5cf4-8b8f-fa41caf84d5f","fields":{"slug":"/22_09_02/"},"frontmatter":{"title":"✏️ 2022-09-02 Today I Learn"}}}]},"previous":{"fields":{"slug":"/23_01_3rd/"},"frontmatter":{"title":"✏️ 2023-01-3rd Weekly I Learn"}},"next":{"fields":{"slug":"/22_08_25/"},"frontmatter":{"title":"✏️ 2022-08-25 Today I Learn"}}},"pageContext":{"id":"e2e4aaa7-0968-5bbe-8808-c44ecd8527de","series":"TIL","previousPostId":"f10efb0a-734e-569a-939b-d4a084287816","nextPostId":"b0fc9180-62b1-58e2-af70-1231ece7a2a6"}},"staticQueryHashes":[]}